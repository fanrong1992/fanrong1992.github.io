<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/favicon.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="BruceFan&#39;s Blog">
<meta property="og:url" content="http://example.com/page/11/index.html">
<meta property="og:site_name" content="BruceFan&#39;s Blog">
<meta property="og:locale">
<meta property="article:author" content="Bruce Fan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>BruceFan's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">BruceFan's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry, stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/08/22/Android%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E4%B9%8B%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/08/22/Android%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E4%B9%8B%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">Android动态加载之插件开发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2016-08-22 11:18:41" itemprop="dateCreated datePublished" datetime="2016-08-22T11:18:41+08:00">2016-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>动态加载可以用来进行插件开发，这些插件大概都是为了在一个主程序中实现比较通用的功能，使主程序具有可扩展性。实现原理是实现一套插件接口，把插件实现编成apk或dex，在运行时用DexClassLoader动态加载进来。<br>预备知识：<a target="_blank" rel="noopener" href="http://pwn4.fun/2016/08/16/Android%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">Android中的动态加载机制</a></p>
<h2 id="插件演示"><a href="#插件演示" class="headerlink" title="插件演示"></a>插件演示</h2><p>这里用了三个项目：</p>
<ul>
<li>PInterface：插件接口项目（只是接口的定义）</li>
<li>PImplement：插件项目（实现插件接口，定义具体的功能）</li>
<li>HostProject：宿主项目（需要引用插件接口项目，然后动态加载插件项目）</li>
</ul>
<h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p>下面看一下项目源代码：<br>1.PInterface项目  </p>
<ol>
<li><p>IBean.java  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pluginsdk.interfaces;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBean</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String paramString)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>IDynamic.java  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pluginsdk.interfaces;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDynamic</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodWithCallBack</span><span class="params">(YKCallBack paramYKCallBack)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">showPluginWindow</span><span class="params">(Context paramContext)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startPluginActivity</span><span class="params">(Context context,Class&lt;?&gt; cls)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getStringForResId</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有太多可说的，后面的代码可以下载项目之后自己看。  </p>
</li>
</ol>
<p>2.PImplement项目  </p>
<ol>
<li>Dynamic.java  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pluginsdk.pimplement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.AlertDialog;</span><br><span class="line"><span class="keyword">import</span> android.app.AlertDialog.Builder;</span><br><span class="line"><span class="keyword">import</span> android.app.Dialog;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.DialogInterface;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.pluginsdk.R;</span><br><span class="line"><span class="keyword">import</span> com.pluginsdk.bean.Bean;</span><br><span class="line"><span class="keyword">import</span> com.pluginsdk.interfaces.IDynamic;</span><br><span class="line"><span class="keyword">import</span> com.pluginsdk.interfaces.YKCallBack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dynamic</span> <span class="keyword">implements</span> <span class="title">IDynamic</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodWithCallBack</span><span class="params">(YKCallBack callback)</span> </span>&#123;</span><br><span class="line">        Bean bean = <span class="keyword">new</span> Bean();</span><br><span class="line">        bean.setName(<span class="string">&quot;PLUGIN_SDK_USER&quot;</span>);</span><br><span class="line">        callback.callback(bean);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPluginWindow</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">         AlertDialog.Builder builder = <span class="keyword">new</span> Builder(context);</span><br><span class="line">          builder.setMessage(<span class="string">&quot;对话框&quot;</span>);</span><br><span class="line">          builder.setTitle(R.string.hello_world);</span><br><span class="line">          builder.setNegativeButton(<span class="string">&quot;取消&quot;</span>, <span class="keyword">new</span> Dialog.OnClickListener() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">                   dialog.dismiss();</span><br><span class="line">               &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">          Dialog dialog = builder.create();<span class="comment">//.show();</span></span><br><span class="line">          dialog.show();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startPluginActivity</span><span class="params">(Context context, Class&lt;?&gt; cls)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这里要注意几点:</span></span><br><span class="line"><span class="comment">         * 1、如果单纯的写一个MainActivity的话，在主项目中也有一个MainActivity，开启的Activity还是主项目中的MainActivity</span></span><br><span class="line"><span class="comment">         * 2、如果这里将MainActivity写成全名的话，还是有问题，会报找不到这个Activity的错误</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(context, cls);</span><br><span class="line">        context.startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStringForResId</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context.getResources().getString(R.string.hello_world);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Bean.java  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pluginsdk.bean;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">pluginsdk</span>.<span class="title">interfaces</span>.<span class="title">IBean</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;这是来自于插件项目中设置的初始化的名字&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>3.宿主项目HostProject  </p>
<ol>
<li>MainActivity.java  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.plugindemo;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.annotation.SuppressLint;</span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.res.AssetManager;</span><br><span class="line"><span class="keyword">import</span> android.content.res.Resources;</span><br><span class="line"><span class="keyword">import</span> android.content.res.Resources.Theme;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Environment;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.ListView;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.pluginsdk.interfaces.IBean;</span><br><span class="line"><span class="keyword">import</span> com.pluginsdk.interfaces.IDynamic;</span><br><span class="line"><span class="keyword">import</span> com.pluginsdk.interfaces.YKCallBack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dalvik.system.DexClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AssetManager mAssetManager;<span class="comment">//资源管理器</span></span><br><span class="line">    <span class="keyword">private</span> Resources mResources;<span class="comment">//资源</span></span><br><span class="line">    <span class="keyword">private</span> Theme mTheme;<span class="comment">//主题</span></span><br><span class="line">    <span class="keyword">private</span> String apkFileName = <span class="string">&quot;Pimplement.apk&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String dexpath = <span class="keyword">null</span>;<span class="comment">//apk文件地址</span></span><br><span class="line">    <span class="keyword">private</span> File fileRelease = <span class="keyword">null</span>; <span class="comment">//释放目录</span></span><br><span class="line">    <span class="keyword">private</span> DexClassLoader classLoader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@SuppressLint(&quot;NewApi&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        dexpath = getApplicationContext().getFilesDir().getAbsolutePath() + File.separator + apkFileName;</span><br><span class="line">        fileRelease = getDir(<span class="string">&quot;dex&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*初始化classloader</span></span><br><span class="line"><span class="comment">         * dexpath dex文件地址</span></span><br><span class="line"><span class="comment">         * fileRelease 文件释放地址 </span></span><br><span class="line"><span class="comment">         * 父classLoader</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        classLoader = <span class="keyword">new</span> DexClassLoader(dexpath, fileRelease.getAbsolutePath(), <span class="keyword">null</span>, getClassLoader());</span><br><span class="line">        </span><br><span class="line">        Button btn_1 = (Button)findViewById(R.id.btn_1);</span><br><span class="line">        Button btn_2 = (Button)findViewById(R.id.btn_2);</span><br><span class="line">        Button btn_3 = (Button)findViewById(R.id.btn_3);</span><br><span class="line">        Button btn_4 = (Button)findViewById(R.id.btn_4);</span><br><span class="line">        Button btn_5 = (Button)findViewById(R.id.btn_5);</span><br><span class="line">        Button btn_6 = (Button)findViewById(R.id.btn_6);</span><br><span class="line">        </span><br><span class="line">        btn_1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;<span class="comment">//普通调用  反射的方式</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Class mLoadClassBean;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mLoadClassBean = classLoader.loadClass(<span class="string">&quot;com.pluginsdk.bean.Bean&quot;</span>);</span><br><span class="line">                    Object beanObject = mLoadClassBean.newInstance();</span><br><span class="line">                    Log.d(<span class="string">&quot;DEMO&quot;</span>, <span class="string">&quot;ClassLoader:&quot;</span> + mLoadClassBean.getClassLoader());</span><br><span class="line">                    Log.d(<span class="string">&quot;DEMO&quot;</span>, <span class="string">&quot;ClassLoader:&quot;</span> + mLoadClassBean.getClassLoader().getParent());</span><br><span class="line">                    Method getNameMethod = mLoadClassBean.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">                    getNameMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    String name = (String) getNameMethod.invoke(beanObject);</span><br><span class="line">                    Toast.makeText(MainActivity.<span class="keyword">this</span>, name, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Log.e(<span class="string">&quot;DEMO&quot;</span>, <span class="string">&quot;msg:&quot;</span>+e.getMessage());</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        btn_2.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;<span class="comment">//带参数调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View arg0)</span> </span>&#123;</span><br><span class="line">                Class mLoadClassBean;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mLoadClassBean = classLoader.loadClass(<span class="string">&quot;com.pluginsdk.bean.Bean&quot;</span>);</span><br><span class="line">                    Object beanObject = mLoadClassBean.newInstance();</span><br><span class="line">                    <span class="comment">//接口形式调用</span></span><br><span class="line">                    Log.d(<span class="string">&quot;DEMO&quot;</span>, beanObject.getClass().getClassLoader()+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                    Log.d(<span class="string">&quot;DEMO&quot;</span>,IBean.class.getClassLoader()+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                    Log.d(<span class="string">&quot;DEMO&quot;</span>,ClassLoader.getSystemClassLoader()+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                    IBean bean = (IBean)beanObject;</span><br><span class="line">                    bean.setName(<span class="string">&quot;宿主程序设置的新名字&quot;</span>);</span><br><span class="line">                    Toast.makeText(MainActivity.<span class="keyword">this</span>, bean.getName(), Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Log.e(<span class="string">&quot;DEMO&quot;</span>, <span class="string">&quot;msg:&quot;</span>+e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        btn_3.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;<span class="comment">//带回调函数的调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View arg0)</span> </span>&#123;</span><br><span class="line">                Class mLoadClassDynamic;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mLoadClassDynamic = classLoader.loadClass(<span class="string">&quot;com.pluginsdk.pimplement.Dynamic&quot;</span>);</span><br><span class="line">                     Object dynamicObject = mLoadClassDynamic.newInstance();</span><br><span class="line">                      <span class="comment">//接口形式调用</span></span><br><span class="line">                    IDynamic dynamic = (IDynamic)dynamicObject;</span><br><span class="line">                    <span class="comment">//回调函数调用</span></span><br><span class="line">                    YKCallBack callback = <span class="keyword">new</span> YKCallBack() &#123;<span class="comment">//回调接口的定义</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">(IBean arg0)</span> </span>&#123;</span><br><span class="line">                            Toast.makeText(MainActivity.<span class="keyword">this</span>, arg0.getName(), Toast.LENGTH_SHORT).show();</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    dynamic.methodWithCallBack(callback);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Log.e(<span class="string">&quot;DEMO&quot;</span>, <span class="string">&quot;msg:&quot;</span>+e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        btn_4.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;<span class="comment">//带资源文件的调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View arg0)</span> </span>&#123;</span><br><span class="line">                loadResources();</span><br><span class="line">                Class mLoadClassDynamic;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mLoadClassDynamic = classLoader.loadClass(<span class="string">&quot;com.pluginsdk.pimplement.Dynamic&quot;</span>);</span><br><span class="line">                    Object dynamicObject = mLoadClassDynamic.newInstance();</span><br><span class="line">                    <span class="comment">//接口形式调用</span></span><br><span class="line">                    IDynamic dynamic = (IDynamic)dynamicObject;</span><br><span class="line">                    dynamic.showPluginWindow(MainActivity.<span class="keyword">this</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Log.e(<span class="string">&quot;DEMO&quot;</span>, <span class="string">&quot;msg:&quot;</span>+e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        btn_5.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;<span class="comment">//带资源文件的调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View arg0)</span> </span>&#123;</span><br><span class="line">                loadResources();</span><br><span class="line">                Class mLoadClassDynamic;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mLoadClassDynamic = classLoader.loadClass(<span class="string">&quot;com.pluginsdk.pimplement.Dynamic&quot;</span>);</span><br><span class="line">                    Object dynamicObject = mLoadClassDynamic.newInstance();</span><br><span class="line">                    <span class="comment">//接口形式调用</span></span><br><span class="line">                    IDynamic dynamic = (IDynamic)dynamicObject;</span><br><span class="line">                    dynamic.startPluginActivity(MainActivity.<span class="keyword">this</span>,</span><br><span class="line">                            classLoader.loadClass(<span class="string">&quot;com.plugindemo.MainActivity&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Log.e(<span class="string">&quot;DEMO&quot;</span>, <span class="string">&quot;msg:&quot;</span>+e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        btn_6.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;<span class="comment">//带资源文件的调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View arg0)</span> </span>&#123;</span><br><span class="line">                loadResources();</span><br><span class="line">                Class mLoadClassDynamic;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mLoadClassDynamic = classLoader.loadClass(<span class="string">&quot;com.pluginsdk.pimplement.Dynamic&quot;</span>);</span><br><span class="line">                    Object dynamicObject = mLoadClassDynamic.newInstance();</span><br><span class="line">                    <span class="comment">//接口形式调用</span></span><br><span class="line">                    IDynamic dynamic = (IDynamic)dynamicObject;</span><br><span class="line">                    String content = dynamic.getStringForResId(MainActivity.<span class="keyword">this</span>);</span><br><span class="line">                    Toast.makeText(getApplicationContext(), content+<span class="string">&quot;&quot;</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Log.e(<span class="string">&quot;DEMO&quot;</span>, <span class="string">&quot;msg:&quot;</span>+e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AssetManager assetManager = AssetManager.class.newInstance();</span><br><span class="line">                Method addAssetPath = assetManager.getClass().getMethod(<span class="string">&quot;addAssetPath&quot;</span>, String.class);</span><br><span class="line">                addAssetPath.invoke(assetManager, dexpath);</span><br><span class="line">                mAssetManager = assetManager;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            Resources superRes = <span class="keyword">super</span>.getResources();</span><br><span class="line">            superRes.getDisplayMetrics();</span><br><span class="line">            superRes.getConfiguration();</span><br><span class="line">            mResources = <span class="keyword">new</span> Resources(mAssetManager, superRes.getDisplayMetrics(),superRes.getConfiguration());</span><br><span class="line">            mTheme = mResources.newTheme();</span><br><span class="line">            mTheme.setTo(<span class="keyword">super</span>.getTheme());</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AssetManager <span class="title">getAssets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mAssetManager == <span class="keyword">null</span> ? <span class="keyword">super</span>.getAssets() : mAssetManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resources <span class="title">getResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mResources == <span class="keyword">null</span> ? <span class="keyword">super</span>.getResources() : mResources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Theme <span class="title">getTheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mTheme == <span class="keyword">null</span> ? <span class="keyword">super</span>.getTheme() : mTheme;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="项目引用关系"><a href="#项目引用关系" class="headerlink" title="项目引用关系"></a>项目引用关系</h3><p>1.将接口项目PInterface设置成一个Library，<br><img src="/images/androidplugin/library.png"><br>并导出项目为一个jar。<br><img src="/images/androidplugin/jar.png"><br>2.插件项目PImplement引用接口项目的jar<br>注意是lib文件夹，而不是libs，在<a target="_blank" rel="noopener" href="http://pwn4.fun/2016/08/16/Android%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">Android中的动态加载机制</a><br>中说过这样做的原因：<strong>插件项目打包不能集成接口jar，宿主项目打包一定要集成接口jar</strong>。<br><img src="/images/androidplugin/plugin.png"><br>3.HostProject项目引用PInterface这个Library<br><img src="/images/androidplugin/host.png"><br>项目引用完成后，我们编译PImplement项目，生成PImplement.apk放到/data/data/com.plugindemo/files，因为代码中是从这个目录进行加载的，这个目录是可以修改的。运行HostProject<br><img src="/images/androidplugin/run.png"><br>运行成功，这个对话框其实是在插件中定义的。<br><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1kVtt01L">项目下载</a><br><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/jiangwei0910410003/article/details/41384667">http://blog.csdn.net/jiangwei0910410003/article/details/41384667</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/08/20/C-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bvector%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/08/20/C-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bvector%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/" class="post-title-link" itemprop="url">C++标准库类型vector和迭代器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2016-08-20 20:44:23" itemprop="dateCreated datePublished" datetime="2016-08-20T20:44:23+08:00">2016-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>忘了说我的运行环境是Ubuntu14.04，vim，gcc version 4.8.4，操作系统和编辑器没什么要紧，gcc如果版本低了可能不支持C++11。<br>编译运行方法如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -std&#x3D;c++11 -o test test.c</span><br><span class="line">$ .&#x2F;test</span><br></pre></td></tr></table></figure>

<h2 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h2><p>标准库类型vector（也常被称为<code>容器</code>）表示对象的集合，其中所有对象的类型都相同。集合中每个对象都有一个与之对应的索引，索引用于访问对象。想要使用vector，必须包含头文件。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br></pre></td></tr></table></figure>
<p>C++语言既有<code>类模板（class template）</code>，也有<code>函数模板</code>。编译器根据模板创建类或函数的过程称为<code>实例化（instantiation）</code>。模板名字后面跟一对尖括号，在括号内放上存放对象的类型。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec; <span class="comment">// ivec保存int类型的对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Sales_item&gt; Sales_vec; <span class="comment">// 保存Sales_item类型的对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; file; <span class="comment">// 该向量的元素是vector对象</span></span><br></pre></td></tr></table></figure>

<h3 id="定义vector对象"><a href="#定义vector对象" class="headerlink" title="定义vector对象"></a>定义vector对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec; <span class="comment">// 默认初始化为空</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec2</span><span class="params">(ivec)</span></span>; <span class="comment">// 把ivec的元素拷贝给ivec2</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec3 = ivec; <span class="comment">// 把ivec的元素拷贝给ivec3</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。</p>
</blockquote>
<p><strong>列表初始化vector对象</strong>  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>&#125;; <span class="comment">// ivec包含了三个元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">// ivec包含了2，3，4，5四个元素</span></span><br></pre></td></tr></table></figure>
<p><strong>创建指定数量的元素</strong>  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>, <span class="number">-1</span>)</span></span>; <span class="comment">// ivec包含了10个-1</span></span><br></pre></td></tr></table></figure>

<h3 id="向vector对象中添加元素"><a href="#向vector对象中添加元素" class="headerlink" title="向vector对象中添加元素"></a>向vector对象中添加元素</h3><p>vector的成员函数<code>push_back</code>可以向其中添加元素，push_back负责把一个值当成vector对象的尾元素压到vector对象的尾端。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2; <span class="comment">// 空</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">100</span>; ++i)</span><br><span class="line">    v2.push_back(i); <span class="comment">// 依次把i添加到v2尾端</span></span><br><span class="line"></span><br><span class="line">sting word;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; text; <span class="comment">// 空</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word) &#123;</span><br><span class="line">    text.push_back(word); <span class="comment">// 把word添加到text后面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他vector操作"><a href="#其他vector操作" class="headerlink" title="其他vector操作"></a>其他vector操作</h3><table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">v.empty()</td>
<td align="left">如果v不含任何元素返回真；否则返回假</td>
</tr>
<tr>
<td align="left">v.size()</td>
<td align="left">返回v中元素的个数</td>
</tr>
<tr>
<td align="left">v[n]</td>
<td align="left">返回v中第n个位置上元素的引用</td>
</tr>
<tr>
<td align="left">v1 == v2</td>
<td align="left">v1和v2对应位置的元素都相同</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : v) <span class="comment">// 这里i为引用</span></span><br><span class="line">        i *= i; <span class="comment">// 求元素的平方</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : v)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出容器中的元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>除了下标运算符可以访问string对象或vector对象的元素，<code>迭代器（iterator）</code>也可以。除了vector，标准库还定义了其他几种容器，所有标准库容器都可以使用迭代器。<br>和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b表示v的第一个元素的位置，e表示v尾元素的下一个位置</span></span><br><span class="line"><span class="keyword">auto</span> b = v.begin(), e = v.end();</span><br></pre></td></tr></table></figure>
<p>end成员返回的迭代器常被称作<code>尾后迭代器（off-the-end iterator）</code>。</p>
<blockquote>
<p>如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器。</p>
</blockquote>
<h3 id="迭代器运算符"><a href="#迭代器运算符" class="headerlink" title="迭代器运算符"></a>迭代器运算符</h3><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">*iter</td>
<td align="left">返回迭代器iter所指元素的引用</td>
</tr>
<tr>
<td align="left">iter-&gt;mem</td>
<td align="left">解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem</td>
</tr>
<tr>
<td align="left">++iter</td>
<td align="left">令iter指示容器中的下一个元素</td>
</tr>
<tr>
<td align="left">–iter</td>
<td align="left">令iter指示容器中的上一个元素</td>
</tr>
<tr>
<td align="left">iter1 == iter2</td>
<td align="left">判断两个迭代器是否相等</td>
</tr>
<tr>
<td align="left">iter1 != iter2</td>
<td align="left">判断两个迭代器是否不相等</td>
</tr>
</tbody></table>
<p>和指针类似，也能通过解引用迭代器来获取他所指示的元素。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依次处理s的字符直至我们处理完全部字符或遇到空格</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = s.begin(); it != s.end() &amp;&amp; !<span class="built_in">isspace</span>(*it); ++it)</span><br><span class="line">    *it = <span class="built_in">toupper</span>(*it);</span><br></pre></td></tr></table></figure>

<h3 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h3><p>拥有迭代器的标准库类型使用<code>iterator</code>和<code>const_iterator</code>来表示迭代器的类型：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it; <span class="comment">// it能读写vector&lt;int&gt;的元素</span></span><br><span class="line"><span class="keyword">for</span> (it = v.begin(); it != v.end(); ++i) &#123;</span><br><span class="line">    *it *= *it; <span class="comment">// 正确，可以读写元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator cit; <span class="comment">// cit只能读vector&lt;int&gt;的元素，不能写</span></span><br><span class="line"><span class="keyword">for</span> (cit = v.begin(); it != v.end(); ++i) &#123;</span><br><span class="line">    *cit *= *cit; <span class="comment">// 错误，只能读不能写</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *cit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果vector对象是一个常量<code>（const vector&lt;int&gt;）</code>，只能用const_iterator；如果不是常量，则iterator和const_iterator都可以用。C++11新标准引入了<code>cbegin()</code>和<code>cend()</code>两个新函数，不论vector对象是否是常量，返回值都是const_vector。</p>
<h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算得到最接近vi中间元素的一个迭代器</span></span><br><span class="line"><span class="keyword">auto</span> mid = vi.begin + v.size()/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (it &lt; mid)</span><br><span class="line">    <span class="comment">// 处理vi前半部分的元素</span></span><br></pre></td></tr></table></figure>
<p><strong>迭代器实现二分搜索</strong>  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// text必须是有序的，beg和end表示我们搜索的范围</span></span><br><span class="line"><span class="keyword">auto</span> beg = text.begin(), end = text.end();</span><br><span class="line"><span class="keyword">auto</span> mid = text.begin() + (end - beg) / <span class="number">2</span>; <span class="comment">// 初始状态下的中间点</span></span><br><span class="line"><span class="comment">// 当还有元素尚未检查并且我们还没有找到sought时执行循环</span></span><br><span class="line"><span class="keyword">while</span> (mid != end &amp;&amp; *mid != sought) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sought &lt; *mid)</span><br><span class="line">        end = mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        beg = mid + <span class="number">1</span>;</span><br><span class="line">    mid = beg + (end - beg) / <span class="number">2</span>; <span class="comment">// 新的中间点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/08/19/Android%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/08/19/Android%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95/" class="post-title-link" itemprop="url">Android内核源码编译调试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2016-08-19 15:40:02" itemprop="dateCreated datePublished" datetime="2016-08-19T15:40:02+08:00">2016-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>下面的方法是基于编译完Android系统源码之后，再另外下载Linux内核进行编译调试的。我在<a target="_blank" rel="noopener" href="http://pwn4.fun/2016/03/03/%E7%BC%96%E8%AF%91Android6-0-1%E6%BA%90%E7%A0%81%EF%BC%8C%E7%83%A7%E5%BD%95%E5%88%B0nexus5%E7%9C%9F%E6%9C%BA%E4%B8%8A/">编译Android6.0.1源码，烧录到nexus5真机上</a>这篇文章中编译的是<code>lunch 8</code>，即aosp_hammerhead-userdebug，但是用<code>emulator</code>启动模拟器时，需要用模拟器版本的编译<code>lunch 1</code>，即aosp_arm-eng。  </p>
<h3 id="下载Android内核源码"><a href="#下载Android内核源码" class="headerlink" title="下载Android内核源码"></a>下载Android内核源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;Computer&#x2F;Android&#x2F;android4.4.2&#x2F;kernel</span><br><span class="line">$ git clone https:&#x2F;&#x2F;android.googlesource.com&#x2F;kernel&#x2F;goldfish.git</span><br><span class="line">$ cd goldfish</span><br></pre></td></tr></table></figure>
<p>Goldfish是一种虚拟的ARM处理器，在android的仿真环境中使用。<br>查看支持哪些Linux内核版本的下载：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -a</span><br></pre></td></tr></table></figure>
<p>选择3.4内核版本进行下载：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -t remotes&#x2F;origin&#x2F;android-goldfish-3.4 -b goldfish3.4</span><br></pre></td></tr></table></figure>
<p>分支goldfish3.4设置为跟踪来自origin的远程分支android-goldfish-3.4，切换到一个新分支<code>goldfish3.4</code>。</p>
<h3 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ make menuconfig # 到Kernel hacking中打开Compile the kernel with debug info、Enable dynamic printk() support、KGDB</span><br><span class="line">$ make ARCH&#x3D;arm goldfish_armv7_defconfig</span><br><span class="line">$ make ARCH&#x3D;arm SUBARCH&#x3D;arm CROSS_COMPILE&#x3D;&#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;Android&#x2F;android4.4.2&#x2F;prebuilts&#x2F;gcc&#x2F;linux-x86&#x2F;arm&#x2F;arm-eabi-4.7&#x2F;bin&#x2F;arm-eabi-</span><br><span class="line"></span><br><span class="line">... &#x2F;&#x2F; 一路Enter</span><br><span class="line">OBJCOPY arch&#x2F;arm&#x2F;boot&#x2F;zImage</span><br><span class="line">Kernel: arch&#x2F;arm&#x2F;boot&#x2F;zImage is ready</span><br></pre></td></tr></table></figure>
<p>我编译的时候出过一些错误，也不知道怎么解决，MD再编译一遍错误就没有了，编译了3遍就成功了，还好内核源码编译比系统源码编译快。</p>
<h3 id="在模拟器中运行编译的内核"><a href="#在模拟器中运行编译的内核" class="headerlink" title="在模拟器中运行编译的内核"></a>在模拟器中运行编译的内核</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd ..&#x2F;..</span><br><span class="line">$ source build&#x2F;envsetup.sh</span><br><span class="line">$ lunch</span><br><span class="line">[aosp_arm-eng]</span><br><span class="line">$ emulator -debug init -kernel kernel&#x2F;goldfish&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;zImage -system out&#x2F;target&#x2F;product&#x2F;generic&#x2F;system.img -ramdisk out&#x2F;target&#x2F;product&#x2F;generic&#x2F;ramdisk.img</span><br></pre></td></tr></table></figure>
<p><img src="/images/androidkernel/kernel.png" alt="用已编译的内核启动Android模拟器"></p>
<h3 id="调试Android内核"><a href="#调试Android内核" class="headerlink" title="调试Android内核"></a>调试Android内核</h3><p>首先要在/tmp文件夹下创建一个qemu文件夹，再在qemu里创建Socket文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;tmp; mkdir qemu; cd qemu; touch Socket</span><br><span class="line"># 回到Android源码根目录</span><br><span class="line">$ emulator -debug init -kernel kernel&#x2F;goldfish&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;zImage -system out&#x2F;target&#x2F;product&#x2F;generic&#x2F;system.img -ramdisk out&#x2F;target&#x2F;product&#x2F;generic&#x2F;ramdisk.img -qemu -monitor unix:&#x2F;tmp&#x2F;qemu&#x2F;Socket,server,nowait -s</span><br></pre></td></tr></table></figure>
<p>配置一个环境变量，在PATH中加入arm-linux-androideabi-gdb所在路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;Android&#x2F;android4.4.2&#x2F;prebuilts&#x2F;gcc&#x2F;linux-x86&#x2F;arm&#x2F;arm-linux-androideabi-4.7&#x2F;bin</span><br></pre></td></tr></table></figure>
<p>另开一个终端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 到goldfish目录中</span><br><span class="line">$ arm-linux-androideabi-gdb vmlinux</span><br><span class="line">...</span><br><span class="line">(gdb) target remote :1234</span><br><span class="line">Remote debugging using :1234</span><br><span class="line">0xc00155c8 in cpu_v7_do_idle ()</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p><strong>reference</strong><br><a target="_blank" rel="noopener" href="https://github.com/Fuzion24/AndroidKernelExploitationPlayground">https://github.com/Fuzion24/AndroidKernelExploitationPlayground</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/08/17/C-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/08/17/C-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">C++变量和基本类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2016-08-17 10:42:53" itemprop="dateCreated datePublished" datetime="2016-08-17T10:42:53+08:00">2016-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><code>引用（reference）</code>为对象起了另外一个名字。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal = ival; <span class="comment">// refVal指向ival</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal2; <span class="comment">// 报错：引用必须被初始化</span></span><br></pre></td></tr></table></figure>
<p>定义引用时，程序把引用和它的初始值<code>绑定</code>在一起，而不是将初始值拷贝给引用。无法令引用重新绑定到另外一个对象，因此引用必须初始化。<br><strong>引用即别名</strong> 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。<br>定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">refVal = <span class="number">2</span>; <span class="comment">// 把2赋值给ival</span></span><br></pre></td></tr></table></figure>

<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针与引用类似，也实现了对其它对象的间接访问。不同于引用的是：</p>
<ul>
<li>指针本身是一个对象，允许对其赋值和拷贝，生命周期内它可以指向几个不同的对象。</li>
<li>指针无需在定义时赋初值。</li>
</ul>
<p><strong>获取对象的地址</strong><br>指针存放某个对象的地址，获取该地址需要<code>取地址符 &amp;</code>  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;ival; <span class="comment">// p存放变量ival的地址，或者说p是指向变量ival的指针</span></span><br></pre></td></tr></table></figure>
<p><strong>利用指针访问对象</strong><br>如果指针指向了一个对象，则允许使用<code>解引用符 *</code>来访问该对象。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; *p; <span class="comment">// 由符号*得到指针p所指的对象，输出42</span></span><br></pre></td></tr></table></figure>
<p><strong>空指针</strong><br>空指针不指向任何对象。C++11初始化空指针的方法：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><p>关键字<code>const</code>定义常量，const对象一旦创建后其值就不能再改变了，所以const对象必须初始化。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bufSize = <span class="number">512</span>;</span><br></pre></td></tr></table></figure>

<h3 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a>const的引用</h3><p>可以把引用绑定到const对象上，我们称之为<code>对常量的引用</code>，对常量的引用不能被用作修改它所绑定的对象。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci; <span class="comment">// 引用及其对应的对象都是常量</span></span><br></pre></td></tr></table></figure>

<h3 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h3><p><code>指向常量的指针(pointer to const)</code>不能用于改变其所指对象的值，要想存放常量对象的地址，只能使用指向常量的指针。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi; <span class="comment">// cptr可以指向一个双精度常量</span></span><br></pre></td></tr></table></figure>
<p>指针是对象而引用不是，允许把指针本身定为常量。<code>常量指针(const pointer)</code>必须初始化，*放在const关键字之前用以说明指针是一个常量，即不变的是指针本身的值而非指向的那个值。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb; <span class="comment">// curErr将一直指向errNumb</span></span><br></pre></td></tr></table></figure>

<h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3><p>用名词<code>顶层const</code>表示指针本身是个常量，而用名词<code>底层const</code>表示指针所指的对象是一个常量。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i; <span class="comment">// 不能改变p1的值，顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>; <span class="comment">// 不能改变ci的值，顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci; <span class="comment">// 可以改变p2的值，底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = ci; <span class="comment">// 用于声明引用的const都是底层const</span></span><br></pre></td></tr></table></figure>

<h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p><code>类型别名(type alias)</code>是一个名字，它是某种类型的同义词。有两种方法定义类型别名：  </p>
<ul>
<li><p>传统方法是用关键字<code>typedef</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages; <span class="comment">// wages是double的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">// base是double的同义词，p是double*的同义词</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(* _prepare_kernel_cred)</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred)</span></span>;</span><br><span class="line">_prepare_kernel_cred prepare_kernel_cred;</span><br></pre></td></tr></table></figure>
<p>以上两句就相当于：unsigned long (*prepare_kernel_cred)(unsigned long cred);<br>定义了一个函数指针prepare_kernel_cred，函数参数为(unsigned long cred)，返回值为unsigned long。<br>建立一个类型别名的方法很简单，在传统的变量声明表达式里用类型名替代变量名，然后把关键字typedef加在该语句的开头。</p>
</li>
<li><p>新标准使用<code>别名声明(alias declaration)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = Sales_item; <span class="comment">// SI是Sales_item的同义词</span></span><br></pre></td></tr></table></figure>
<p>这种方法用关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。</p>
</li>
</ul>
<h3 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h3><p>编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候就清楚地知道表达式的类型。然而有时做不到这样，因此，C++11新标准引入了auto类型说明符，它能让编译器替我们去分析表达式所属的类型，让编译器通过初始值来推算变量的类型。auto定义的变量必须有初始值。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> item = val1 + val2; <span class="comment">// item初始化为val1和val2相加的结果</span></span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, *p = &amp;i;     <span class="comment">// 正确：i是整数、p是整形指针</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>;  <span class="comment">// 错误：sz和pi的类型不一致</span></span><br></pre></td></tr></table></figure>

<h3 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h3><p>有时希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(f()) sum = x; <span class="comment">// sum的类型就是函数f的返回类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>; <span class="comment">// x的类型是const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x; <span class="comment">// y的类型是const int &amp;， y绑定到变量x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z; <span class="comment">// 错误：z是一个引用，必须初始化</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/08/16/Android%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/08/16/Android%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Android中的动态加载机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2016-08-16 22:09:02" itemprop="dateCreated datePublished" datetime="2016-08-16T22:09:02+08:00">2016-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文主要介绍Android动态加载jar的技术，如何开发一个可以自定义控件的Android应用？就像eclipse一样，可以动态加载插件；如何让Android应用执行服务器上的不可预知的代码？如何对Android应用加密，而只在执行时自解密，从而防止被破解？这篇文章是一个基础，后面的一些文章会以此继续深入。  </p>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>Dalvik虚拟机如同其他Java虚拟机一样，在运行程序时首先需要将对应的类加载到内存中。而在Java标准的虚拟机中，类加载可以从class文件中读取，也可以是其他形式的二进制流，因此，我们常常利用这一点，在程序运行时手动加载Class，从而达到代码动态加载执行的目的。<br>然而Dalvik虚拟机毕竟不算是标准的Java虚拟机，因此在类加载机制上，它们有相同的地方，也有不同之处。例如，在使用标准Java虚拟机时，我们经常自定义继承自<code>ClassLoader</code>的类加载器。然后通过<code>defineClass</code>方法来从一个二进制流中加载Class，然而，这在Android里是行不通的。参看源码我们知道，Android中ClassLoader的defineClass方法具体是调用<code>VMClassLoader</code>的defineClass本地静态方法。而这个本地方法除了抛出一个<code>UnsupportedOperationException</code>之外，什么都没做，甚至连返回值都为空。<br><strong>代码清单</strong> /dalvik/vm/native/java_lang_VMClassLoader.cpp  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Dalvik_java_lang_VMClassLoader_defineClass</span><span class="params">(<span class="keyword">const</span> u4* args, JValue* pResult)</span> </span>&#123;  </span><br><span class="line">    Object* loader = (Object*) args[<span class="number">0</span>];</span><br><span class="line">    StringObject* nameObj = (StringObject*) args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> u1* data = (<span class="keyword">const</span> u1*) args[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> offset = args[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> len = args[<span class="number">4</span>];</span><br><span class="line">    Object* pd = (Object*) args[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">char</span>* name = <span class="literal">NULL</span>;</span><br><span class="line">    name = dvmCreateCstrFromString(nameObj);</span><br><span class="line">    LOGE(<span class="string">&quot;ERROR: defineClass(%p, %s, %p, %d, %d, %p)\n&quot;</span>,loader, name, data, offset, len, pd);</span><br><span class="line">    dvmThrowException(<span class="string">&quot;Ljava/lang/UnsupportedOperationException;&quot;</span>,<span class="string">&quot;can&#x27;t load this type of class file&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(name);</span><br><span class="line">    RETURN_VOID();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="Dalvik虚拟机类加载机制"><a href="#Dalvik虚拟机类加载机制" class="headerlink" title="Dalvik虚拟机类加载机制"></a>Dalvik虚拟机类加载机制</h2><p>那如果在Dalvik虚拟机里，ClassLoader不好使，我们如何实现动态加载类呢？Android为我们从ClassLoader派生出了两个类：<code>DexClassLoader</code>（/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java）和<code>PathClassLoader</code>（/libcore/dalvik/src/main/java/dalvik/system/PathClassLoader.java）。这两个继承自ClassLoader的类加载器，本质上是重载了ClassLoader的findClass方法。在执行loadClass时，我们可以参看ClassLoader部分源码：<br><strong>代码清单</strong> /libcore/libdvm/src/main/java/java/lang/ClassLoader.java: loadClass()  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String className, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">Class&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = parent.loadClass(className, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Don&#x27;t want to see this.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = findClass(className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此DexClassLoader和PathClassLoader都属于符合<code>双亲委派模型</code>的类加载器（因为它们没有重载loadClass方法）。也就是说，它们在加载一个类之前，回去检查自己以及自己以上的类加载器是否已经加载了这个类。如果已经加载过了，就会直接将之返回，而不会重复加载。<br>DexClassLoader和PathClassLoader其实都是通过<code>DexFile</code>这个类来实现类加载的。这里需要顺便提一下的是，Dalvik虚拟机识别的是dex文件，而不是class文件。因此，我们供类加载的文件也只能是dex文件，或者包含有dex文件的apk或jar文件。<br>PathClassLoader是通过构造函数<code>new DexFile(path)</code>来产生DexFile对象的；而DexClassLoader则是通过其静态方法<code>loadDex(path, outpath, 0)</code>得到DexFile对象。<br>PathClassLoader是Android应用中的<code>默认加载器</code>。这两者的区别在于：</p>
<ul>
<li>DexClassLoader可以加载任意路径的apk、jar和dex文件，并且会在指定的outpath路径释放出dex文件。</li>
<li>PathClassLoader只能加载<code>/data/app</code>中的apk，也就是已经安装到手机中的apk。这个也是PathClassLoader作为默认类加载器的原因，因为一般程序都是安装了再打开。</li>
</ul>
<p>另外，PathClassLoader在加载类时调用的是DexFile的<code>loadClassBinaryName</code>，而DexClassLoader调用的是<code>loadClass</code>。因此，在使用PathClassLoader时类全名需要用<code>/</code>替换<code>.</code><br>下面看一下Android中的各种类加载器分别加载哪些类：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.androiddemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.widget.ListView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">// java.lang.BootClassLoader，也继承了ClassLoader类</span></span><br><span class="line">        Log.i(<span class="string">&quot;DEMO&quot;</span>, <span class="string">&quot;Context的类加载加载器:&quot;</span>+Context.class.getClassLoader());</span><br><span class="line">        Log.i(<span class="string">&quot;DEMO&quot;</span>, <span class="string">&quot;ListView的类加载器:&quot;</span>+ListView.class.getClassLoader());</span><br><span class="line">        <span class="comment">// dalvik.system.PathClassLoader</span></span><br><span class="line">        Log.i(<span class="string">&quot;DEMO&quot;</span>, <span class="string">&quot;应用程序默认加载器:&quot;</span>+getClassLoader());</span><br><span class="line">        Log.i(<span class="string">&quot;DEMO&quot;</span>, <span class="string">&quot;系统类加载器:&quot;</span>+ClassLoader.getSystemClassLoader());</span><br><span class="line">        <span class="comment">// 默认加载器PathClassLoader的父亲是BootClassLoader</span></span><br><span class="line">        Log.i(<span class="string">&quot;DEMO&quot;</span>,<span class="string">&quot;打印应用程序默认加载器的委派机制:&quot;</span>);</span><br><span class="line">        ClassLoader classLoader = getClassLoader();</span><br><span class="line">        <span class="keyword">while</span>(classLoader != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Log.i(<span class="string">&quot;DEMO&quot;</span>, <span class="string">&quot;类加载器:&quot;</span>+classLoader);</span><br><span class="line">            classLoader = classLoader.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 系统加载器PathClassLoader的父亲也是BootClassLoader</span></span><br><span class="line">        Log.i(<span class="string">&quot;DEMO&quot;</span>,<span class="string">&quot;打印系统加载器的委派机制:&quot;</span>);</span><br><span class="line">        classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        <span class="keyword">while</span>(classLoader != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Log.i(<span class="string">&quot;DEMO&quot;</span>, <span class="string">&quot;类加载器:&quot;</span>+classLoader);</span><br><span class="line">            classLoader = classLoader.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>使用到的工具都比较常规：javac、dx、eclipse等其中dx工具最好是指明–no-strict，因为class文件的路径可能不匹配。<br>加载好类后，通常我们可以通过Java反射机制来使用这个类，但是这样效率相对不高，而且老用反射代码也比较复杂凌乱。更好的做法是定义一个interface，并将这个interface写进宿主程序里。待加载的类，继承自这个interface，并且有一个参数为空的构造函数，以使我们能够通过Class的newInstance方法产生对象然后将对象强制转换为interface对象，于是就可以直接调用成员方法了，下面是具体的实现步骤了:<br><strong>第一步</strong><br>编写好动态代码类：<br><img src="/images/dynamicload/structure.png"><br><strong>代码清单</strong> IDynamic.java  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dynamic.interfaces;</span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDynamic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Activity activity)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBanner</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showDialog</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showFullScreen</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAppWall</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码清单</strong> Dynamic.java  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dynamic.impl;</span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"><span class="keyword">import</span> com.dynamic.interfaces.IDynamic;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dynamic</span> <span class="keyword">implements</span> <span class="title">IDynamic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Activity mActivity;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        mActivity = activity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBanner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Toast.makeText(mActivity, <span class="string">&quot;我是ShowBanner方法&quot;</span>, <span class="number">1500</span>).show();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showDialog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Toast.makeText(mActivity, <span class="string">&quot;我是ShowDialog方法&quot;</span>, <span class="number">1500</span>).show();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showFullScreen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Toast.makeText(mActivity, <span class="string">&quot;我是ShowFullScreen方法&quot;</span>, <span class="number">1500</span>).show();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAppWall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Toast.makeText(mActivity, <span class="string">&quot;我是ShowAppWall方法&quot;</span>, <span class="number">1500</span>).show();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第二步</strong><br>将上面开发好的动态类打包成jar，这里要注意的是只打包实现类Dynamic.java，不打包接口类IDynamic.java<br>右键项目-&gt;Export<br><img src="/images/dynamicload/exportjar.png"><br>点击next<br><img src="/images/dynamicload/export.png"><br>然后使用dx命令:(我的jar文件是dynamic.jar)<br><code>dx --dex --output=dynamic_temp.jar dynamic.jar</code><br>这样就生成了dynamic_temp.jar，这个jar和dynamic.jar有什么区别呢？<br>其实这条命令主要做的工作是：首先将dynamic.jar编译成dynamic.dex文件(Android虚拟机认识的字节码文件)，然后再将dynamic.dex文件压缩成dynamic_temp.jar，当然你也可以压缩成zip格式的，或者直接编译成apk文件都可以的，这个后面会说到。<br>同样的方法只打包接口类IDynamic.java，得到dynamic_int.jar，不用dx处理，第三步中会用到。<br><strong>第三步</strong><br>新建一个DynamicDemo项目，目录如下<br><img src="/images/dynamicload/dynamicdemo.png"><br>下面看一下目标类：<br><strong>代码清单</strong> AndroidDynamicLoadClassActivity.java  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dynamic.demo;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.ActivityInfo;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.ResolveInfo;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Environment;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.View.OnClickListener;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.dynamic.interfaces.IDynamic;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> dalvik.system.DexClassLoader;</span><br><span class="line"><span class="keyword">import</span> dalvik.system.PathClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidDynamicLoadClassActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 动态类加载接口</span></span><br><span class="line">    <span class="keyword">private</span> IDynamic lib;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">// 初始化组件</span></span><br><span class="line">        Button showBannerBtn = (Button) findViewById(R.id.show_banner_btn);</span><br><span class="line">        Button showDialogBtn = (Button) findViewById(R.id.show_dialog_btn);</span><br><span class="line">        Button showFullScreenBtn = (Button) findViewById(R.id.show_fullscreen_btn);</span><br><span class="line">        Button showAppWallBtn = (Button) findViewById(R.id.show_appwall_btn);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 使用DexClassLoader方式加载类 */</span></span><br><span class="line">        <span class="comment">// dex压缩文件的路径（可以是apk，jar，zip格式）</span></span><br><span class="line">        String jarPath = getApplicationContext().getFilesDir().getAbsolutePath() + File.separator + <span class="string">&quot;dynamic_temp.jar&quot;</span>;</span><br><span class="line">        <span class="comment">// dex解压释放后的目录</span></span><br><span class="line">        String dexOutputDirs = getApplicationContext().getCacheDir().getAbsolutePath();</span><br><span class="line">        <span class="comment">// 定义DexClassLoader</span></span><br><span class="line">        <span class="comment">// 第一个参数：是dex压缩文件的路径</span></span><br><span class="line">        <span class="comment">// 第二个参数：是dex解压缩后存放的目录</span></span><br><span class="line">        <span class="comment">// 第三个参数：是C/C++依赖的本地库文件目录,可以为null</span></span><br><span class="line">        <span class="comment">// 第四个参数：是上一级的类加载器</span></span><br><span class="line">        DexClassLoader cl = <span class="keyword">new</span> DexClassLoader(jarPath, dexOutputDirs, <span class="keyword">null</span>, getClassLoader());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 使用PathClassLoader方法加载类 */</span></span><br><span class="line">        <span class="comment">// 创建一个intent，用来找到指定的apk：这里的&quot;com.dynamic.impl&quot;是指定apk中在AndroidMainfest.xml文件中定义的&lt;action name=&quot;com.dynamic.impl&quot;/&gt;</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="string">&quot;com.dynamic.impl&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 获得包管理器</span></span><br><span class="line">        PackageManager pm = getPackageManager();</span><br><span class="line">        List&lt;ResolveInfo&gt; resolveinfoes = pm.queryIntentActivities(intent, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 获得指定的activity信息</span></span><br><span class="line">        ActivityInfo actInfo = resolveinfoes.get(<span class="number">0</span>).activityInfo;</span><br><span class="line">        <span class="comment">// 获得apk的目录或者jar的目录</span></span><br><span class="line">        String apkPath = actInfo.applicationInfo.sourceDir;</span><br><span class="line">        <span class="comment">// native代码的目录</span></span><br><span class="line">        String libPath = actInfo.applicationInfo.nativeLibraryDir;</span><br><span class="line">        <span class="comment">// 创建类加载器，把dex加载到虚拟机中</span></span><br><span class="line">        <span class="comment">// 第一个参数：是指定apk安装的路径，这个路径要注意只能是通过actInfo.applicationInfo.sourceDir来获取</span></span><br><span class="line">        <span class="comment">// 第二个参数：是C/C++依赖的本地库文件目录,可以为null</span></span><br><span class="line">        <span class="comment">// 第三个参数：是上一级的类加载器</span></span><br><span class="line">        PathClassLoader pcl = <span class="keyword">new</span> PathClassLoader(apkPath, libPath, <span class="keyword">this</span>.getClassLoader());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载类</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// com.dynamic.impl.Dynamic是动态类名</span></span><br><span class="line">            <span class="comment">// 使用DexClassLoader加载类</span></span><br><span class="line">            Class libProviderClazz = cl.loadClass(<span class="string">&quot;com.dynamic.impl.Dynamic&quot;</span>);</span><br><span class="line">            <span class="comment">// 使用PathClassLoader加载类</span></span><br><span class="line">            <span class="comment">// Class libProviderClazz = pcl.loadClass(&quot;com.dynamic.impl.Dynamic&quot;);</span></span><br><span class="line">            lib = (IDynamic)libProviderClazz.newInstance();</span><br><span class="line">            <span class="keyword">if</span> (lib != <span class="keyword">null</span>) &#123;</span><br><span class="line">                lib.init(AndroidDynamicLoadClassActivity.<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面分别调用动态类中的方法</span></span><br><span class="line">        showBannerBtn.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (lib != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    lib.showBanner();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Toast.makeText(getApplicationContext(), <span class="string">&quot;类加载失败&quot;</span>, <span class="number">1500</span>).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        showDialogBtn.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (lib != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    lib.showDialog();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Toast.makeText(getApplicationContext(), <span class="string">&quot;类加载失败&quot;</span>, <span class="number">1500</span>).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        showFullScreenBtn.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (lib != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    lib.showFullScreen();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Toast.makeText(getApplicationContext(), <span class="string">&quot;类加载失败&quot;</span>, <span class="number">1500</span>).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        showAppWallBtn.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (lib != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    lib.showAppWall();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Toast.makeText(getApplicationContext(), <span class="string">&quot;类加载失败&quot;</span>, <span class="number">1500</span>).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个IDynamic接口变量，而且给出了DexClassLoader和PathClassLoader加载类的使用方法。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DexClassLoader cl = <span class="keyword">new</span> DexClassLoader(jarPath, dexOutputDirs, <span class="keyword">null</span>, getClassLoader());</span><br></pre></td></tr></table></figure>
<p>DexClassLoader是继承ClassLoader类的，这里面的参数说明：</p>
<ul>
<li><p>第一个参数是：dex压缩文件的路径，就是我们将上面编译后的dynamic_temp.jar存放的目录，当然也可以是zip和apk格式的。</p>
</li>
<li><p>第二个参数是：dex解压后存放的目录，就是将jar、zip或apk文件解压出的dex文件存放的目录，这个就和PathClassLoader方法有区别了，同时你也可以看到PathClassLoader方法中没有这个参数，这个也真是这两个类的区别：<br>PathClassLoader不能主动从zip包中释放出dex，因此只支持直接操作dex格式文件，或者已经安装的apk（因为已经安装的apk在手机的data/dalvik目录中存在缓存的dex文件）。而DexClassLoader可以支持apk、jar和dex文件，并且会在指定的outpath路径释放出dex文件。  </p>
<blockquote>
<p>我们可以通过DexClassLoader方法指定解压后的dex文件的存放目录，但是我们一般不这么做，因为这样做无疑的暴露了dex文件，所以我们一般不会将jar/zip/apk压缩文件存放到用户可以察觉到的位置，同时解压dex的目录也是不能让用户看到的。</p>
</blockquote>
</li>
<li><p>第三个参数是：加载的时候需要用到的lib库，这个一般不用。</p>
</li>
<li><p>第四个参数是：给DexClassLoader指定父加载器。</p>
</li>
</ul>
<p>com.dynamic.interfaces这个包是从Dynamic项目中剪切过来的，同时要在Dynamic项目中新建一个lib文件夹，将dynamic_int.jar文件拷进去，然后右键dynamic_int.jar-&gt;Build Path-&gt;Add to Build Path，后面会说为什么要这么做。<br><strong>第四步</strong><br>运行目标类：<br>如果用的是DexClassLoader方式加载类:这时候需要将jar或者zip或者apk文件放到指定的目录中，我这里放到了/data/data/com.dynamic.demo/files目录。<br>如果用的是PathClassLoader方法加载类:这时候需要先将Dynamic.apk安装到设备上，不然找不到这个指定的activity，同时需要注意：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">&quot;com.dynamic.impl&quot;</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>这里<code>com.dynamic.impl</code>是一个action，需要定义在Dynamic项目中，这个名称是动态apk和目标apk之间约定好的。  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/AppTheme&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.DynamicActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.dynamic.impl&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="/images/dynamicload/result.png"><br>点击按钮就弹出对应的Toast，成功地运行了动态类中的代码。<br>其实更好的办法就是将动态的jar，zip，apk文件从网络上获取，安全可靠，同时本地的目标项目不需要改动代码就可以执行不同的逻辑了。</p>
<h2 id="问题解释"><a href="#问题解释" class="headerlink" title="问题解释"></a>问题解释</h2><p>需要解释的是项目中接口和jar的位置以及导入方式，在解释原因之前先来了解一下Eclipse中引用项目的不同方式和区别：<br><strong>第一种</strong> 最常用的将引用项目打成jar放到需要引用项目的libs下面(这里是将PluginImpl打成jar,放到HostProject项目的libs中)<br>这种方式是Eclipse推荐使用的，当我们在建立一个项目的时候也会自动产生这个文件夹，当我们将我们需要引用的项目打成jar，然后放到这个文件夹之后，Eclipse就自动导入了(这个功能是Eclipse3.7之后有的)。<br><strong>第二种</strong> 和第一种的区别是，我们可以从新新建一个文件夹比如是lib，然后将引用的jar放到这个文件夹中，但是此时Eclipse是不会自动导入的，需要我们手动的导入(Add to Build Path…)，但是这个是一个区别，还有一个区别，也是到这个这个报错原因的区别，就是libs文件夹中的jar，在运行的时候是会将这个jar集成到程序中的，而我们新建的文件夹(名字非libs即可)，及时我们手动的导入，编译是没有问题的，但是运行的时候，是不会将jar集成到程序中。<br><strong>第三种</strong> 和前两种的区别是不需要将引用项目打成jar，直接引用这个项目<br><img src="/images/dynamicload/importproj.png"><br>这种方式其实效果和第一种差不多，唯一的区别就是不需要打成jar，但是运行的时候是不会将引用项目集成到程序中的。<br><strong>第四种</strong> 和第三种的方式是一样的，也是不需要将引用项目打成jar，直接引用项目：<br><img src="/images/dynamicload/improtproj2.png"><br>这个前提是需要设置引用项目为Library，同时引用的项目和被引用的项目必须在一个工作空间中，不然会报错，这种的效果和第二种是一样的，在运行的时候是会将引用项目集成到程序中的。<br><strong>第五种</strong> 和第一种、第二种差不多，导入jar：<br><img src="/images/dynamicload/importjar.png"><br>这里有很多种方式选择jar的位置，但是这些操作的效果和第一种是一样的，运行的时候是不会将引用的jar集成到程序中的。<br>上面两个项目可以将Dynamic看成一个插件项目，DynamicDemo看成一个宿主项目，要遵循的一个原则就是<strong>插件项目不能集成接口，宿主项目一定要集成接口</strong>。<br><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1pKYm53X">项目下载</a><br><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/jiangwei0910410003/article/details/17679823">http://blog.csdn.net/jiangwei0910410003/article/details/17679823</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/jiangwei0910410003/article/details/41384667">http://blog.csdn.net/jiangwei0910410003/article/details/41384667</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/07/16/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/16/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">算法-排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2016-07-16 11:13:23" itemprop="dateCreated datePublished" datetime="2016-07-16T11:13:23+08:00">2016-07-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>运行时间</strong><br>评估算法的<code>性能</code>。首先，要计算各个排序算法在不同的随机输入下的基本操作的次数（包括比较和交换，或者是读写数组的次数）。然后，我们用这些数据估计算法的相对性能。<br><strong>额外的内存使用</strong><br>排序算法的额外内存开销和运行时间是同样重要的。排序算法可分为两类：除了函数调用所需的栈和固定数目的实例变量之外无需额外内存的原地排序算法，以及需要额外内存空间来存储另一份数组副本的其他排序算法。<br><strong>排序算法类模板</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Comparable t = a[i]; a[i] = a[j]; a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 测试元素是否有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(a[i], a[i-<span class="number">1</span>])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] a = &#123;<span class="string">&quot;S&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;P&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        sort(a);</span><br><span class="line">        show(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个模板适用于任何实现了<code>Comparable接口</code>的数据类型。很多希望排序的数据都实现了Comparable接口。如Java中封装数字的类型Integer和Double，以及String和其他许多高级数据类型都实现了Comparable接口。在创建自己的数据类型时，只要实现Comparable接口就能够保证用例代码可以将其排序。</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ol>
<li>找到数组中最小的元素，将它和数组的第一个元素交换位置。</li>
<li>在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。</li>
<li>如此往复，直至整个数组排序。</li>
</ol>
<p><strong>两个特点</strong></p>
<ul>
<li>运行时间和输入无关。</li>
<li>数据移动是最少的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(a[j], a[min])) min = j;</span><br><span class="line">            exch(a, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>将每一个元素插入到其他已经有序元素中的适当位置，为了给要插入的元素腾出空间，需要将其余所有元素在插入之前都向右移动一位。<br>对于某些类型的<code>非随机数组</code>很有效。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将a按升序排列</span></span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123; <span class="comment">// 将a[i]插入到a[i-1]、a[i-2]、a[i-3]...之中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j], a[j-<span class="number">1</span>]); j--)</span><br><span class="line">            exch(a, j, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序的思想是使数组中任意间隔为h的元素都是有序的。这样的数组被称为<code>h有序数组</code>。一个h有序数组就是h个互相独立的有序数组编织在一起组成的一个数组。<br>实现方法：因为子数组是相互独立的，一种简单的方法是在h子数组中将每个元素交换到比它大的元素之前去。只需要在插入排序的代码中将移动元素的距离由1改为h即可。这样，希尔排序的实现就转化为了一个类似于插入排序但使用不同增量的过程。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将a[]按升序排列</span></span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; N/<span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>; <span class="comment">// 1, 4, 13, 40, 121...</span></span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123; <span class="comment">// 将数组变为h有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++) &#123; <span class="comment">// 将a[i]插入到a[i-h],a[i-2*h],a[i-3*h]...之中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(a[j], a[j-h]); j -= h)</span><br><span class="line">                exch(a, j, j-h);</span><br><span class="line">        &#125;</span><br><span class="line">        h = h / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/07/16/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/16/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">基于线程的并发编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2016-07-16 11:10:05" itemprop="dateCreated datePublished" datetime="2016-07-16T11:10:05+08:00">2016-07-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基于线程的并发编程"><a href="#基于线程的并发编程" class="headerlink" title="基于线程的并发编程"></a>基于线程的并发编程</h2><p>线程（thread）就是运行在进程上下文中的逻辑流。线程由内核自动调度。每个线程都有它自己的线程上下文（thread context），包括一个唯一的整数线程ID（Thread ID，TID）、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有运行在一个进程里的线程共享该进程的整个虚拟地址空间。</p>
<h3 id="Posix线程"><a href="#Posix线程" class="headerlink" title="Posix线程"></a>Posix线程</h3><p>Posix线程（Pthreads）是在C程序中处理线程的一个标准接口。下面的Pthreads程序：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>); <span class="comment">// 返回时，主线程和对等线程同时运行</span></span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>); <span class="comment">// 等待对等线程终止</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主线程（main thread）创建一个对等线程（peer thread），然后等待它的终止。对等线程输出”Hello, world!\n”并终止。当主线程检测到对等线程终止后，他就通过调用exit终止该进程。<br>如第二行里的原型所示，每个线程例程都以一个通用指针作为输入，并返回一个通用指针。如果想传递多个参数给线程例程，那么应该将参数放到一个结构中，并传递一个指向该结构的指针。</p>
<blockquote>
<p>1.写程序时忘记函数所需的头文件可以用man来查看，如pthread_create函数可以用<code>man pthread_create</code>命令查看所需头文件。<br>2.该文件编译：gcc -o hello hello.c -lpthread ，pthread不是Linux下的默认的库，也就是在链接的时候，无法找到pthread库中函数的入口地址，于是链接会失败。</p>
</blockquote>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>线程通过调用<code>pthread_create</code>函数来创建其他线程。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *(func)(<span class="keyword">void</span> *);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *tid, <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                func *f, <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回：若成功则返回0，若出错则为非零。<br>pthread_create函数创建一个新的线程，并带着一个输入变量arg，在新线程的上下文中运行线程例程f。能用attr参数来改变新创建线程的默认属性。<br>新线程可以通过调用pthread_self函数来获得它自己的线程ID。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p>终止方式如下：</p>
<ul>
<li>当顶层的线程例程返回时，线程会<code>隐式地</code>终止。</li>
<li>通过调用pthread_exit函数，线程会<code>显式地</code>终止。如果主线程调用pthread_exit，它会等待所有其他对等线程终止，然后再终止主线程和整个进程，返回值为thread_return。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *thread_return)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>某个对等线程调用Unix的exit函数，该函数终止进程以及所有与改进程相关的线程。</li>
<li>另一个对等线程通过以当前线程ID作为参数调用pthread_cancle函数来终止当前线程。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="回收已终止线程的资源"><a href="#回收已终止线程的资源" class="headerlink" title="回收已终止线程的资源"></a>回收已终止线程的资源</h3><p>线程通过调用pthread_join函数等待其他线程终止。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> tid, <span class="keyword">void</span> **thread_return)</span></span>;</span><br></pre></td></tr></table></figure>
<p>pthread_join函数会阻塞，直到线程tid终止，将线程例程返回的（void *）指针赋值为thread_return指向的位置，然后<code>回收</code>已终止线程占用的所有存储器资源。<br>和Unix的wait函数不同，pthread_join函数只能等待一个指定的线程终止。没有办法让pthread_join等待任意某个线程终止。</p>
<h3 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h3><p>在任一个时间点，线程是<code>可结合的（joinable）</code>或者是<code>分离的（detached）</code>。一个可结合的线程能被其他线程收回其资源和杀死。一个分离的线程是不能被其他线程回收或杀死的。<br>线程默认是可结合的，为了避免存储器泄露，每个可结合线程都应该要么被其他线程显式回收，要么通过pthread_detach函数被分离。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="初始化线程"><a href="#初始化线程" class="headerlink" title="初始化线程"></a>初始化线程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_once</span><span class="params">(<span class="keyword">pthread_once_t</span> *once_control, <span class="keyword">void</span> (*init_routine)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<p>once_control变量是一个全局或者静态变量，总是被初始化为PTHREAD_ONCE_INIT。第一次用参数once_control调用pthread_once时，它调用init_routine，这是一个没有输入参数，也没有返回的函数。（后面有应用）</p>
<h3 id="一个基于线程的并发服务器"><a href="#一个基于线程的并发服务器" class="headerlink" title="一个基于线程的并发服务器"></a>一个基于线程的并发服务器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, *connfdp, port;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    listenfd = Open_listenfd(port);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 为了避免对等线程的赋值语句和主线程的accept语句间引入的竞争</span></span><br><span class="line">        connfdp = Malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        *connfdp = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, connfdp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> n;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server received %d bytes\n&quot;</span>, n);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> connfd = *((<span class="keyword">int</span> *)vargp);</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    Free(vargp);</span><br><span class="line">    echo(connfd);</span><br><span class="line">    Close(connfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对等线程的赋值语句和主线程的Accept语句间引入的竞争：主线程Accept之后，创建新线程执行thread线程例程，同时主线程继续Accept，如果主线程的Accept在新线程的赋值语句之前执行，那么之前的连接就没有被处理，而是处理的下一次连接。因此必须让每个Accept返回的已连接描述符分配到不同的动态存储器块。</p>
</blockquote>
<p>编译：<code>gcc -o echoservert echoservert.c csapp.c csapp.h -lpthread</code></p>
<h2 id="多线程程序中的共享变量"><a href="#多线程程序中的共享变量" class="headerlink" title="多线程程序中的共享变量"></a>多线程程序中的共享变量</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</span><br><span class="line"><span class="keyword">char</span> **ptr;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">char</span> *msgs[N] = &#123;</span><br><span class="line">        <span class="string">&quot;Hello from foo&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Hello from bar&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ptr = msgs;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, (<span class="keyword">void</span> *)i);</span><br><span class="line">    Pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myid = (<span class="keyword">int</span>)vargp;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d]: %s (cnt=%d)\n&quot;</span>, myid, ptr[myid], ++cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译：<code>gcc -o sharing sharing.c csapp.c csapp.h -lpthread</code></p>
<h3 id="线程存储器模型"><a href="#线程存储器模型" class="headerlink" title="线程存储器模型"></a>线程存储器模型</h3><p>一组并发线程运行在一个进程的上下文中。每个线程都有它自己独立的线程上下文，包括<code>线程ID</code>、<code>栈</code>、<code>栈指针</code>、<code>程序计数器</code>、<code>条件码</code>和<code>通用目的寄存器值</code>。每个线程和其他线程一起共享进程上下文的剩余部分。这包括<code>整个用户虚拟地址空间</code>，它是由只读文本（代码）、读/写数据、堆以及所有的共享库代码和数据区域组成的。<br><strong>将变量映射到存储器</strong></p>
<ul>
<li><strong>全局变量</strong> 在运行时，虚拟存储器的读/写区域只包含每个全局变量的一个实例，任何线程都可以引用。</li>
<li><strong>本地自动变量</strong> 每个线程的栈都包含它自己的所有本地自动变量的实例。</li>
<li><strong>本地静态变量</strong> 和全局变量一样，虚拟存储器的读/写区域只包含在程序中声明的每个本地静态变量的一个实例。</li>
</ul>
<h2 id="用信号量同步线程"><a href="#用信号量同步线程" class="headerlink" title="用信号量同步线程"></a>用信号量同步线程</h2><p>一个共享变量引入<code>同步错误（synchronization）</code>的例子：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> niters;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;niters&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    niters = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    Pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread, &amp;niters);</span><br><span class="line">    Pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread, &amp;niters);</span><br><span class="line">    Pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt != (<span class="number">2</span> * niters))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;BOOM! cnt=%d\n&quot;</span>, cnt);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OK cnt=%d\n&quot;</span>, cnt);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, niters =*((<span class="keyword">int</span> *)vargp);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; niters; i++)</span><br><span class="line">        cnt++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译：<code>gcc -o badcnt badcnt.c csapp.c csapp.h -lpthread</code><br>执行：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  pthread .&#x2F;badcnt 10000000</span><br><span class="line">BOOM! cnt&#x3D;18624047</span><br><span class="line">➜  pthread .&#x2F;badcnt 10000000</span><br><span class="line">BOOM! cnt&#x3D;12824971</span><br></pre></td></tr></table></figure>
<p>会发现当niters足够大时，得到的答案会是错误的，而且每次都不同。因为当badcnt.c中的两个对等线程在一个单处理器上并发运行时，机器指令以某种顺序一个接一个地完成。这些顺序中的一些将会产生正确结果，但其他的则不会。一般而言，没有办法预测操作系统是否将为你的线程选择一个正确的顺序。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量s是具有非负整数值的全局变量，只能由两种特殊的操作来处理：</p>
<ul>
<li><strong>P(s)</strong> 如果s是非零的，P将s减一，并立即返回。如果s为零，那么就挂起这个线程，直到s变为非零。</li>
<li><strong>V(s)</strong> V操作将s加一。如果有任何线程阻塞在P操作等待s变成非零，那么V操作会重启这些线程中的一个。</li>
</ul>
<p>当有多个线程在等待同一个信号量时，不能预测V操作要重启哪个线程。<br>Posix标准定义了许多操作信号量的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="comment">// 将信号量sem初始化为value，每个信号量使用前必须初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="number">0</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="comment">// 程序分别通过调用sem_wait和sem_post函数来执行P和V操作。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *s)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以用以下包装函数代替  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(<span class="keyword">sem_t</span> *s)</span></span>; <span class="comment">// sem_wait的包装函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">(<span class="keyword">sem_t</span> *s)</span></span>; <span class="comment">// sem_post的包装函数</span></span><br></pre></td></tr></table></figure>

<h3 id="使用信号量来实现互斥"><a href="#使用信号量来实现互斥" class="headerlink" title="使用信号量来实现互斥"></a>使用信号量来实现互斥</h3><p>基本思想是将共享变量与一个信号量s（初始为1）联系起来，然后用P(s)和V(s)操作将相应的临界区包围起来。</p>
<blockquote>
<p>临界区：对于线程i，操作共享变量cnt内容的指令构成了一个临界区（critical section）。<br>要确保每个线程在执行它的临界区中的指令时，拥有对共享变量的互斥的访问，这种现象称为互斥（mutual exclusion）。</p>
</blockquote>
<p>以这种方式保护共享变量的信号量叫做二元信号量（binary semaphore），因为它的值为0或1。以提供互斥为目的的二元信号量也成为互斥锁（mutex）。在一个互斥锁上执行P操作称为对互斥锁<code>加锁</code>，V操作称为<code>解锁</code>。对一个互斥锁加了锁但是还没有解锁的线程称为<code>占用</code>这个互斥锁。<br>一个被用作一组可用资源的计数器的信号量称为<code>计数信号量</code>。<br>用信号量正确同步前面的计数器程序实例：<br>1.首先声明一个信号量mutex  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">sem_t</span> mutex; </span><br></pre></td></tr></table></figure>
<p>2.在主例程中，pthread_create之前将mutex初始化为1  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>3.通过在线程例程中对共享变量cnt的更新包围P和V操作  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; niters; i++) &#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    cnt++;</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再编译执行就一定能得到正确结果了  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  pthread gcc -o badcnt badcnt.c csapp.c csapp.h -lpthread</span><br><span class="line">➜  pthread .&#x2F;badcnt 10000000</span><br><span class="line">OK cnt&#x3D;20000000</span><br><span class="line">➜  pthread .&#x2F;badcnt 100000000</span><br><span class="line">OK cnt&#x3D;200000000</span><br></pre></td></tr></table></figure>

<h3 id="利用信号量来调度共享资源"><a href="#利用信号量来调度共享资源" class="headerlink" title="利用信号量来调度共享资源"></a>利用信号量来调度共享资源</h3><p>一个线程通过信号量操作来通知另一个线程，程序状态中某个条件已经为真了。两个经典而有用的例子是<code>生产者 - 消费者</code>和<code>读者 - 写者</code>问题。<br>1.生产者 - 消费者问题<br>生产者和消费者线程共享一个有n个槽的<code>有限缓冲区</code>。生产者线程反复地生成新的项目，并把它们插入到缓冲区中。消费者线程不断地从缓冲区中取出这些项目，然后消费它们。<br>因为插入和取出项目都涉及更新共享变量，所以我们必须保证对缓冲区的访问是互斥的。但只保证互斥访问是不够的，还需要调度对缓冲区的访问。如果缓冲区是满的，生产者就必须等到有一个槽位变为可用。如果缓冲区是空的，那么消费者必须等到有一个可用项目。<br>下面开发一个简单的包，叫做SBUF，用来构造生产者 - 消费者程序。<br>SBUF操作类型为sbuf_t的有限缓冲区。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sbuf.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *buf;    <span class="comment">// 存放项目的动态分配的n项整数数组</span></span><br><span class="line">    <span class="keyword">int</span> n;       <span class="comment">// 槽位的个数</span></span><br><span class="line">    <span class="keyword">int</span> front;   <span class="comment">// 索引值，(front+1)%n记录数组第一项</span></span><br><span class="line">    <span class="keyword">int</span> rear;    <span class="comment">// 索引值，rear%n记录数组最后一项</span></span><br><span class="line">    <span class="keyword">sem_t</span> mutex; <span class="comment">// 提供互斥缓冲区访问的信号量</span></span><br><span class="line">    <span class="keyword">sem_t</span> slots; <span class="comment">// 空槽位数</span></span><br><span class="line">    <span class="keyword">sem_t</span> items; <span class="comment">// 可用项目数</span></span><br><span class="line">&#125; <span class="keyword">sbuf_t</span>;</span><br></pre></td></tr></table></figure>
<p>SBUF函数的实现  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">&quot;csapp.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sbuf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_init</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 为缓冲区分配堆存储器</span></span><br><span class="line">    sp-&gt;buf = Calloc(n, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    sp-&gt;n = n;</span><br><span class="line">    sp-&gt;front = sp-&gt;rear = <span class="number">0</span>; <span class="comment">// 表示空缓冲区</span></span><br><span class="line">    Sem_init(&amp;sp-&gt;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    Sem_init(&amp;sp-&gt;slots, <span class="number">0</span>, n);</span><br><span class="line">    Sem_init(&amp;sp-&gt;items, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_deinit</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 应用程序用完缓冲区时，释放缓冲区存储</span></span><br><span class="line">    Free(sp-&gt;buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_insert</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P(&amp;sp-&gt;slots); <span class="comment">// wait for available slot</span></span><br><span class="line">    P(&amp;sp-&gt;mutex); <span class="comment">// lock the buffer</span></span><br><span class="line">    sp-&gt;buf[(++sp-&gt;rear) % (sp-&gt;n)] = item; <span class="comment">// insert the item</span></span><br><span class="line">    V(&amp;sp-&gt;mutex); <span class="comment">// unlock the buffer</span></span><br><span class="line">    V(&amp;sp-&gt;items); <span class="comment">// announce available item</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sbuf_remove</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    P(&amp;sp-&gt;items); <span class="comment">// wait for available slot</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);</span><br><span class="line">    item = sp-&gt;buf[(++sp-&gt;front) % (sp-&gt;n)];</span><br><span class="line">    V(&amp;sp-&gt;mutex);</span><br><span class="line">    V(&amp;sp-&gt;slots);</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.读者 - 写者问题<br>一组并发的线程要访问一个共享对象，有些线程只读对象，而其他的线程只修改对象。修改对象的线程叫做<code>写者</code>，只读对象的线程叫做<code>读者</code>。写者必须拥有对对象的独占的访问，而读者可以和无限多个其他的读者共享对象。<br><code>第一类读者 - 写者问题</code> 读者优先，要求不让读者等待，除非已经有写者在占用。<br><code>第二类读者 - 写者问题</code> 写者优先，在写者之后到的读者要等待。<br>第一类读者 - 写者问题的实现  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readcnt; <span class="comment">// 共享变量，统计当前在临界区中的读者数量</span></span><br><span class="line"><span class="keyword">sem_t</span> mutex, w; <span class="comment">// mutex保护对readcnt的访问，w控制对访问共享对象的临界区的访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        readcnt++;</span><br><span class="line">        <span class="keyword">if</span> (readcnt == <span class="number">1</span>) <span class="comment">// first in</span></span><br><span class="line">            P(&amp;w);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        <span class="comment">/* Critical section</span></span><br><span class="line"><span class="comment">           Reading happens */</span></span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        readcnt--;</span><br><span class="line">        <span class="keyword">if</span> (readcnt == <span class="number">0</span>) <span class="comment">// last out</span></span><br><span class="line">            V(&amp;w);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(&amp;w);</span><br><span class="line">        <span class="comment">/* Critical section</span></span><br><span class="line"><span class="comment">           Writing happens */</span></span><br><span class="line">        V(&amp;w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="综合：基于预线程化的并发服务器"><a href="#综合：基于预线程化的并发服务器" class="headerlink" title="综合：基于预线程化的并发服务器"></a>综合：基于预线程化的并发服务器</h3><p>一个基于预线程化（prethreading）的服务器通过使用生产者 - 消费者模型来降低为每一个新客户端创建一个新线程的开销。服务器是由一个主线程和一组工作者线程构成的。主线程不断地接收来自客户端的连接请求，并将得到的连接描述符放在一个有限缓冲区中。每一个工作者线程反复地从共享缓冲区中取出描述符，为客户端服务，然后等待下一个描述符。<br>用SBUF包实现一个预线程化的并发echo服务器。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// echoservert_pre.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sbuf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NTHREADS 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SBUFSIZE 16</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo_cnt</span><span class="params">(<span class="keyword">int</span> connfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sbuf_t</span> sbuf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, listenfd, connfd, port;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    sbuf_init(&amp;sbuf, SBUFSIZE); <span class="comment">// 初始化缓冲区sbuf</span></span><br><span class="line">    listenfd = Open_listenfd(port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NTHREADS; i++) &#123; <span class="comment">// 主线程创建了一组工作者线程</span></span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">// 进入无限的服务器循环，接受连接请求</span></span><br><span class="line">        connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);</span><br><span class="line">        sbuf_insert(&amp;sbuf, connfd); <span class="comment">// 将得到的已连接的描述符插入到缓冲区sbuf中。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">// 每个工作者线程等待直到它能从缓冲区中取出一个已连接的描述符</span></span><br><span class="line">        <span class="keyword">int</span> connfd = sbuf_remove(&amp;sbuf);</span><br><span class="line">        echo_cnt(connfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>echo_cnt函数的实现如下  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// echo_cnt.c</span></span><br><span class="line">include <span class="string">&quot;csapp.h&quot;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> byte_cnt; <span class="comment">// 记录了所有客户端接收到的累计字节数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">sem_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_echo_cnt</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    byte_cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo_cnt</span><span class="params">(<span class="keyword">int</span> connfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> rio;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_once_t</span> once = PTHREAD_ONCE_INIT;</span><br><span class="line">    Pthread_once(&amp;once, init_echo_cnt); <span class="comment">// 当第一次有某个线程调用echo_once函数时，使用pthread_once调用初始化函数</span></span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        P(&amp;mutex); <span class="comment">// 对共享变量byte_cnt进行保护</span></span><br><span class="line">        byte_cnt += n;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %d received %d (%d total) bytes on fd %d\n&quot;</span>,</span><br><span class="line">                (<span class="keyword">int</span>)pthread_self(), n, byte_cnt, connfd);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译：<code>gcc -o echoservert_pre echoservert_pre.c sbuf.h sbuf.c csapp.h csapp.c echo_cnt.c -lpthread</code><br><strong>reference</strong><br>《深入理解计算机系统》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/06/28/Android-Hooking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/06/28/Android-Hooking/" class="post-title-link" itemprop="url">Android Hooking</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2016-06-28 09:36:13" itemprop="dateCreated datePublished" datetime="2016-06-28T09:36:13+08:00">2016-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="ptrace-on-Android"><a href="#ptrace-on-Android" class="headerlink" title="ptrace on Android"></a>ptrace on Android</h3><p>无论是hook还是调试都离不开ptrace这个system call，ptrace可以跟踪目标进程，并且在目标进程暂停的时候对目标进程的内存进行读写。<br>首先看一下要ptrace的目标程序，用来一直循环输出一句话”Hello, Hooking!”  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">targetFunc</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">&quot;Hello, Hooking!&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, str, number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        targetFunc(count);</span><br><span class="line">        count++;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要编译它需要先建立一个Android.mk文件，内容如下，让ndk将文件编译为elf可执行文件：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">LOCAL_MODULE := target</span><br><span class="line">LOCAL_SRC_FILES := target.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_EXECUTABLE)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>只有设置Android SDK&lt;=9编译出的elf文件才是executable的，否则编译出的是shared object（即使是include的BUILD_EXECUTABLE）。</p>
</blockquote>
<p>接下来写出hook1.c程序来hook target程序的system call，main函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;pid to be traced&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    pid = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != ptrace(PTRACE_ATTACH, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Trace process failed:%d.\n&quot;</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ptrace(PTRACE_SYSCALL, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">        hookSysCallBefore(pid);</span><br><span class="line">        ptrace(PTARCE_SYSCALL, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        wait(&amp;status);</span><br><span class="line">        hookSysCallAfter(pid);</span><br><span class="line">        ptrace(PTRACE_SYSCALL, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ptrace(PTRACE_DETACH, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先要知道hook目标进程的pid，用ps命令获取。然后使用<code>ptrace(PTRACE_ATTACH, pid, NULL, NULL)</code>这个函数对目标进程进行加载。加载成功后，我们可以使用<code>ptrace(PTRACE_SYSCALL, pid, NULL, NULL)</code>这个函数来对目标程序下断点，每当目标程序调用system call前的时候，就会暂停下来。然后可以读取寄存器的值来获取system call的各项信息。再一次使用<code>ptrace(PTRACE_SYSCALL, pid, NULL, NULL)</code>这个函数就可以让system call在调用完成后再一次暂停下来，并获取system call的返回值。<br>获取system call编号的函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getSysCallNo</span><span class="params">(<span class="keyword">int</span> pid, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> scno = <span class="number">0</span>;</span><br><span class="line">    scno = ptrace(PTRACE_PEEKTEXT, pid, (<span class="keyword">void</span> *)(regs-&gt;ARM_pc - <span class="number">4</span>), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (scno = <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (scno == <span class="number">0xef000000</span>) &#123;</span><br><span class="line">        scno = regs-&gt;ARM_r7;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((scno &amp; <span class="number">0x0ff00000</span>) != <span class="number">0x0f900000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        scno &amp;= <span class="number">0x000fffff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ARM架构上，所有的系统调用都是通过SWI来实现的。并且在ARM架构中有两个SWI指令，分别针对EABI和OABI：</p>
<blockquote>
<p>[EABI]<br>机器码： 1110 1111 0000 0000 – SWI 0<br>具体的调用号存放在寄存器r7中。<br>[OABI]<br>机器码： 1101 1111 vvvv vvvv – SWI immed_8<br>调用号进行转换后得到指令中的立即数。立即数=调用号 | 0x900000</p>
</blockquote>
<p>需要兼容两种方法的调用，在代码上就要分开处理。首先要获取SWI指令判断是EABI还是OABI，如果是EABI，可从r7中获取调用号。如果是OABI，则从SWI指令中获取立即数，反向计算出调用号。<br>接着看hook system call前的函数，和hook system call后的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hookSysCallBefore</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">regs</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sysCallNo = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    sysCallNo = getSysCallNo(pid, &amp;regs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before SysCallNo = %d\n&quot;</span>, sysCallNo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sysCallNo == __NR_write) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;__NR_write: %ld %p %ld\n&quot;</span>, regs.ARM_r0, (<span class="keyword">void</span>*)regs.ARM_r1, regs.ARM_r2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hookSysCallAfter</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">regs</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sysCallNo = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    sysCallNo = getSysCallNo(pid, &amp;regs);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After SysCallNo = %d\n&quot;</span>, sysCallNo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sysCallNo == __NR_write) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;__NR_write return: %ld\n&quot;</span>, regs.ARM_r0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在获取了system call的调用号后，可以进一步获取各个参数的值，比如说wirte这个system call有三个参数。在arm上，如果形参个数少于或等于4，则形参由<code>R0</code>，<code>R1</code>，<code>R2</code>，<code>R3</code>四个寄存器传递。大于四个则通过栈传递。函数的返回值保存在<code>R0</code>中。<br>把target和hook1 push到/data/local/tmp目录下，再chmod 777，接着运行target：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;target</span><br><span class="line">Hello, Hooking! 0</span><br><span class="line">Hello, Hooking! 1</span><br><span class="line">Hello, Hooking! 2</span><br><span class="line">Hello, Hooking! 3</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>再开一个shell，<code>ps</code>获取target的pid，使用hook1程序对target进行hook操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;hook1 27190</span><br><span class="line">Before SysCallNo &#x3D; 0</span><br><span class="line">After SysCallNo &#x3D; 0</span><br><span class="line"></span><br><span class="line">Before SysCallNo &#x3D; 4</span><br><span class="line">__NR_write: 1 0x4f5020 20</span><br><span class="line">After SysCallNo &#x3D; 4</span><br><span class="line">__NR_write return: 20</span><br><span class="line"></span><br><span class="line">Before SysCallNo &#x3D; 162</span><br><span class="line">After SysCallNo &#x3D; 162</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>syscall No 162是<code>sleep</code>函数，syscall No 4是<code>write</code>函数，因为printf本质就是调用write这个系统调用。对write函数参数的解析：1是stdout即标准输出，0x4f5020是字符串地址，20表示字符串长度。返回值20是write成功写入的长度。<br>整个过程的图示：<br><img src="/images/androidhook/syscall_trace.png"></p>
<h3 id="利用ptrace动态修改内存"><a href="#利用ptrace动态修改内存" class="headerlink" title="利用ptrace动态修改内存"></a>利用ptrace动态修改内存</h3><p>下面演示用ptrace进行内存读写，将write()输出的string进行翻转。<br>在hook1.c的基础上继续进行修改，在hookSysCallBefore()函数中加入modifyString(pid, regs.ARM_r1, regs.ARM_r2)这个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sysCallNo == __NR_write) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;__NR_write: %ld %p %ld\n&quot;</span>, regs.ARM_r0, (<span class="keyword">void</span> *)regs.ARM_r1, regs.ARM_r2);</span><br><span class="line">    modifyString(pid, regs.ARM_r1, regs.ARM_r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把write的第二个参数字符串地址<code>r1</code>和第三个参数字符串长度<code>r2</code>传递给<code>modifyString()</code>这个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyString</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">long</span> addr, <span class="keyword">long</span> <span class="built_in">strlen</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    str = (<span class="keyword">char</span> *)<span class="built_in">calloc</span>((<span class="built_in">strlen</span>+<span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>), <span class="number">1</span>);</span><br><span class="line">    getdata(pid, addr, str, <span class="built_in">strlen</span>);</span><br><span class="line">    reverse(str);</span><br><span class="line">    putdata(pid, addr, str, <span class="built_in">strlen</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>modifyString()</code>首先获取在内存中的字符串，然后进行翻转操作，最后把翻转后的字符串写入原来的地址。这些操作用到了getdata()和putdata()函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdata</span><span class="params">(<span class="keyword">pid_t</span> child, <span class="keyword">long</span> addr, <span class="keyword">char</span> *str, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *laddr;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">u</span> &#123;</span></span><br><span class="line">        <span class="keyword">long</span> val;</span><br><span class="line">        <span class="keyword">char</span> chars[long_size];</span><br><span class="line">    &#125; data;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = len / long_size;</span><br><span class="line">    laddr = str;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        data.val = ptrace(PTRACE_PEEKDATA, child, addr+i*<span class="number">4</span>, <span class="literal">NULL</span>); <span class="comment">// ptrace的内存操作一次只能控制4个字节</span></span><br><span class="line">        <span class="built_in">memcpy</span>(laddr, data.chars, long_size);</span><br><span class="line">        ++i;</span><br><span class="line">        laddr += long_size;</span><br><span class="line">    &#125;</span><br><span class="line">    j = len % long_size;</span><br><span class="line">    <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">        data.val = ptrace(PTRACE_PEEKDATA, child, addr+i*<span class="number">4</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(laddr, data.chars, j);</span><br><span class="line">    &#125;</span><br><span class="line">    str[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putdata</span><span class="params">(<span class="keyword">pid_t</span> child, <span class="keyword">long</span> addr, <span class="keyword">char</span> *str, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *laddr;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">u</span> &#123;</span></span><br><span class="line">        <span class="keyword">long</span> val;</span><br><span class="line">        <span class="keyword">char</span> chars[long_size];</span><br><span class="line">    &#125; data;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = len / long_size;</span><br><span class="line">    laddr = str;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(data.chars, laddr, long_size);</span><br><span class="line">        ptrace(PTRACE_POKEDATA, child, addr+i*<span class="number">4</span>, data.val);</span><br><span class="line">        ++i;</span><br><span class="line">        laddr += long_size;</span><br><span class="line">    &#125;</span><br><span class="line">    j = len % long_size;</span><br><span class="line">    <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(data.chars, laddr, j);</span><br><span class="line">        ptrace(PTRACE_POKEDATA, child, addr+i*<span class="number">4</span>, data.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getdata()</code>和<code>putdata()</code>分别使用<code>PTRACE_PEEKDATA</code>和<code>PTRACE_POKEDATA</code>对内存进行读写操作。因为ptrace的内存操作一次只能控制4个字节，所以如果修改比较长的内容需要进行多次操作。<br>现在运行target，并且在运行中用hook2进行hook：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;target</span><br><span class="line">Hello, Hooking! 0</span><br><span class="line">Hello, Hooking! 1</span><br><span class="line">Hello, Hooking! 2</span><br><span class="line">Hello, Hooking! 3</span><br><span class="line">Hello, Hooking! 4</span><br><span class="line">Hello, Hooking! 5</span><br><span class="line">Hello, Hooking! 6</span><br><span class="line">Hello, Hooking! 7</span><br><span class="line">Hello, Hooking! 8</span><br><span class="line">Hello, Hooking! 9</span><br><span class="line">01 !gnikooH ,olleH</span><br><span class="line">11 !gnikooH ,olleH</span><br><span class="line">21 !gnikooH ,olleH</span><br><span class="line">31 !gnikooH ,olleH</span><br><span class="line">41 !gnikooH ,olleH</span><br><span class="line">51 !gnikooH ,olleH</span><br><span class="line">Hello, Hooking! 16</span><br><span class="line">Hello, Hooking! 17</span><br><span class="line">Hello, Hooking! 18</span><br><span class="line">Hello, Hooking! 19</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>运行hook2后字符串被翻转，退出hook2字符串回到原顺序。</p>
<h3 id="利用ptrace动态执行sleep-函数"><a href="#利用ptrace动态执行sleep-函数" class="headerlink" title="利用ptrace动态执行sleep()函数"></a>利用ptrace动态执行sleep()函数</h3><p>下面利用ptrace来执行libc.so中的sleep()函数，主要逻辑如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">old_regs</span>, <span class="title">regs</span>;</span></span><br><span class="line">    <span class="keyword">long</span> sleep_addr;</span><br><span class="line">    <span class="comment">// save old regs</span></span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;old_regs);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;regs, &amp;old_regs, <span class="keyword">sizeof</span>(regs));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getting remote sleep_addr:\n&quot;</span>);</span><br><span class="line">    sleep_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)sleep);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> parameters[<span class="number">1</span>];</span><br><span class="line">    parameters[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    ptrace_call(pid, sleep_addr, parameters, <span class="number">1</span>, &amp;regs);</span><br><span class="line">    <span class="comment">// restore old regs</span></span><br><span class="line">    ptrace(PTRACE_SETREGS, pid, <span class="literal">NULL</span>, &amp;old_regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们用<code>ptrace(PTRACE_GETREGS, pid, NULL, &amp;old_regs)</code>获取当前寄存器的值，以便最后恢复数据。然后获取sleep()函数在目标进程中的地址，接着利用ptrace执行sleep()函数。<br>下面是获取sleep()函数在目标进程中地址的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">get_module_base</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">const</span> <span class="keyword">char</span> *module_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> addr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *pch;</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">32</span>], line[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;/proc/self/maps&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;/proc/%d/maps&quot;</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    fp = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (fgets(line, <span class="keyword">sizeof</span>(line), fp)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, module_name)) &#123;</span><br><span class="line">                pch = strtok(line, <span class="string">&quot;-&quot;</span>);</span><br><span class="line">                addr = strtoul(pch, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">                <span class="keyword">if</span> (addr == <span class="number">0x8000</span>) <span class="comment">// 如果被加载的文件是executable而不是so，则不需要加上基址</span></span><br><span class="line">                    addr = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">get_remote_addr</span><span class="params">(<span class="keyword">pid_t</span> target_pid, <span class="keyword">const</span> <span class="keyword">char</span> *module_name, <span class="keyword">void</span> *local_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *local_handle, *remote_handle;</span><br><span class="line">    local_handle = get_module_base(<span class="number">0</span>, module_name);</span><br><span class="line">    remote_handle = get_module_base(target_pid, module_name);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;module_base: local[%p], remote[%p]\n&quot;</span>, local_handle, remote_handle);</span><br><span class="line">    <span class="comment">// 本进程函数地址减去本进程libc地址等于该函数在libc的偏移，再加上负载进程的libc基址即负载进程中函数地址</span></span><br><span class="line">    <span class="keyword">long</span> ret_addr = (<span class="keyword">long</span>)((<span class="keyword">uint32_t</span>)local_addr - (<span class="keyword">uint32_t</span>)local_handle + (<span class="keyword">uint32_t</span>)remote_handle);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;remote_addr: [%p]\n&quot;</span>, (<span class="keyword">void</span> *)ret_addr);</span><br><span class="line">    <span class="keyword">return</span> ret_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为libc.so在内存中的地址是随机的，所以要先获取目标进程的libc.so的加载地址，再获取本进程的libc.so的加载地址和sleep()在内存中的地址。然后我们就能计算出sleep()函数在目标进程中的地址了。要注意的是获取目标进程和本进程的libc.so的加载地址是通过解析<code>/proc/[pid]/maps</code>得到的。<br>接下来执行sleep()函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_call</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">long</span> addr, <span class="keyword">long</span> *params, <span class="keyword">uint32_t</span> num_params, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    <span class="comment">// 将参数赋给R0-R3</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_params &amp;&amp; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        regs-&gt;uregs[i] = params[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数大于四个，将参数放在栈上</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; num_params) &#123;</span><br><span class="line">        regs-&gt;ARM_sp -= (num_params - i) * long_size;</span><br><span class="line">        putdata(pid, (<span class="keyword">long</span>)regs-&gt;ARM_sp, (<span class="keyword">char</span> *)&amp;params[i], (num_params - i) * long_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    regs-&gt;ARM_pc = addr;</span><br><span class="line">    <span class="keyword">if</span> (regs-&gt;ARM_pc &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* thumb */</span></span><br><span class="line">        regs-&gt;ARM_pc &amp;= (~<span class="number">1u</span>);</span><br><span class="line">        regs-&gt;ARM_cpsr |= CPSR_T_MASK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* arm */</span></span><br><span class="line">        regs-&gt;ARM_cpsr &amp;= ~CPSR_T_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    regs-&gt;ARM_lr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ptrace_setregs(pid, regs) == <span class="number">-1</span> || ptrace_continue(pid) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> stat = <span class="number">0</span>;</span><br><span class="line">    waitpid(pid, &amp;stat, WUNTRACED);</span><br><span class="line">    <span class="keyword">while</span> (stat != <span class="number">0xb7f</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptrace_continue(pid) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        waitpid(pid, &amp;stat, WUNTRACED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是将参数赋值给R0-R3，如果参数大于四个的话，再使用putdata()将参数存放在栈上。然后我们将PC的值设置为函数地址。接着再根据是否是thumb指令设置ARM_cpsr寄存器的值。随后我们使用ptrace_setregs()将目标进程寄存器的值进行修改。最后使用waitpid()等待函数被执行。</p>
<h3 id="利用ptrace动态加载so并执行自定义函数"><a href="#利用ptrace动态加载so并执行自定义函数" class="headerlink" title="利用ptrace动态加载so并执行自定义函数"></a>利用ptrace动态加载so并执行自定义函数</h3><p>逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">保存当前寄存器的状态</span><br><span class="line">获取目标程序的mmap, dlopen, dlsym, dlclose地址</span><br><span class="line">调用mmap分配一段内存空间来保存参数信息</span><br><span class="line">调用dlopen加载so文件</span><br><span class="line">调用dlsym找到目标函数地址</span><br><span class="line">使用ptrace_call执行目标函数</span><br><span class="line">调用dlclose卸载so文件</span><br><span class="line">恢复寄存器的状态</span><br></pre></td></tr></table></figure>
<p>实现整个逻辑的函数injectSo()的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">injectSo</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">char</span> *so_path, <span class="keyword">char</span> *function_name, <span class="keyword">char</span> *parameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">old_regs</span>, <span class="title">regs</span>;</span></span><br><span class="line">    <span class="keyword">long</span> mmap_addr, dlopen_addr, dlsym_addr, dlclose_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save old regs</span></span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;old_regs);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;regs, &amp;old_regs, <span class="keyword">sizeof</span>(regs));</span><br><span class="line">    <span class="comment">// get remote address</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getting remote address:\n&quot;</span>);</span><br><span class="line">    mmap_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)mmap);</span><br><span class="line">    dlopen_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)dlopen);</span><br><span class="line">    dlsym_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)dlsym);</span><br><span class="line">    dlclose_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)dlclose);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmap_addr = %p dlopen_addr=%p dlsym_addr=%p dlclose_addr=%p\n&quot;</span>,</span><br><span class="line">            (<span class="keyword">void</span> *)mmap_addr, (<span class="keyword">void</span> *)dlopen_addr, (<span class="keyword">void</span> *)dlsym_addr, (<span class="keyword">void</span> *)dlclose_addr);</span><br><span class="line">    <span class="keyword">long</span> parameters[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mmap</span></span><br><span class="line">    parameters[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// address</span></span><br><span class="line">    parameters[<span class="number">1</span>] = <span class="number">0x4000</span>; <span class="comment">// size</span></span><br><span class="line">    parameters[<span class="number">2</span>] = PROT_READ | PROT_WRITE | PROT_EXEC; <span class="comment">// WRX</span></span><br><span class="line">    parameters[<span class="number">3</span>] = MAP_ANONYMOUS | MAP_PRIVATE; <span class="comment">// flag</span></span><br><span class="line">    parameters[<span class="number">4</span>] = <span class="number">0</span>; <span class="comment">// fd</span></span><br><span class="line">    parameters[<span class="number">5</span>] = <span class="number">0</span>; <span class="comment">// offset</span></span><br><span class="line"></span><br><span class="line">    ptrace_call(pid, mmap_addr, parameters, <span class="number">6</span>, &amp;regs);</span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    <span class="keyword">long</span> map_base = regs.ARM_r0; <span class="comment">// 返回映射区的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;map_base = %p\n&quot;</span>, (<span class="keyword">void</span> *)map_base);</span><br><span class="line">    <span class="comment">// dlopen</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;save os_path = %s to map_base %p\n&quot;</span>, so_path, (<span class="keyword">void</span> *)map_base);</span><br><span class="line">    putdata(pid, map_base, so_path, <span class="built_in">strlen</span>(so_path)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    parameters[<span class="number">0</span>] = map_base;</span><br><span class="line">    parameters[<span class="number">1</span>] = RTLD_NOW | RTLD_GLOBAL;</span><br><span class="line">    ptrace_call(pid, dlopen_addr, parameters, <span class="number">2</span>, &amp;regs);</span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    <span class="keyword">long</span> handle = regs.ARM_r0;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handle = %p\n&quot;</span>, (<span class="keyword">void</span> *)handle);</span><br><span class="line">    <span class="comment">// dlsym</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;save function_name = %s to map_base = %p\n&quot;</span>, function_name, (<span class="keyword">void</span> *)map_base);</span><br><span class="line">    putdata(pid, map_base, function_name, <span class="built_in">strlen</span>(function_name) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    parameters[<span class="number">0</span>] = handle;</span><br><span class="line">    parameters[<span class="number">1</span>] = map_base;</span><br><span class="line">    ptrace_call(pid, dlsym_addr, parameters, <span class="number">2</span>, &amp;regs);</span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    <span class="keyword">long</span> function_ptr = regs.ARM_r0;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function_ptr = %p\n&quot;</span>, (<span class="keyword">void</span> *)function_ptr);</span><br><span class="line">    <span class="comment">// function_call</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;save parameter = %s to map_base = %p\n&quot;</span>, parameter, (<span class="keyword">void</span> *)map_base);</span><br><span class="line">    putdata(pid, map_base, parameter, <span class="built_in">strlen</span>(parameter)+<span class="number">1</span>); <span class="comment">//此处的parameter是通过参数传递进来的</span></span><br><span class="line"></span><br><span class="line">    parameters[<span class="number">0</span>] = map_base;</span><br><span class="line"></span><br><span class="line">    ptrace_call(pid, function_ptr, parameters, <span class="number">1</span>, &amp;regs);</span><br><span class="line">    <span class="comment">// dlclose</span></span><br><span class="line">    parameters[<span class="number">0</span>] = handle;</span><br><span class="line">    ptrace_call(pid, dlclose_addr, parameters, <span class="number">1</span>, &amp;regs);</span><br><span class="line">    <span class="comment">// restore old regs</span></span><br><span class="line">    ptrace(PTRACE_SETREGS, pid, <span class="literal">NULL</span>, &amp;old_regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mmap()可以用来将一个文件或者其它对象映射进内存，如果我们把flag设置为MAP_ANONYMOUS并且把参数fd设置为0的话就相当于直接映射一段内容为空的内存。mmap()的函数声明和参数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>start：映射区的开始地址，设置为0时表示由系统决定映射区的起始地址。<br>length：映射区的长度。<br>prot：期望的内存保护标志，不能与文件的打开模式冲突。这里设置为RWX。<br>flags：指定映射对象的类型，映射选项和映射页是否可以共享。我们这里设置为：MAP_ANONYMOUS(匿名映射，映射区不与任何文件关联)，MAP_PRIVATE(建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件)。<br>fd：有效的文件描述词。匿名映射设置为0。<br>offset：被映射对象内容的起点。设置为0。</p>
</blockquote>
<p><code>mmap()</code>映射的内存主要用来保存传递给其他函数的参数。比如接下来我们需要用dlopen()去加载”/data/local/tmp/libinject.so”这个文件，所以需要先用<code>putdata()</code>将字符串”/data/local/tmp/libinject.so”放置在mmap()所映射的内存中，再将映射地址作为参数传递给dlopen()。接下来的dlsym()，so中的目标函数，dlclose()都是相同的调用方式。<br>被加载的so文件内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">injectedFunc</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;injected function pid = %d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello %s\n&quot;</span>, str);</span><br><span class="line">    LOGD(<span class="string">&quot;injected function pid = %d\n&quot;</span>, getpid());</span><br><span class="line">    LOGD(<span class="string">&quot;Hello %s\n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里不光使用printf()还使用了android debug的函数LOGD()用来输出调试结果。所以在编译时我们需要加上<code>LOCAL_LDLIBS := -llog</code>。<br>编译完后使用hook4对target进行注入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;target</span><br><span class="line">Hello, Hooking! 0</span><br><span class="line">Hello, Hooking! 1</span><br><span class="line">Hello, Hooking! 2</span><br><span class="line">Hello, Hooking! 3</span><br><span class="line">injected function pid &#x3D; 13574</span><br><span class="line">Hello Android hooking</span><br><span class="line">Hello, Hooking! 4</span><br><span class="line">Hello, Hooking! 5</span><br><span class="line">Hello, Hooking! 6</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;hook4 13574</span><br><span class="line">getting remote address:</span><br><span class="line">module_base: local[0xb6f7c000], remote[0xb6ec0000]</span><br><span class="line">remote_addr: [0xb6ed2c5d]</span><br><span class="line">module_base: local[0xb6f7c000], remote[0xb6ec0000]</span><br><span class="line">remote_addr: [0xb6f22f31]</span><br><span class="line">module_base: local[0xb6f7c000], remote[0xb6ec0000]</span><br><span class="line">remote_addr: [0xb6f22e81]</span><br><span class="line">module_base: local[0xb6f7c000], remote[0xb6ec0000]</span><br><span class="line">remote_addr: [0xb6f22dfd]</span><br><span class="line">mmap_addr &#x3D; 0xb6ed2c5d dlopen_addr&#x3D;0xb6f22f31 dlsym_addr&#x3D;0xb6f22e81 dlclose_addr&#x3D;0xb6f22dfd</span><br><span class="line">map_base &#x3D; 0xb6e82000</span><br><span class="line">save os_path &#x3D; &#x2F;data&#x2F;local&#x2F;tmp&#x2F;libinject.so to map_base 0xb6e82000</span><br><span class="line">handle &#x3D; 0xb6f1f494</span><br><span class="line">save function_name &#x3D; injectedFunc to map_base &#x3D; 0xb6e82000</span><br><span class="line">function_ptr &#x3D; 0xb6e7cc61</span><br><span class="line">save parameter &#x3D; Android hooking to map_base &#x3D; 0xb6e82000</span><br></pre></td></tr></table></figure>
<p>可以看到stdout和logcat都成功输出了调试信息。这意味着可以通过注入让目标进程加载so文件并执行任意代码了。</p>
<h3 id="利用函数挂钩实现native层的hook"><a href="#利用函数挂钩实现native层的hook" class="headerlink" title="利用函数挂钩实现native层的hook"></a>利用函数挂钩实现native层的hook</h3><p>这一节要实现用函数挂钩hook目标函数，函数挂钩的基本原理是先用mprotect()将原代码段改成可读可写可执行，然后修改原函数的入口处的代码，让pc指针跳转到动态加载的so文件中的hook函数中，执行完hook函数以后再让pc指针跳转回原本的函数中。<br>用来注入的程序hook5逻辑与hook4相比并没有太大变化，仅仅少了”调用dlclose卸载so文件”这一个步骤，因为要执行的hook后的函数在so中，所以不需要卸载，步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">保存当前寄存器的状态</span><br><span class="line">获取目标程序的mmap, dlopen, dlsym地址</span><br><span class="line">调用mmap分配一段内存空间用来保存参数信息</span><br><span class="line">调用dlopen加载so文件</span><br><span class="line">调用dlsym找到目标函数地址</span><br><span class="line">使用ptrace_call执行目标函数</span><br><span class="line">恢复寄存器的状态</span><br></pre></td></tr></table></figure>
<p>hook5的主要代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">injectSo</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">char</span> *so_path, <span class="keyword">char</span> *function_name,<span class="keyword">char</span> *parameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">old_regs</span>,<span class="title">regs</span>;</span></span><br><span class="line">    <span class="keyword">long</span> mmap_addr, dlopen_addr, dlsym_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save old regs</span></span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;old_regs);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;regs, &amp;old_regs, <span class="keyword">sizeof</span>(regs));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get remote address</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getting remote addres:\n&quot;</span>);</span><br><span class="line">    mmap_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)mmap);</span><br><span class="line">    dlopen_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)dlopen);</span><br><span class="line">    dlsym_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)dlsym);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmap_addr=%p dlopen_addr=%p dlsym_addr=%p\n&quot;</span>,</span><br><span class="line">    (<span class="keyword">void</span>*)mmap_addr,(<span class="keyword">void</span>*)dlopen_addr,(<span class="keyword">void</span>*)dlsym_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> parameters[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mmap</span></span><br><span class="line">    parameters[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// address</span></span><br><span class="line">    parameters[<span class="number">1</span>] = <span class="number">0x4000</span>; <span class="comment">// size</span></span><br><span class="line">    parameters[<span class="number">2</span>] = PROT_READ | PROT_WRITE | PROT_EXEC; <span class="comment">// WRX</span></span><br><span class="line">    parameters[<span class="number">3</span>] = MAP_ANONYMOUS | MAP_PRIVATE; <span class="comment">// flag</span></span><br><span class="line">    parameters[<span class="number">4</span>] = <span class="number">0</span>; <span class="comment">// fd</span></span><br><span class="line">    parameters[<span class="number">5</span>] = <span class="number">0</span>; <span class="comment">// offset</span></span><br><span class="line">    </span><br><span class="line">    ptrace_call(pid, mmap_addr, parameters, <span class="number">6</span>, &amp;regs);</span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> map_base = regs.ARM_r0;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;map_base = %p\n&quot;</span>, (<span class="keyword">void</span>*)map_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dlopen</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;save so_path = %s to map_base = %p\n&quot;</span>, so_path, (<span class="keyword">void</span>*)map_base);</span><br><span class="line">    putdata(pid, map_base, so_path, <span class="built_in">strlen</span>(so_path) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    parameters[<span class="number">0</span>] = map_base;</span><br><span class="line">    parameters[<span class="number">1</span>] = RTLD_NOW| RTLD_GLOBAL;</span><br><span class="line"></span><br><span class="line">    ptrace_call(pid, dlopen_addr, parameters, <span class="number">2</span>, &amp;regs);</span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> handle = regs.ARM_r0;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handle = %p\n&quot;</span>,(<span class="keyword">void</span>*) handle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dlsym</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;save function_name = %s to map_base = %p\n&quot;</span>, function_name, (<span class="keyword">void</span>*)map_base);</span><br><span class="line">    putdata(pid, map_base, function_name, <span class="built_in">strlen</span>(function_name) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    parameters[<span class="number">0</span>] = handle;</span><br><span class="line">    parameters[<span class="number">1</span>] = map_base;</span><br><span class="line"></span><br><span class="line">    ptrace_call(pid, dlsym_addr, parameters, <span class="number">2</span>, &amp;regs);</span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> function_ptr = regs.ARM_r0;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function_ptr = %p\n&quot;</span>, (<span class="keyword">void</span>*)function_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// function_call</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;save parameter = %s to map_base = %p\n&quot;</span>, parameter, (<span class="keyword">void</span>*)map_base);</span><br><span class="line">    putdata(pid, map_base, parameter, <span class="built_in">strlen</span>(parameter) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    parameters[<span class="number">0</span>] = map_base;</span><br><span class="line"></span><br><span class="line">    ptrace_call(pid, function_ptr, parameters, <span class="number">1</span>, &amp;regs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore old regs</span></span><br><span class="line">    ptrace(PTRACE_SETREGS, pid, <span class="literal">NULL</span>, &amp;old_regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>arm处理器支持两种指令集，一种是arm指令集，另一种是thumb指令集。所以要hook的函数可能是被编译成arm指令集的，也有可能是被编译成thumb指令集的。需要注意的是thumb指令的长度是不固定的，但arm指令是固定的32位长度。<br>为了更容易地理解hook的原理，先只考虑arm指令集，因为arm相比thumb要简单一点，不需要考虑指令长度的问题。所以我们需要将target和hook的so编译成arm指令集的形式。很简单，只要在Android.mk中的文件名后面加上”.arm”即可 (真正的文件不用加)。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">LOCAL_MODULE    := target</span><br><span class="line">LOCAL_SRC_FILES := target.c.arm</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_EXECUTABLE)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">LOCAL_MODULE    := inject2</span><br><span class="line">LOCAL_SRC_FILES := inject2.c.arm</span><br><span class="line">LOCAL_LDLIBS := -llog </span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span></span><br></pre></td></tr></table></figure>
<p>确定了指令集以后，来看实现挂钩最重要的逻辑，这个逻辑是在注入的so里实现的。首先我们需要一个结构体保存汇编代码和hook地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hook_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> jump[<span class="number">3</span>]; <span class="comment">// 保存跳转指令</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> store[<span class="number">3</span>]; <span class="comment">// 保存原指令</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> orig; <span class="comment">// 保存原函数地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> patch; <span class="comment">// 保存hook函数地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接着来看注入的逻辑，最重要的函数为hook_direct()，他有三个参数，1）最开始定义的用来保存汇编代码和hook地址的结构体，2）要hook的原函数的地址，3）用来执行的hook函数地址。函数的源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hook_direct</span><span class="params">(struct <span class="keyword">hook_t</span> *h, <span class="keyword">unsigned</span> <span class="keyword">int</span> addr, <span class="keyword">void</span> *hookf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr  = %x\n&quot;</span>, addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hookf = %x\n&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)hookf);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将代码段改成可读可写可执行</span></span><br><span class="line">    mprotect((<span class="keyword">void</span>*)<span class="number">0x8000</span>, <span class="number">0xa000</span><span class="number">-0x8000</span>, PROT_READ|PROT_WRITE|PROT_EXEC);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// modify function entry </span></span><br><span class="line">    h-&gt;patch = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)hookf; <span class="comment">// hook函数地址</span></span><br><span class="line">    h-&gt;orig = addr; <span class="comment">// 原函数地址</span></span><br><span class="line">    h-&gt;jump[<span class="number">0</span>] = <span class="number">0xe59ff000</span>; <span class="comment">// 把目标函数第一条指令改成 LDR pc, [pc, #0];跳转到PC指针所指的地址</span></span><br><span class="line">    h-&gt;jump[<span class="number">1</span>] = h-&gt;patch; <span class="comment">// 由于pc寄存器读出的值实际上是当前指令地址加8，所以我们把后面两处指令</span></span><br><span class="line">    h-&gt;jump[<span class="number">2</span>] = h-&gt;patch; <span class="comment">// 都保存为hook函数的地址，这样的话，我们就能控制PC跳转到hook函数的地址了。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="comment">// 保存原函数的前三条指令</span></span><br><span class="line">        h-&gt;store[i] = ((<span class="keyword">int</span>*)h-&gt;orig)[i];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="comment">// 将函数入口指令改成跳转指令</span></span><br><span class="line">        ((<span class="keyword">int</span>*)h-&gt;orig)[i] = h-&gt;jump[i];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 刷新指令的缓存。因为虽然前面的操作修改了内存中的指令，但有可能被修改的指令已经被缓存起来了   </span></span><br><span class="line">    hook_cacheflush((<span class="keyword">unsigned</span> <span class="keyword">int</span>)h-&gt;orig, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)h-&gt;orig + <span class="keyword">sizeof</span>(h-&gt;jump));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然android有ASLR，但并没有PIE，所以program image是固定在0x8000这个地址的，因此我们用mprotect()函数将整个target代码段变成RWX，这样我们就能修改函数入口处的代码了。是否修改成功可以通过cat /proc/[pid]/maps查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F; # cat &#x2F;proc&#x2F;18029&#x2F;maps</span><br><span class="line">00008000-0000a000 rwxp 00000000 b3:1c 671749     &#x2F;data&#x2F;local&#x2F;tmp&#x2F;target</span><br><span class="line">0000a000-0000b000 r--p 00001000 b3:1c 671749     &#x2F;data&#x2F;local&#x2F;tmp&#x2F;target</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>然后需要确定目标函数的地址，这个有两种方法。1）如果目标程序本身没有被strip的话，那些symbol都是存在的，因此可以使用dlopen()和dlsym()等方法来获取目标函数地址。但很多情况，目标程序都会被strip，特别是可以直接运行的二进制文件默认都会被直接strip。比如target中的targetFunc()这个函数名会在编译的时候去掉，所以使用dlsym()的话是无法找到这个函数的。2）这时候我们就需要使用IDA或者objdump来定位一下目标函数的地址。比如用IDA找一下target程序里面targetFunc(int number)这个函数的地址：<br><img src="/images/androidhook/targetFunc.png"><br>虽然target这个binary被strip了，但还是可以找到targetFunc()这个函数的起始地址是在0x84c4。一般ARM程序在IDA中打开后，自定义的函数都在<code>Functions window</code>的前几个：<br><img src="/images/androidhook/window.png"><br>最后一个参数也就是我们要执行的hook函数的地址。得到这个地址非常简单，因为是so中的函数，调用hook_direct()的时候直接写上函数名即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hook_direct(&amp;eph, hookaddr, hookFunc);</span><br></pre></td></tr></table></figure>
<p>hook_cacheflush()代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">inline</span> <span class="title">hook_cacheflush</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> begin, <span class="keyword">unsigned</span> <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> syscall = <span class="number">0xf0002</span>;</span><br><span class="line"> </span><br><span class="line">    __asm __volatile (</span><br><span class="line">        <span class="string">&quot;mov     r0, %0\n&quot;</span>         </span><br><span class="line">        <span class="string">&quot;mov     r1, %1\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov     r7, %2\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov     r2, #0x0\n&quot;</span></span><br><span class="line">        <span class="string">&quot;svc     0x00000000\n&quot;</span></span><br><span class="line">        :</span><br><span class="line">        :   <span class="string">&quot;r&quot;</span> (begin), <span class="string">&quot;r&quot;</span> (end), <span class="string">&quot;r&quot;</span> (syscall)</span><br><span class="line">        :   <span class="string">&quot;r0&quot;</span>, <span class="string">&quot;r1&quot;</span>, <span class="string">&quot;r7&quot;</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刷新完缓存后，再执行到原函数的时候，pc指针就会跳转到自定义的hook函数中了，hook函数里的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>  __attribute__ ((noinline)) hookFunc(<span class="keyword">int</span> number)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;targetFunc() called, number = %d\n&quot;</span>, number);</span><br><span class="line">    number *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*orig_targetFunc)(<span class="keyword">int</span> number);</span><br><span class="line">    orig_targetFunc = (<span class="keyword">void</span> *)eph.orig;</span><br><span class="line">    </span><br><span class="line">    hook_precall(&amp;eph);</span><br><span class="line">    orig_targetFunc(number);</span><br><span class="line">    hook_postcall(&amp;eph);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先在hook函数中，可以获得原函数的参数（参数已经在寄存器中了，编写hook函数的时候，参数与原函数相同即可），并且可以对原函数的参数进行修改，比如说将数字乘2。随后使用<code>hook_precall(&amp;eph);</code>将原本函数的内容进行还原。hook_precall()内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hook_precall</span><span class="params">(struct <span class="keyword">hook_t</span> *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        ((<span class="keyword">int</span>*)h-&gt;orig)[i] = h-&gt;store[i];</span><br><span class="line"> </span><br><span class="line">    hook_cacheflush((<span class="keyword">unsigned</span> <span class="keyword">int</span>)h-&gt;orig, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)h-&gt;orig+<span class="keyword">sizeof</span>(h-&gt;jump)*<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在hook_precall()中，先对原本的三条指令进行还原，然后使用hook_cacheflush()对内存进行刷新。经过处理之后，就可以执行原来的函数orig_targetFunc(number)了。执行完后，如果还想再次hook这个函数，就需要调用hook_postcall(&amp;eph)将原本的三条指令再进行一次修改。<br>下面用hook5和libinject2.so来注入以下target这个程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;target</span><br><span class="line">Hello, Hooking! 0</span><br><span class="line">Hello, Hooking! 1</span><br><span class="line">Hello, Hooking! 2</span><br><span class="line">Hello, Hooking! 3</span><br><span class="line">Hello, Hooking! 4</span><br><span class="line">Hello, Hooking! 5</span><br><span class="line">Hello, Hooking! 6</span><br><span class="line">Hook Function pid &#x3D; 18561</span><br><span class="line">Hello HookFunction</span><br><span class="line">addr  &#x3D; 84c4</span><br><span class="line">hookf &#x3D; b6ea3da5</span><br><span class="line">targetFunc() called, number &#x3D; 7</span><br><span class="line">Hello, Hooking! 14</span><br><span class="line">targetFunc() called, number &#x3D; 8</span><br><span class="line">Hello, Hooking! 16</span><br><span class="line">targetFunc() called, number &#x3D; 9</span><br><span class="line">Hello, Hooking! 18</span><br><span class="line">targetFunc() called, number &#x3D; 10</span><br><span class="line">Hello, Hooking! 20</span><br><span class="line">targetFunc() called, number &#x3D; 11</span><br><span class="line">Hello, Hooking! 22</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;hook5 18561</span><br><span class="line">getting remote addres:</span><br><span class="line">mmap_addr&#x3D;0xb6ef9c5d dlopen_addr&#x3D;0xb6f49f31 dlsym_addr&#x3D;0xb6f49e81</span><br><span class="line">map_base &#x3D; 0xb6ea9000</span><br><span class="line">save so_path &#x3D; &#x2F;data&#x2F;local&#x2F;tmp&#x2F;libinject2.so to map_base &#x3D; 0xb6ea9000</span><br><span class="line">handle &#x3D; 0xb6f46494</span><br><span class="line">save function_name &#x3D; hookEntry to map_base &#x3D; 0xb6ea9000</span><br><span class="line">function_ptr &#x3D; 0xb6ea3e3d</span><br><span class="line">save parameter &#x3D; HookFunction to map_base &#x3D; 0xb6ea9000</span><br></pre></td></tr></table></figure>
<p><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://drops.wooyun.org/tips/9300">http://drops.wooyun.org/tips/9300</a><br><a target="_blank" rel="noopener" href="http://drops.wooyun.org/papers/10156">http://drops.wooyun.org/papers/10156</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/06/20/Radare2%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/06/20/Radare2%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" class="post-title-link" itemprop="url">Radare2使用说明</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2016-06-20 19:11:12" itemprop="dateCreated datePublished" datetime="2016-06-20T19:11:12+08:00">2016-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="radare2"><a href="#radare2" class="headerlink" title="radare2"></a>radare2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ radare2 -h # 查看帮助</span><br><span class="line">$ r2 -d file # 调试一个文件</span><br><span class="line">&gt; d? #显示调试命令</span><br><span class="line">|Usage: d # Debug commands</span><br><span class="line">| db[?]                   Breakpoints commands</span><br><span class="line">| dc[?]                   Continue execution</span><br><span class="line">| dm[?]                   Show memory maps</span><br><span class="line">| dr[?]                   Cpu registers</span><br><span class="line">...</span><br><span class="line">&gt; v # 进入visual mode，q退出；</span><br><span class="line">    # c可以显示一个游标；</span><br><span class="line">    # 按shift加hjkl可以选中；</span><br><span class="line">    # visual mode中可以用i来overwrite字节；</span><br><span class="line">    # p&#x2F;P切换其他visual mode view；</span><br><span class="line">    # s - step into，S - step over当前指令；</span><br><span class="line">    # b下断点；</span><br><span class="line">    # : 可以在visual mode中输入常规的radare命令</span><br></pre></td></tr></table></figure>
<p><strong>Seeking</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; s?</span><br><span class="line">&gt; s 0x0804848c # 查找这个地址，可以当跳转用</span><br><span class="line">&gt; s-           # 撤销查找</span><br><span class="line">&gt; s+           # 重做查找</span><br><span class="line">&gt; s*           # 列出撤销查找的历史</span><br><span class="line">&gt; s&#x2F; DATA      # 查找下一处&#39;DATA&#39;</span><br><span class="line">&gt; s&#x2F;x 85ff     # 查找下一处\x85\xff</span><br><span class="line">&gt; sf           # 查找下一个函数</span><br><span class="line">&gt; sr eip       # 查找寄存器</span><br></pre></td></tr></table></figure>
<p><strong>Block Size</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; b?</span><br><span class="line">&gt; b # 显示当前block大小</span><br><span class="line">&gt; b+3 # 当前block大小加3</span><br><span class="line">&gt; b 0x100 # 把block大小设置为0x100</span><br></pre></td></tr></table></figure>
<p><strong>Sections</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; S?</span><br><span class="line">&gt; S # 列出sections</span><br><span class="line">&gt; S. # 展示当前section名</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>Flags</strong><br>类似于书签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; f flag_name @ offset # create a flag type</span><br><span class="line">&gt; f- flag_name # 删除一个flag</span><br><span class="line">&gt; fs # 切换flagspace或创建新的flagspace</span><br><span class="line">&gt; fs symbols # 只选中symbols里的flag</span><br><span class="line">&gt; f # 列出flagspace里的flag</span><br></pre></td></tr></table></figure>

<h3 id="rabin2"><a href="#rabin2" class="headerlink" title="rabin2"></a>rabin2</h3><p><strong>File type identification</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ rabin2 -I test</span><br><span class="line">havecode true</span><br><span class="line">pic      false</span><br><span class="line">canary   false</span><br><span class="line">nx       true</span><br><span class="line">crypto   false</span><br><span class="line">va       true</span><br><span class="line">intrp    &#x2F;lib64&#x2F;ld-linux-x86-64.so.2</span><br><span class="line">bintype  elf</span><br><span class="line">class    ELF64</span><br><span class="line">lang     c</span><br><span class="line">arch     x86</span><br><span class="line">bits     64</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>Code Entrypoints</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ rabin2 -e test</span><br><span class="line">[Entrypoints]</span><br><span class="line">vaddr&#x3D;0x004004b0 paddr&#x3D;0x000004b0 baddr&#x3D;0x00400000 laddr&#x3D;0x00000000 type&#x3D;program</span><br><span class="line"></span><br><span class="line">1 entrypoints</span><br></pre></td></tr></table></figure>
<p><strong>Imports&amp;PLT</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ rabin2 -i test | head</span><br><span class="line">[Imports]</span><br><span class="line">ordinal&#x3D;001 plt&#x3D;0x00400470 bind&#x3D;GLOBAL type&#x3D;FUNC name&#x3D;printf</span><br><span class="line">ordinal&#x3D;002 plt&#x3D;0x00400480 bind&#x3D;GLOBAL type&#x3D;FUNC name&#x3D;__libc_start_main</span><br><span class="line">ordinal&#x3D;003 plt&#x3D;0x00400490 bind&#x3D;UNKNOWN type&#x3D;NOTYPE name&#x3D;__gmon_start__</span><br><span class="line">ordinal&#x3D;004 plt&#x3D;0x004004a0 bind&#x3D;GLOBAL type&#x3D;FUNC name&#x3D;__isoc99_scanf</span><br><span class="line"></span><br><span class="line">4 imports</span><br></pre></td></tr></table></figure>
<p><strong>Symbols(Exports)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rabin2 -s test | head</span><br><span class="line">[Symbols]</span><br><span class="line">vaddr&#x3D;0x00600e20 paddr&#x3D;0x00000e20 ord&#x3D;028 fwd&#x3D;NONE sz&#x3D;0 bind&#x3D;LOCAL type&#x3D;OBJECT name&#x3D;__JCR_LIST__</span><br><span class="line">vaddr&#x3D;0x004004e0 paddr&#x3D;0x000004e0 ord&#x3D;029 fwd&#x3D;NONE sz&#x3D;0 bind&#x3D;LOCAL type&#x3D;FUNC name&#x3D;deregister_tm_clones</span><br><span class="line">vaddr&#x3D;0x00400510 paddr&#x3D;0x00000510 ord&#x3D;030 fwd&#x3D;NONE sz&#x3D;0 bind&#x3D;LOCAL type&#x3D;FUNC name&#x3D;register_tm_clones</span><br><span class="line">vaddr&#x3D;0x00400550 paddr&#x3D;0x00000550 ord&#x3D;031 fwd&#x3D;NONE sz&#x3D;0 bind&#x3D;LOCAL type&#x3D;FUNC name&#x3D;__do_global_dtors_aux</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>List Libraries</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rabin2 -l test</span><br><span class="line">[Linked libraries]</span><br><span class="line">libc.so.6</span><br><span class="line"></span><br><span class="line">1 library</span><br></pre></td></tr></table></figure>
<p><strong>Strings</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabin2 -z test | head</span><br></pre></td></tr></table></figure>
<p><strong>Program Sections</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ rabin2 -S test</span><br><span class="line">rabin2 -S test</span><br><span class="line">[Sections]</span><br><span class="line">idx&#x3D;00 vaddr&#x3D;0x00000000 paddr&#x3D;0x00000000 sz&#x3D;0 vsz&#x3D;0 perm&#x3D;----- name&#x3D;</span><br><span class="line">idx&#x3D;01 vaddr&#x3D;0x00400238 paddr&#x3D;0x00000238 sz&#x3D;28 vsz&#x3D;28 perm&#x3D;--r-- name&#x3D;.interp</span><br><span class="line">idx&#x3D;02 vaddr&#x3D;0x00400254 paddr&#x3D;0x00000254 sz&#x3D;32 vsz&#x3D;32 perm&#x3D;--r-- name&#x3D;.note.ABI_tag</span><br><span class="line">idx&#x3D;03 vaddr&#x3D;0x00400274 paddr&#x3D;0x00000274 sz&#x3D;36 vsz&#x3D;36 perm&#x3D;--r-- name&#x3D;.note.gnu.build_id</span><br><span class="line">idx&#x3D;04 vaddr&#x3D;0x00400298 paddr&#x3D;0x00000298 sz&#x3D;28 vsz&#x3D;28 perm&#x3D;--r-- name&#x3D;.gnu.hash</span><br><span class="line">idx&#x3D;05 vaddr&#x3D;0x004002b8 paddr&#x3D;0x000002b8 sz&#x3D;120 vsz&#x3D;120 perm&#x3D;--r-- name&#x3D;.dynsym</span><br><span class="line">idx&#x3D;06 vaddr&#x3D;0x00400330 paddr&#x3D;0x00000330 sz&#x3D;88 vsz&#x3D;88 perm&#x3D;--r-- name&#x3D;.dynstr</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">40 sections</span><br></pre></td></tr></table></figure>

<h3 id="rasm2"><a href="#rasm2" class="headerlink" title="rasm2"></a>rasm2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ rasm2 -a java &#39;nop&#39;</span><br><span class="line">00</span><br><span class="line">$ rasm2 -a x86 -d &#39;90&#39;</span><br><span class="line">nop</span><br><span class="line">$ rasm2 -a x86 -b 64 &#39;syscall&#39;</span><br><span class="line">0f05</span><br></pre></td></tr></table></figure>

<h3 id="rahash2"><a href="#rahash2" class="headerlink" title="rahash2"></a>rahash2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rahash2 file -a md5</span><br><span class="line">file: 0x00000000-0x00000072 md5: b42ebe5fad4e8f020c8153a5b748ad2b</span><br></pre></td></tr></table></figure>

<h3 id="radiff2"><a href="#radiff2" class="headerlink" title="radiff2"></a>radiff2</h3><p>无参数运行radiff2显示修改的字节及对应的偏移</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ radiff2 test test-c</span><br><span class="line">radiff2 test test-c</span><br><span class="line">Buffer truncated to 8610 bytes (1 not compared)</span><br><span class="line">0x00000200 52 &#x3D;&gt; 02 0x00000200</span><br></pre></td></tr></table></figure>
<p>radiff2可以比较两个文件的相似度和距离</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ radiff2 -s test test-c</span><br><span class="line">Processing 8610 of 8609</span><br><span class="line">similarity: 1.000</span><br><span class="line">distance: 2</span><br></pre></td></tr></table></figure>

<h3 id="rafind2"><a href="#rafind2" class="headerlink" title="rafind2"></a>rafind2</h3><h3 id="ragg2"><a href="#ragg2" class="headerlink" title="ragg2"></a>ragg2</h3><h3 id="rarun2"><a href="#rarun2" class="headerlink" title="rarun2"></a>rarun2</h3><p>useful for:</p>
<ul>
<li>Crackmes</li>
<li>Fuzzing</li>
<li>Test suites</li>
</ul>
<h3 id="rax2"><a href="#rax2" class="headerlink" title="rax2"></a>rax2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ rax2 1337</span><br><span class="line">0x539</span><br><span class="line">$ rax2 -b 01111001</span><br><span class="line">y</span><br><span class="line">$ rax2 -S AB</span><br><span class="line">4142</span><br><span class="line">$ rax2 -s 4142</span><br><span class="line">AB</span><br><span class="line">$ rax2 -e 33 # swap endianness</span><br><span class="line">0x21000000</span><br></pre></td></tr></table></figure>

<p>先写这些吧，后面看心情补充。。。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/06/16/Android-Debug/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/06/16/Android-Debug/" class="post-title-link" itemprop="url">Android Debug</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2016-06-16 15:06:39" itemprop="dateCreated datePublished" datetime="2016-06-16T15:06:39+08:00">2016-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Android代码调试"><a href="#Android代码调试" class="headerlink" title="Android代码调试"></a>Android代码调试</h3><p>与Java一样，Dalvik实现了一个标准的调试接口，称为<code>Java调试线协议</code>（Java Debug Wire Protocol, <code>JDWP</code>）。所有用来调试Dalvik和Java上的程序的工具都是基于此协议开发的。 <a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/java/j-lo-jpda3/">深入Java调试体系</a><br>Android设备监视器（Monitor）和Dalvik调试监视服务器（DDMS）都采用了JDWP标准协议，它们用JDWP访问指定应用的信息（线程、堆使用情况、正在进行的方法调用）<br><strong>1.调试应用程序</strong><br>点击工具栏中的<code>Debug As</code>图标（like a bug）进入Debug界面，想要返回代码界面点击右上角的<code>Java</code>按钮。<br><img src="/images/androiddebug/Debug.png"><br>左上角的小窗是各个栈帧，点击某个栈帧会在代码窗口显示附近代码。<br><strong>2.显示framework层源代码</strong><br>点击栈帧时可以显示Android framework层源代码：首先要正确初始化AOSP资料库。<a target="_blank" rel="noopener" href="http://source.android.com/source/building.html">文档</a><br>下一步，为Eclipse创建类路径。在AOSP根目录下运行<code>make idegen</code>命令创建<code>idegen.sh</code>脚本，在顶层目录下创建<code>excluded-paths</code>文件，以排除顶层目录下不想包含的所有目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">^abi&#x2F;.*</span><br><span class="line">^external&#x2F;.*</span><br><span class="line">^packages&#x2F;.*</span><br><span class="line">^cts&#x2F;.*</span><br><span class="line">^art&#x2F;.*</span><br><span class="line">^dalvik&#x2F;.*</span><br><span class="line">^development&#x2F;.*</span><br><span class="line">^prebuilts&#x2F;.*</span><br><span class="line">^out&#x2F;.*</span><br><span class="line">^tools&#x2F;.*</span><br><span class="line">^sdk&#x2F;.*</span><br><span class="line">^libcore&#x2F;.*</span><br><span class="line">^gdk&#x2F;.*</span><br><span class="line">^hardware&#x2F;.*</span><br><span class="line">^device&#x2F;.*</span><br><span class="line">^kernel&#x2F;*</span><br><span class="line">^pdk&#x2F;*</span><br><span class="line">^developers&#x2F;*</span><br></pre></td></tr></table></figure>
<p>新建一个Java Project命名为AOSP Framework Source，取消Use Default Location复选框，指定AOSP根目录。<br>调试刚才的示例应用，右键栈帧窗口中的项目名，选择<code>Edit Source Lookup...</code>Add路径为Java Project，选上一步创建的AOSP Framework Source项目，再点击父栈帧时会显示framework层的代码。<br><img src="/images/androiddebug/srclookup.png"><br><strong>3.伪造调试设备</strong><br>对于原厂设备，启动Android SDK中自带的DDMS或Monitor只显示可调试进程。<br><img src="/images/androiddebug/ddms.png"><br>使用eng配置生成的工程设备允许访问所有进程。eng与user或userdebug之间的主要区别是系统属性ro.secure和ro.debuggable，user和userdebug生成时将这两个值设置为1和0；而eng生成时为0和1。<br>修改已root设备以支持调试系统服务和预装应用并不复杂，介绍一种简单但不是永久有效的方法，设备重启后失效。首先，获取一份<a target="_blank" rel="noopener" href="http://pan.baidu.com/s/1mi4IFTe">setpropex工具</a>，此工具可以在已root设备上修改只读的系统属性：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shell@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp $ su</span><br><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;setpropex ro.secure 0</span><br><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;setpropex ro.debuggable 1</span><br><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # getprop ro.secure</span><br><span class="line">0</span><br><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # getprop ro.debuggable</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>断开shell连接，在主机上使用adb root命令以root权限重启ADB守护进程。<br>最后重启所有依赖Dalvik VM的进程。在修改ro.debuggable属性后启动的任何进程都是可调试的。为了强制重启Android Dalvik层，可以简单地结束system_server进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # ps</span><br><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # kill -9 system_server_pid</span><br></pre></td></tr></table></figure>
<p>设备重启后，Monitor中会出现所有的Dalvik进程。<br><strong>4.附加到其他进程</strong><br>处于完全调试模式下的设备也支持实时调试任何Dalvik进程。在Eclipse启动并处于运行状态下，点击右上角的<code>DDMS</code>，在Devices窗口中选择目标进程，比如system_process。在Run菜单中选择Debug Configurations打开对话框，在对话框左边双击<code>Remote Java Application</code>新建一个链接，<code>Name</code>设为Attacher，Connect选项卡中<code>Project</code>设为AOSP Framework Source项目，<code>Host</code>设为127.0.0.1，Port设为<code>8700</code>。<br>最后点击Apply，点击Debug。</p>
<h3 id="调试原生代码"><a href="#调试原生代码" class="headerlink" title="调试原生代码"></a>调试原生代码</h3><p>关于如何使用原生代码编程可以参考《Android C++高级编程》<br><strong>1.使用Eclipse进行调试</strong><br>打开要调试的目标项目，首先，需要告知Android生成的应用必须支持调试：选择<code>Project-&gt;Properties</code>，点开<code>C/C++生成选项</code>并选择<code>Environment</code>，点击Add按钮，变量名输入<code>NDK_DEBUG</code>，值输入<code>1</code>。点击OK就可以开始调试了。为确保新的环境变量生效，选择<code>Project-&gt;Build All</code>。<br>先在Java代码调用Native代码之前下断点，点击<code>Debug As</code>开启调试，再在Native代码中想要调试的位置下断点进行调试：<br><img src="/images/androiddebug/debug_native.png"><br><strong>2.使用AOSP进行调试</strong><br>编译AOSP代码，烧录到Nexus5设备上，具体过程可以参考我的<a target="_blank" rel="noopener" href="http://pwn4.fun/2016/03/03/%E7%BC%96%E8%AF%91Android4-4-2%E6%BA%90%E7%A0%81%EF%BC%8C%E7%83%A7%E5%BD%95%E5%88%B0nexus5%E7%9C%9F%E6%9C%BA%E4%B8%8A/">另一篇文章</a>。<br>将GDB服务器二进制文件上传到设备：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android4.4.2 $ adb push prebuilts&#x2F;misc&#x2F;android-arm&#x2F;gdbserver&#x2F;gdbserver &#x2F;data&#x2F;local&#x2F;tmp</span><br><span class="line">android4.4.2 $ adb shell chmod 755 &#x2F;data&#x2F;local&#x2F;tmp&#x2F;gdbserver</span><br></pre></td></tr></table></figure>
<p>调试过程使用标准的TCP/IP连接将GDB客户端连接到GDB服务器上。建议通过USB使用ADB进行调试。用ADB的端口转发功能为GDB客户端打开一个管道：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android4.4.2 $ adb forward tcp:31337 tcp:31337</span><br></pre></td></tr></table></figure>
<p>下一步将GDB服务器执行目标程序或附加至进程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~ $ adb shell</span><br><span class="line"># 启动应用，也可以手动点开，命令行显得更专（zhuang）业（bi）一点</span><br><span class="line">root@hammerhead # am start -n com.bruce.jnitest&#x2F;.MainActivity </span><br><span class="line">root@hammerhead # ps</span><br><span class="line">...</span><br><span class="line">u0_a90    15078 28517 926056 41384 ffffffff 4009573c S com.bruce.jnitest</span><br><span class="line">...</span><br><span class="line">root@hammerhead # .&#x2F;gdbserver --attach tcp:31337 15078</span><br><span class="line"># 或执行目标程序： .&#x2F;gdbserver tcp:31337 .&#x2F;debugfile</span><br></pre></td></tr></table></figure>
<p>打开另一个终端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android4.4.2 $ cd prebuilts&#x2F;gcc&#x2F;linux-x86&#x2F;arm&#x2F;arm-eabi-4.7&#x2F;bin</span><br><span class="line">bin $ .&#x2F;arm-eabi-gdb -q</span><br><span class="line">(gdb) target remote :31337</span><br><span class="line">Remote debugging using :31337</span><br><span class="line">0x4009573c in ?? ()</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>在另一个终端中adb连接到设备，查看so库加载的基址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead # cat &#x2F;proc&#x2F;15078&#x2F;maps</span><br><span class="line">...</span><br><span class="line">74f1c000-74f20000 r-xp 00000000 b3:1c 1638414    &#x2F;data&#x2F;app-lib&#x2F;com.bruce.jnitest-1&#x2F;libJniTest.so</span><br><span class="line">74f20000-74f21000 r--p 00003000 b3:1c 1638414    &#x2F;data&#x2F;app-lib&#x2F;com.bruce.jnitest-1&#x2F;libJniTest.so</span><br><span class="line">74f21000-74f22000 rw-p 00004000 b3:1c 1638414    &#x2F;data&#x2F;app-lib&#x2F;com.bruce.jnitest-1&#x2F;libJniTest.so</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>从中可以看到so库的基址是74f1c000，在IDA中找到想要调试的代码地址，加上基址得到实际内存中代码的地址：<br><img src="/images/androiddebug/ida_addr.png"><br>切换到gdb客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break *0x74f1d998</span><br><span class="line">Breakpoint 1 at 0x74f1d998</span><br><span class="line">(gdb) x&#x2F;i 0x74f1d998</span><br><span class="line">   0x74f1d998:    mov    r3, #0</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"># 触发应用调用so库中的native代码</span><br><span class="line">Program received signal SIGILL, Illegal instruction.</span><br><span class="line">0x74f1d99c in ?? ()</span><br><span class="line">(gdb) disas 0x74f1d99c,+20</span><br><span class="line">Dump of assembler code from 0x74f1d99c to 0x74f1d9b0:</span><br><span class="line">&#x3D;&gt; 0x74f1d99c:    str    r3, [r11, #-48]    ; 0x30</span><br><span class="line">   0x74f1d9a0:    b    0x74f1d9d0</span><br><span class="line">   0x74f1d9a4:    ldr    r2, [r11, #-48]    ; 0x30</span><br><span class="line">   0x74f1d9a8:    mvn    r3, #27</span><br><span class="line">   0x74f1d9ac:    lsl    r2, r2, #2</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<p>剩下就可以使用GDB命令进行调试了。<br><strong>3.使用IDA调试</strong><br>GDB对thumb指令支持不好，调试thumb指令时最好还是用IDA。</p>
<ul>
<li>打开ddms<br>打开ddms才能打开调试端口，才能用jdb</li>
<li>adb push android_server /data/local/tmp/<br>android_server在IDA安装目录的dbgsvr目录中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">cd &#x2F;data&#x2F;local&#x2F;tmp</span><br><span class="line">chmod 777 android_server</span><br><span class="line">.&#x2F;android_server</span><br></pre></td></tr></table></figure></li>
<li>adb forward tcp:23946 tcp:23946</li>
<li>adb shell am start -D -n com.bruce.jnitest</li>
<li>IDA attach到目标应用上<br><code>Debugger-&gt;Attach-&gt;Remote ARMLinux/Android debugger</code><br><img src="/images/androiddebug/android_attach.png"><br>选择<code>com.bruce.jnitest</code>，进程过多可以ctrl+F查找<br><img src="/images/androiddebug/pick_process.png">  </li>
<li>suspend on library loading<br><code>Debugger-&gt;Debugger options...</code><br><img src="/images/androiddebug/debug_options.png"><br>选择<code>suspend on libaray load/unload</code>，然后按F9继续执行。  </li>
<li>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700<br><img src="/images/androiddebug/jdb.png"><br>弹出的框都点cancel就行了，在右边的Modules窗口中找到要调试的so库双击。<br><img src="/images/androiddebug/modules.png"><br>在新窗口中找到想要调试的函数，右键添加断点，继续执行程序。（在linker时会停多次，继续执行即可）<br><img src="/images/androiddebug/add_breakp.png"><br>下面触发应用调用库函数，控制流即停在断点处<br><img src="/images/androiddebug/begin_debug.png"><br>有时在一个函数里无法使用F5，这时在函数中按P，IDA会把这段代码作为函数分析，再按F5即可。  </li>
</ul>
<p><strong>reference</strong><br>《Android安全攻防权威指南》<br><a target="_blank" rel="noopener" href="http://drops.wooyun.org/tips/6840">http://drops.wooyun.org/tips/6840</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bruce Fan"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Bruce Fan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">125</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bruce Fan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
