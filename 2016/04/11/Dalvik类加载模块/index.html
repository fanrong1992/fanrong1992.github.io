<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/favicon.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="类加载机制Dalvik虚拟机中，类加载机制的主要功能就是将应用程序中Dalvik操作码以及程序数据提取并加载到虚拟机内部。Dex文件是类加载机制的输入文件，输出是一个名为ClassObject的数据结构实例对象。 工作流程类加载机制的主要内容及工作流程主要分三点：(1) 对Dex文件进行验证并优化。(2) 对优化后的Dex文件进行解析。(3) 对指定类进行实际加载。">
<meta property="og:type" content="article">
<meta property="og:title" content="Dalvik类加载模块">
<meta property="og:url" content="http://example.com/2016/04/11/Dalvik%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97/index.html">
<meta property="og:site_name" content="BruceFan&#39;s Blog">
<meta property="og:description" content="类加载机制Dalvik虚拟机中，类加载机制的主要功能就是将应用程序中Dalvik操作码以及程序数据提取并加载到虚拟机内部。Dex文件是类加载机制的输入文件，输出是一个名为ClassObject的数据结构实例对象。 工作流程类加载机制的主要内容及工作流程主要分三点：(1) 对Dex文件进行验证并优化。(2) 对优化后的Dex文件进行解析。(3) 对指定类进行实际加载。">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/images/androiddalvik2/dexodex.png">
<meta property="article:published_time" content="2016-04-11T07:57:17.000Z">
<meta property="article:modified_time" content="2022-08-09T16:03:24.919Z">
<meta property="article:author" content="Bruce Fan">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/androiddalvik2/dexodex.png">

<link rel="canonical" href="http://example.com/2016/04/11/Dalvik%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>Dalvik类加载模块 | BruceFan's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">BruceFan's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry, stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/04/11/Dalvik%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Dalvik类加载模块
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2016-04-11 15:57:17" itemprop="dateCreated datePublished" datetime="2016-04-11T15:57:17+08:00">2016-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2022-08-10 00:03:24" itemprop="dateModified" datetime="2022-08-10T00:03:24+08:00">2022-08-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>Dalvik虚拟机中，类加载机制的主要功能就是将应用程序中Dalvik操作码以及程序数据提取并加载到虚拟机内部。Dex文件是类加载机制的输入文件，输出是一个名为<code>ClassObject</code>的数据结构实例对象。</p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>类加载机制的主要内容及工作流程主要分三点：<br>(1) 对Dex文件进行验证并优化。<br>(2) 对优化后的Dex文件进行解析。<br>(3) 对指定类进行实际加载。  </p>
<a id="more"></a>
<h2 id="Dex文件的优化与验证"><a href="#Dex文件的优化与验证" class="headerlink" title="Dex文件的优化与验证"></a>Dex文件的优化与验证</h2><p>为了保证原Dex文件的数据安全与优化机制的独立性，优化机制重新创建一个<code>.Odex</code>文件，主要包括<code>依赖库关系</code>、<code>寄存器映射关系</code>以及<code>类的索引关系</code>。</p>
<h3 id="Odex文件结构分析"><a href="#Odex文件结构分析" class="headerlink" title="Odex文件结构分析"></a>Odex文件结构分析</h3><p>Dex文件与Odex文件结构对比：<br><img src="/images/androiddalvik2/dexodex.png"><br>DexOptHeader数据结构定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexOptHeader</span> &#123;</span></span><br><span class="line">    u1 magic[<span class="number">8</span>];   <span class="comment">//Odex文件版本标识</span></span><br><span class="line">    u4 dexOffset;  <span class="comment">// 原Dex文件起始位置偏移量（0x28）</span></span><br><span class="line">    u4 dexLenght;  <span class="comment">// Dex文件总长度</span></span><br><span class="line">    u4 depsOffset; <span class="comment">// Odex文件依赖库列表偏移量</span></span><br><span class="line">    u4 depsLength; <span class="comment">// 依赖库信息总长度</span></span><br><span class="line">    u4 optOffset;  <span class="comment">// 优化数据信息偏移量</span></span><br><span class="line">    u4 optLength;  <span class="comment">// 优化数据总长度，类索引信息封装在这</span></span><br><span class="line">    u4 flags;      <span class="comment">// 标识位，用于标示Odex优化与验证选项</span></span><br><span class="line">    u4 checksum;   <span class="comment">// 文件校验和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>依赖库信息</li>
</ol>
<p>Dependence结构不会被加载进内存，Android源码中也没有它的明确定义，以下为整理形式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dependence</span> &#123;</span></span><br><span class="line">    u4 modWhen;          <span class="comment">// 时间戳</span></span><br><span class="line">    u4 crc;              <span class="comment">// 校验信息</span></span><br><span class="line">    u4 DALVIK_VM_BUILD;  <span class="comment">// 虚拟机版本号</span></span><br><span class="line">    u4 numDeps;          <span class="comment">// 依赖库个数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        u4 len;          <span class="comment">// name长度</span></span><br><span class="line">        u4 name[len];    <span class="comment">// 依赖库名称</span></span><br><span class="line">        kSHA1DigestLen signature; <span class="comment">// SHA-1值</span></span><br><span class="line">    &#125; table[numDeps];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>类索引信息</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassLookup</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;         <span class="comment">// 总大小</span></span><br><span class="line">    <span class="keyword">int</span> numEntries;   <span class="comment">// 表的项数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	    u4 classDescriptorHash;     <span class="comment">// 类描述符的哈希值</span></span><br><span class="line">	    <span class="keyword">int</span> classDescriptorOffset;  <span class="comment">// Dex文件中该类描述符的偏移位置</span></span><br><span class="line">	    <span class="keyword">int</span> classDefOffset;         <span class="comment">// Dex文件中该类定义偏移位置</span></span><br><span class="line">    &#125; table[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>numEntries是通过<code>dexRoundUpPower2()</code>（用于求比一个数大的最小的2的整数次幂，如数为6，结果为8，降低了哈希冲突率）函数生成。</p>
<h3 id="函数执行流程"><a href="#函数执行流程" class="headerlink" title="函数执行流程"></a>函数执行流程</h3><p>PackageManagerService-&gt;Installer-&gt;installd-&gt;do_dexopt-&gt;dexopt-&gt;run_dexopt-&gt;/system/bin/dexopt<br><code>/system/bin/dexopt</code>的代码位于dalvik/dexopt/OptMain.cpp文件，其中<code>extractAndProcessZip()</code>是优化机制的主控程序。<br><strong>代码清单</strong> dalvik/dexopt/OptMain.cpp: extractAndProcessZip()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Extract &quot;classes.dex&quot; from zipFd into &quot;cacheFd&quot;, leaving a little space</span></span><br><span class="line"><span class="comment"> * up front for the DEX optimization header.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">extractAndProcessZip</span><span class="params">(<span class="keyword">int</span> zipFd, <span class="keyword">int</span> cacheFd,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span>* debugFileName, <span class="keyword">bool</span> isBootstrap, <span class="keyword">const</span> <span class="keyword">char</span>* bootClassPath,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span>* dexoptFlagStr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ZipArchive zippy; <span class="comment">// 用于描述ZIP压缩文件的数据结构</span></span><br><span class="line">    ZipEntry zipEntry; <span class="comment">// 用于表示一个ZIP入口</span></span><br><span class="line">    <span class="keyword">size_t</span> uncompLen;</span><br><span class="line">    <span class="keyword">long</span> modWhen, crc32;</span><br><span class="line">    <span class="keyword">off_t</span> dexOffset; <span class="comment">// 用于表示在Odex文件中，原Dex文件的起始地址</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> dexoptFlags = <span class="number">0</span>;        <span class="comment">/* bit flags, from enum DexoptFlags */</span></span><br><span class="line">	<span class="comment">// 设置默认的优化模式</span></span><br><span class="line">    DexClassVerifyMode verifyMode = VERIFY_MODE_ALL;</span><br><span class="line">    DexOptimizerMode dexOptMode = OPTIMIZE_MODE_VERIFIED;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;zippy, <span class="number">0</span>, <span class="keyword">sizeof</span>(zippy));</span><br><span class="line">    <span class="comment">/* make sure we&#x27;re still at the start of an empty file */</span></span><br><span class="line">    <span class="keyword">if</span> (lseek(cacheFd, <span class="number">0</span>, SEEK_END) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;DexOptZ: new cache file &#x27;%s&#x27; is not empty&quot;</span>, debugFileName);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Write a skeletal DEX optimization header.  We want the classes.dex</span></span><br><span class="line"><span class="comment">     * to come just after it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    err = dexOptCreateEmptyHeader(cacheFd);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    <span class="comment">/* record the file position so we can get back here later */</span></span><br><span class="line">	<span class="comment">// 取得Odex文件中原Dex文件的起始位置，实际就是一个Odex文件头部的长度</span></span><br><span class="line">    dexOffset = lseek(cacheFd, <span class="number">0</span>, SEEK_CUR);</span><br><span class="line">    <span class="keyword">if</span> (dexOffset &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Open the zip archive, find the DEX entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dexZipPrepArchive(zipFd, debugFileName, &amp;zippy) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;DexOptZ: unable to open zip archive &#x27;%s&#x27;&quot;</span>, debugFileName);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 获取目标Dex文件的解压入口</span></span><br><span class="line">    zipEntry = dexZipFindEntry(&amp;zippy, kClassesDex);</span><br><span class="line">    <span class="keyword">if</span> (zipEntry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;DexOptZ: zip archive &#x27;%s&#x27; does not include %s&quot;</span>,</span><br><span class="line">            debugFileName, kClassesDex);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Extract some info about the zip entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dexZipGetEntryInfo(&amp;zippy, zipEntry, <span class="literal">NULL</span>, &amp;uncompLen, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">            &amp;modWhen, &amp;crc32) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;DexOptZ: zip archive GetEntryInfo failed on %s&quot;</span>, debugFileName);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    uncompLen = uncompLen;</span><br><span class="line">    modWhen = modWhen;</span><br><span class="line">    crc32 = crc32;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Extract the DEX data into the cache file at the current offset.</span></span><br><span class="line"><span class="comment">	 * 从ZIP文件将目标Dex文件解压出来，并写入cacheFd所指文件，此时cacheFd所指文件非空，</span></span><br><span class="line"><span class="comment">	 * 包括一个Odex文件头部加上一个原始的Dex文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dexZipExtractEntryToFile(&amp;zippy, zipEntry, cacheFd) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;DexOptZ: extraction of %s from %s failed&quot;</span>,</span><br><span class="line">            kClassesDex, debugFileName);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Parse the options. */</span></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * 入口参数dexoptFlagStr，对验证优化需求进行分析，dexoptFlagStr实际上是一个字符串，</span></span><br><span class="line"><span class="comment">	 * 记录了验证优化的要求</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">if</span> (dexoptFlagStr[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* opc;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* val;</span><br><span class="line">		<span class="comment">// 设置验证模式</span></span><br><span class="line">        opc = <span class="built_in">strstr</span>(dexoptFlagStr, <span class="string">&quot;v=&quot;</span>);      <span class="comment">/* verification */</span></span><br><span class="line">        <span class="keyword">if</span> (opc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (*(opc+<span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:   verifyMode = VERIFY_MODE_NONE;          <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:   verifyMode = VERIFY_MODE_REMOTE;        <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:   verifyMode = VERIFY_MODE_ALL;           <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:                                            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 设置优化模式</span></span><br><span class="line">        opc = <span class="built_in">strstr</span>(dexoptFlagStr, <span class="string">&quot;o=&quot;</span>);      <span class="comment">/* optimization */</span></span><br><span class="line">        <span class="keyword">if</span> (opc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (*(opc+<span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:   dexOptMode = OPTIMIZE_MODE_NONE;        <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:   dexOptMode = OPTIMIZE_MODE_VERIFIED;    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:   dexOptMode = OPTIMIZE_MODE_ALL;         <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:   dexOptMode = OPTIMIZE_MODE_FULL;        <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:                                            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        opc = <span class="built_in">strstr</span>(dexoptFlagStr, <span class="string">&quot;m=y&quot;</span>);     <span class="comment">/* register map */</span></span><br><span class="line">        <span class="keyword">if</span> (opc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            dexoptFlags |= DEXOPT_GEN_REGISTER_MAPS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        opc = <span class="built_in">strstr</span>(dexoptFlagStr, <span class="string">&quot;u=&quot;</span>);      <span class="comment">/* uniprocessor target */</span></span><br><span class="line">        <span class="keyword">if</span> (opc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (*(opc+<span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:   dexoptFlags |= DEXOPT_UNIPROCESSOR;     <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:   dexoptFlags |= DEXOPT_SMP;              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:                                            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Prep the VM and perform the optimization.</span></span><br><span class="line"><span class="comment">	 * 完成了原Dex文件的提取以及验证优化选项的设置，即可以开始真正的优化工作，需要</span></span><br><span class="line"><span class="comment">	 * 初始化一个虚拟机专门用于验证优化工作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dvmPrepForDexOpt(bootClassPath, dexOptMode, verifyMode,</span><br><span class="line">            dexoptFlags) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;DexOptZ: VM init failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//vmStarted = 1;</span></span><br><span class="line">    <span class="comment">/* do the optimization */</span></span><br><span class="line">    <span class="keyword">if</span> (!dvmContinueOptimization(cacheFd, dexOffset, uncompLen, debugFileName,</span><br><span class="line">            modWhen, crc32, isBootstrap))</span><br><span class="line">    &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Optimization failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* we don&#x27;t shut the VM down -- process is about to exit */</span></span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">bail:</span><br><span class="line">    dexZipCloseArchive(&amp;zippy);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码清单</strong> dalvik/vm/analysis/DexPrepare.cpp: dvmContinueOptimization()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dvmContinueOptimization</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> dexOffset, <span class="keyword">long</span> dexLength,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span>* fileName, u4 modWhen, u4 crc, <span class="keyword">bool</span> isBootstrap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明相关中间变量</span></span><br><span class="line">    DexClassLookup* pClassLookup = <span class="literal">NULL</span>; <span class="comment">// 类索引信息</span></span><br><span class="line">    RegisterMapBuilder* pRegMapBuilder = <span class="literal">NULL</span>; <span class="comment">// 寄存器映射关系信息</span></span><br><span class="line"></span><br><span class="line">    assert(gDvm.optimizing);</span><br><span class="line">    ALOGV(<span class="string">&quot;Continuing optimization (%s, isb=%d)&quot;</span>, fileName, isBootstrap);</span><br><span class="line"></span><br><span class="line">    assert(dexOffset &gt;= <span class="number">0</span>); <span class="comment">// 判断输入文件长度非0</span></span><br><span class="line">    <span class="comment">// 对目标文件进行合法性检验，Dex文件长度不能小于其文件头长度</span></span><br><span class="line">    <span class="keyword">if</span> (dexLength &lt; (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(DexHeader)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;too small to be DEX&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Odex文件中的Dex文件的起始偏移量不能小于Odex文件头的长度</span></span><br><span class="line">    <span class="keyword">if</span> (dexOffset &lt; (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(DexOptHeader)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;not enough room for opt header&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 将fd所指文件映射到某一内存位置，该位置的起始地址为mapAddr，其大小</span></span><br><span class="line"><span class="comment">         * 就为fd所指文件大小，即一个Odex文件头部加上一个Dex文件长度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        mapAddr = mmap(<span class="literal">NULL</span>, dexOffset + dexLength, PROT_READ|PROT_WRITE,</span><br><span class="line">                    MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mapAddr == MAP_FAILED) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;unable to mmap DEX cache: %s&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置相关的验证优化选项</span></span><br><span class="line">        <span class="keyword">bool</span> doVerify, doOpt;</span><br><span class="line">        <span class="keyword">if</span> (gDvm.classVerifyMode == VERIFY_MODE_NONE) &#123;</span><br><span class="line">            doVerify = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gDvm.classVerifyMode == VERIFY_MODE_REMOTE) &#123;</span><br><span class="line">            doVerify = !gDvm.optimizingBootstrapClass;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">/*if (gDvm.classVerifyMode == VERIFY_MODE_ALL)*/</span> &#123;</span><br><span class="line">            doVerify = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gDvm.dexOptMode == OPTIMIZE_MODE_NONE) &#123;</span><br><span class="line">            doOpt = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gDvm.dexOptMode == OPTIMIZE_MODE_VERIFIED ||</span><br><span class="line">                   gDvm.dexOptMode == OPTIMIZE_MODE_FULL) &#123;</span><br><span class="line">            doOpt = doVerify;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">/*if (gDvm.dexOptMode == OPTIMIZE_MODE_ALL)*/</span> &#123;</span><br><span class="line">            doOpt = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重写文件，主要包括：字符顺序调整、结构重新对齐、类验证、字节码优化</span></span><br><span class="line">        success = rewriteDex(((u1*) mapAddr) + dexOffset, dexLength,</span><br><span class="line">                    doVerify, doOpt, &amp;pClassLookup, <span class="literal">NULL</span>);</span><br><span class="line">        ...</span><br><span class="line">    <span class="comment">// 对文件进行8字节对齐</span></span><br><span class="line">    <span class="keyword">off_t</span> depsOffset, optOffset, endOffset, adjOffset;</span><br><span class="line">    <span class="keyword">int</span> depsLength, optLength;</span><br><span class="line">    u4 optChecksum;</span><br><span class="line"></span><br><span class="line">    depsOffset = lseek(fd, <span class="number">0</span>, SEEK_END); <span class="comment">// 取得fd所指文件大小</span></span><br><span class="line">    <span class="keyword">if</span> (depsOffset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;lseek to EOF failed: %s&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// depsOffset是dependency list起始地址</span></span><br><span class="line">    adjOffset = (depsOffset + <span class="number">7</span>) &amp; ~(<span class="number">0x07</span>); <span class="comment">// 8字节对齐，adjOffset&gt;=depsOffset</span></span><br><span class="line">    <span class="keyword">if</span> (adjOffset != depsOffset) &#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;Adjusting deps start from %d to %d&quot;</span>,</span><br><span class="line">            (<span class="keyword">int</span>) depsOffset, (<span class="keyword">int</span>) adjOffset);</span><br><span class="line">        depsOffset = adjOffset;</span><br><span class="line">        lseek(fd, depsOffset, SEEK_SET);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写入依赖库信息</span></span><br><span class="line">    <span class="keyword">if</span> (writeDependencies(fd, modWhen, crc) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;Failed writing dependencies&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算依赖库长度，调整优化信息的起始地址8字节对齐</span></span><br><span class="line">    optOffset = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    depsLength = optOffset - depsOffset;</span><br><span class="line"></span><br><span class="line">    adjOffset = (optOffset + <span class="number">7</span>) &amp; ~(<span class="number">0x07</span>);</span><br><span class="line">    <span class="keyword">if</span> (adjOffset != optOffset) &#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;Adjusting opt start from %d to %d&quot;</span>,</span><br><span class="line">            (<span class="keyword">int</span>) optOffset, (<span class="keyword">int</span>) adjOffset);</span><br><span class="line">        optOffset = adjOffset;</span><br><span class="line">        lseek(fd, optOffset, SEEK_SET);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写入其他优化信息，包括类索引以及寄存器映射关系</span></span><br><span class="line">    <span class="keyword">if</span> (!writeOptData(fd, pClassLookup, pRegMapBuilder)) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;Failed writing opt data&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 对Odex文件的头部内容进行修正</span></span><br><span class="line">    DexOptHeader optHdr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;optHdr, <span class="number">0xff</span>, <span class="keyword">sizeof</span>(optHdr));</span><br><span class="line">    <span class="built_in">memcpy</span>(optHdr.magic, DEX_OPT_MAGIC, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(optHdr.magic+<span class="number">4</span>, DEX_OPT_MAGIC_VERS, <span class="number">4</span>);</span><br><span class="line">    optHdr.dexOffset = (u4) dexOffset;</span><br><span class="line">    optHdr.dexLength = (u4) dexLength;</span><br><span class="line">    optHdr.depsOffset = (u4) depsOffset;</span><br><span class="line">    optHdr.depsLength = (u4) depsLength;</span><br><span class="line">    optHdr.optOffset = (u4) optOffset;</span><br><span class="line">    optHdr.optLength = (u4) optLength;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<h2 id="Dex文件的解析"><a href="#Dex文件的解析" class="headerlink" title="Dex文件的解析"></a>Dex文件的解析</h2><h3 id="DexFile数据结构"><a href="#DexFile数据结构" class="headerlink" title="DexFile数据结构"></a>DexFile数据结构</h3><p>Dex文件解析的重要目标是为Dex文件生成一个DexFile数据结构。<br>DexFile结构体定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexFile</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> DexOptHeader* pOptHeader;      <span class="comment">// 优化数据头</span></span><br><span class="line">    <span class="keyword">const</span> DexHeader* pHeader;            <span class="comment">// Dex文件头</span></span><br><span class="line">    <span class="keyword">const</span> DexStringId * pStringIds;      <span class="comment">// 指向字符串索引区</span></span><br><span class="line">    <span class="keyword">const</span> DexTypeId* pTypeIds;           <span class="comment">// 指向类型索引区</span></span><br><span class="line">    <span class="keyword">const</span> DexFieldId* pFieldIds;         <span class="comment">// 指向字段索引区</span></span><br><span class="line">    <span class="keyword">const</span> DexMethodId* pMethodIds;       <span class="comment">// 指向方法索引区</span></span><br><span class="line">    <span class="keyword">const</span> DexProtoId* pProtoIds;         <span class="comment">// 指向原型索引区</span></span><br><span class="line">    <span class="keyword">const</span> DexClassDef* pClassDefs;       <span class="comment">// 指向类定义区</span></span><br><span class="line">    <span class="keyword">const</span> DexLink* pLinkData;            <span class="comment">// 指向链接数据区</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> DexClassLookup* pClassLookup;  <span class="comment">// 类索引</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>* pRegisterMapPool;        <span class="comment">// 寄存器映射关系</span></span><br><span class="line">    <span class="keyword">const</span> u1* baseAddr;                  <span class="comment">// 基地址</span></span><br><span class="line">    <span class="keyword">int</span> overhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dex文件解析流程"><a href="#Dex文件解析流程" class="headerlink" title="Dex文件解析流程"></a>Dex文件解析流程</h3><ol>
<li>对Odex文件进行完整性校验</li>
<li>解析Odex文件中的优化数据</li>
<li>为Dex文件与相关数据结构建立映射关系</li>
<li>为Dex文件进行校验并计算SHA-1</li>
<li>保存设置并返回</li>
</ol>
<h3 id="函数执行流程-1"><a href="#函数执行流程-1" class="headerlink" title="函数执行流程"></a>函数执行流程</h3><p>Dex文件的解析工作主要由虚拟机源码目录dalvik/vm/RawDexFile.cpp中的<code>dvmRawDexFileOpen()</code>函数完成，这部分工作中称其为主控函数。<br><strong>代码清单</strong> dalvik/vm/RawDexFile.cpp: dvmRawDexFileOpen()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dvmRawDexFileOpen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fileName, <span class="keyword">const</span> <span class="keyword">char</span>* odexOutputName,</span></span></span><br><span class="line"><span class="function"><span class="params">    RawDexFile** ppRawDexFile, <span class="keyword">bool</span> isBootstrap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明函数中间的执行变量</span></span><br><span class="line">    DvmDex* pDvmDex = <span class="literal">NULL</span>;     <span class="comment">// 用于在虚拟机中描述解析的Dex文件</span></span><br><span class="line">    <span class="keyword">char</span>* cachedName = <span class="literal">NULL</span>;    <span class="comment">// 用于保存执行期间产生的优化Dex文件名</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">-1</span>;            <span class="comment">// 设置函数返回值，0表示成功</span></span><br><span class="line">    <span class="keyword">int</span> dexFd = <span class="number">-1</span>;             <span class="comment">// 目标Dex文件的文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> optFd = <span class="number">-1</span>;             <span class="comment">// 优化Dex文件的文件描述符</span></span><br><span class="line">    u4 modTime = <span class="number">0</span>;             <span class="comment">// 文件修改时间参数</span></span><br><span class="line">    u4 adler32 = <span class="number">0</span>;             <span class="comment">// 校验和</span></span><br><span class="line">    <span class="keyword">size_t</span> fileSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> newFile = <span class="literal">false</span>;       <span class="comment">// 标示虚拟机是否需要对Dex文件进行优化</span></span><br><span class="line">    <span class="keyword">bool</span> locked = <span class="literal">false</span>;        <span class="comment">// 标示优化进程占用</span></span><br><span class="line">    <span class="comment">// fileName记录了Dex文件在文件系统中的绝对路径，用open函数根据fileName将目标文件读入内存</span></span><br><span class="line">    dexFd = open(fileName, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (dexFd &lt; <span class="number">0</span>) <span class="keyword">goto</span> bail;</span><br><span class="line">    <span class="comment">/* If we fork/exec into dexopt, don&#x27;t let it inherit the open fd. */</span></span><br><span class="line">    dvmSetCloseOnExec(dexFd);</span><br><span class="line">    <span class="comment">// 对dex文件的合法性与正确性进行检验</span></span><br><span class="line">    <span class="keyword">if</span> (verifyMagicAndGetAdler32(dexFd, &amp;adler32) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Error with header for %s&quot;</span>, fileName);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录文件修改时间并赋值给modTime</span></span><br><span class="line">    <span class="keyword">if</span> (getModTimeAndSize(dexFd, &amp;modTime, &amp;fileSize) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Error with stat for %s&quot;</span>, fileName);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据目标Dex文件名为其产生相应的Odex文件名，并赋值给cachedName</span></span><br><span class="line">    <span class="keyword">if</span> (odexOutputName == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cachedName = dexOptGenerateCacheFileName(fileName, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (cachedName == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cachedName = strdup(odexOutputName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">&quot;dvmRawDexFileOpen: Checking cache for %s (%s)&quot;</span>,</span><br><span class="line">            fileName, cachedName);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 尝试根据cachedName所指的Odex文件名在cache中查找并读取Odex文件，如果读取失败或是当前的Odex文件有误</span></span><br><span class="line"><span class="comment">     * 则需要重新对Dex文件进行优化(将newFile设为true)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    optFd = dvmOpenCachedDexFile(fileName, cachedName, modTime,</span><br><span class="line">        adler32, isBootstrap, &amp;newFile, <span class="comment">/*createIfMissing=*/</span><span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (optFd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">&quot;Unable to open or create cache for %s (%s)&quot;</span>,</span><br><span class="line">                fileName, cachedName);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    locked = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  虚拟机根据newFile的值决定是否对Dex文件进行优化</span></span><br><span class="line">    <span class="keyword">if</span> (newFile) &#123;</span><br><span class="line">        u8 startWhen, copyWhen, endWhen;</span><br><span class="line">        <span class="keyword">bool</span> result;</span><br><span class="line">        <span class="keyword">off_t</span> dexOffset;</span><br><span class="line"></span><br><span class="line">        dexOffset = lseek(optFd, <span class="number">0</span>, SEEK_CUR);</span><br><span class="line">        result = (dexOffset &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            startWhen = dvmGetRelativeTimeUsec();</span><br><span class="line">            <span class="comment">// 将dexFd所指文件复制到optFd所指文件中</span></span><br><span class="line">            result = copyFileToFile(optFd, dexFd, fileSize) == <span class="number">0</span>;</span><br><span class="line">            copyWhen = dvmGetRelativeTimeUsec();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用dvmOptimizeDexFile函数对optFd所指文件进行优化</span></span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            result = dvmOptimizeDexFile(optFd, dexOffset, fileSize,</span><br><span class="line">                fileName, modTime, adler32, isBootstrap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;Unable to extract+optimize DEX from &#x27;%s&#x27;&quot;</span>, fileName);</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        endWhen = dvmGetRelativeTimeUsec();</span><br><span class="line">        ALOGD(<span class="string">&quot;DEX prep &#x27;%s&#x27;: copy in %dms, rewrite %dms&quot;</span>,</span><br><span class="line">            fileName,</span><br><span class="line">            (<span class="keyword">int</span>) (copyWhen - startWhen) / <span class="number">1000</span>,</span><br><span class="line">            (<span class="keyword">int</span>) (endWhen - copyWhen) / <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当Dex文件的优化结束后，将会调用dvmDexFileOpenFromFd函数对该Dex文件进行解析</span></span><br><span class="line">    <span class="keyword">if</span> (dvmDexFileOpenFromFd(optFd, &amp;pDvmDex) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">&quot;Unable to map cached %s&quot;</span>, fileName);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ALOGV(<span class="string">&quot;Successfully opened &#x27;%s&#x27;&quot;</span>, fileName);</span><br><span class="line">    <span class="comment">// 对入口参数ppRawDexFile进行设置，其作用是用于保存当前处理的Dex文件的相关信息</span></span><br><span class="line">    *ppRawDexFile = (RawDexFile*) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(RawDexFile));</span><br><span class="line">    (*ppRawDexFile)-&gt;cacheFileName = cachedName; <span class="comment">// 保存Odex文件名</span></span><br><span class="line">    (*ppRawDexFile)-&gt;pDvmDex = pDvmDex; <span class="comment">// 保存DvmDex数据结构</span></span><br><span class="line">    cachedName = <span class="literal">NULL</span>;      <span class="comment">// don&#x27;t free it below</span></span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dvmRawDexFileOpen()函数完成目标Dex文件优化后，会调用dvmDexFileOpenFromFd()函数完成Dex文件的后续解析工作。<br><strong>代码清单</strong> dalvik/vm/DvmDex.cpp: dvmDexFileOpenFromFd()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dvmDexFileOpenFromFd</span><span class="params">(<span class="keyword">int</span> fd, DvmDex** ppDvmDex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明函数执行过程中所用到的中间变量</span></span><br><span class="line">    DvmDex* pDvmDex; <span class="comment">// 用于在虚拟机中描述解析的Dex文件</span></span><br><span class="line">    DexFile* pDexFile;</span><br><span class="line">    MemMapping memMap;</span><br><span class="line">    <span class="keyword">int</span> parseFlags = kDexParseDefault;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 验证Dex文件校验和</span></span><br><span class="line">    <span class="keyword">if</span> (gDvm.verifyDexChecksum)</span><br><span class="line">        parseFlags |= kDexParseVerifyChecksum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lseek(fd, <span class="number">0</span>, SEEK_SET) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;lseek rewind failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对目标Dex文件进行映射，并将其设置为只读文件</span></span><br><span class="line">    <span class="keyword">if</span> (sysMapFileInShmemWritableReadOnly(fd, &amp;memMap) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Unable to map file&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Dex文件解析的关键，dexFileParse函数对Dex文件解析，并返回一个DexFile数据结构的实例对象</span></span><br><span class="line">    pDexFile = dexFileParse((u1*)memMap.addr, memMap.length, parseFlags);</span><br><span class="line">    <span class="keyword">if</span> (pDexFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;DEX parse failed&quot;</span>);</span><br><span class="line">        sysReleaseShmem(&amp;memMap);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// allocateAuxStructures函数根据pDexFile对DvmDex数据结构的一些成员变量进行设置。</span></span><br><span class="line">    pDvmDex = allocateAuxStructures(pDexFile);</span><br><span class="line">    <span class="keyword">if</span> (pDvmDex == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dexFileFree(pDexFile);</span><br><span class="line">        sysReleaseShmem(&amp;memMap);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* tuck this into the DexFile so it gets released later */</span></span><br><span class="line">    sysCopyMap(&amp;pDvmDex-&gt;memMap, &amp;memMap);</span><br><span class="line">    pDvmDex-&gt;isMappedReadOnly = <span class="literal">true</span>;</span><br><span class="line">    *ppDvmDex = pDvmDex;</span><br><span class="line">    result = <span class="number">0</span>; <span class="comment">// 0表示成功</span></span><br><span class="line"></span><br><span class="line">bail:</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dvmDexFileOpenFromFd()函数首先对已经优化的Dex文件进行正确性检验，随后调用dexFileParse()函数将目标文件进行解析，目标是将Dex文件与DexFile结构体建立关联。<br><strong>代码清单</strong> dalvik/libdex/DexFile.cpp: dexFileParse()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DexFile* <span class="title">dexFileParse</span><span class="params">(<span class="keyword">const</span> u1* data, <span class="keyword">size_t</span> length, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DexFile* pDexFile = <span class="literal">NULL</span>;   <span class="comment">// 结构体指针，用于保存和返回解析结果</span></span><br><span class="line">    <span class="keyword">const</span> DexHeader* pHeader;   <span class="comment">// 保存Dex文件头部信息</span></span><br><span class="line">    <span class="keyword">const</span> u1* magic;            <span class="comment">// 用于保存Dex文件的魔数</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// Dex文件长度不能小于其文件头的长度</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="keyword">sizeof</span>(DexHeader)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;too short to be a valid .dex&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;      <span class="comment">/* bad file format */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pDexFile = (DexFile*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DexFile));</span><br><span class="line">    <span class="keyword">if</span> (pDexFile == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> bail;      <span class="comment">/* alloc failure */</span></span><br><span class="line">    <span class="built_in">memset</span>(pDexFile, <span class="number">0</span>, <span class="keyword">sizeof</span>(DexFile));</span><br><span class="line">    <span class="comment">// 对目标文件的magic进行验证，确定其为一个优化的Dex文件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(data, DEX_OPT_MAGIC, <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        magic = data;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">memcmp</span>(magic+<span class="number">4</span>, DEX_OPT_MAGIC_VERS, <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;bad opt version (0x%02x %02x %02x %02x)&quot;</span>,</span><br><span class="line">                 magic[<span class="number">4</span>], magic[<span class="number">5</span>], magic[<span class="number">6</span>], magic[<span class="number">7</span>]);</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将优化文件头部与DexFile数据结构的pOptHeader成员变量关联</span></span><br><span class="line">        pDexFile-&gt;pOptHeader = (<span class="keyword">const</span> DexOptHeader*) data;</span><br><span class="line">        ALOGV(<span class="string">&quot;Good opt header, DEX offset is %d, flags=0x%02x&quot;</span>,</span><br><span class="line">            pDexFile-&gt;pOptHeader-&gt;dexOffset, pDexFile-&gt;pOptHeader-&gt;flags);</span><br><span class="line">        <span class="comment">// 对优化数据进行处理，将各个优化数据与DexFile数据结构中的相应成员变量进行关联</span></span><br><span class="line">        <span class="keyword">if</span> (!dexParseOptData(data, length, pDexFile))</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line">        <span class="comment">// 用data变量记录当前文件所分析到的位置，length记录还有多少内容没分析</span></span><br><span class="line">        data += pDexFile-&gt;pOptHeader-&gt;dexOffset;</span><br><span class="line">        length -= pDexFile-&gt;pOptHeader-&gt;dexOffset;</span><br><span class="line">        <span class="keyword">if</span> (pDexFile-&gt;pOptHeader-&gt;dexLength &gt; length) &#123;</span><br><span class="line">	        ALOGE(<span class="string">&quot;File truncated? stored len=%d, rem len=%d&quot;</span>,</span><br><span class="line">                pDexFile-&gt;pOptHeader-&gt;dexLength, (<span class="keyword">int</span>) length);</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line">        &#125;</span><br><span class="line">        length = pDexFile-&gt;pOptHeader-&gt;dexLength;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从data所标示的位置将Dex文件中其他各部分数据与DexFile数据结构建立完整的映射关系</span></span><br><span class="line">    dexFileSetupBasicPointers(pDexFile, data);</span><br><span class="line">    pHeader = pDexFile-&gt;pHeader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dexHasValidMagic(pHeader)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 验证Dex文件校验和</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; kDexParseVerifyChecksum) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 验证SHA-1值</span></span><br><span class="line">    <span class="keyword">if</span> (kVerifySignature) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> pDexFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随着dexFileParse函数结束，Dex文件的解析也告一段落，类加载机制接下来的工作就是根据虚拟机的运行需要，从Dex文件中加载指定类，并将其装入虚拟机的运行时环境中。</p>
<h2 id="运行时环境数据加载"><a href="#运行时环境数据加载" class="headerlink" title="运行时环境数据加载"></a>运行时环境数据加载</h2><h3 id="ClassObject数据结构"><a href="#ClassObject数据结构" class="headerlink" title="ClassObject数据结构"></a>ClassObject数据结构</h3><p>类加载的最终目标就是为目标类生成一个ClassObject的实例对象，并将其存储在运行时环境中，随时被执行模块引用执行。<br><strong>代码清单</strong> dalvik/vm/oo/Object.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ClassObject</span> :</span> Object &#123;</span><br><span class="line">    u4           instanceData[CLASS_FIELD_SLOTS];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>*  descriptor;          <span class="comment">// 类描述符</span></span><br><span class="line">    <span class="keyword">char</span>*        descriptorAlloc;</span><br><span class="line">    u4           accessFlags;         <span class="comment">// 访问标志符</span></span><br><span class="line">    u4           serialNumber;        <span class="comment">// 虚拟机独有的类序列号</span></span><br><span class="line">    DvmDex*      pDvmDex;             <span class="comment">// 指向所属Dex文件</span></span><br><span class="line">    ClassStatus  status;              <span class="comment">// 类初始化状态</span></span><br><span class="line">    ClassObject* verifyErrorClass;    <span class="comment">// 错误处理</span></span><br><span class="line">    u4           initThreadId;        <span class="comment">// 初始化进程ID</span></span><br><span class="line">    <span class="keyword">size_t</span>       objectSize;          <span class="comment">// 总共的object数</span></span><br><span class="line">    ClassObject* elementClass;        <span class="comment">// 元素类</span></span><br><span class="line">    <span class="keyword">int</span>          arrayDim;            <span class="comment">// 数组维数</span></span><br><span class="line">    PrimitiveType primitiveType;      <span class="comment">// 原始类型索引</span></span><br><span class="line">    ClassObject* super;               <span class="comment">// 指向超类</span></span><br><span class="line">    Object*      classLoader;         <span class="comment">// 类装载器</span></span><br><span class="line">    InitiatingLoaderList initiatingLoaderList;</span><br><span class="line">    <span class="comment">/* 这个类中直接实现的接口的数组 */</span></span><br><span class="line">    <span class="keyword">int</span>          interfaceCount;</span><br><span class="line">    ClassObject** interfaces;</span><br><span class="line">    <span class="comment">/* 直接方法 */</span></span><br><span class="line">    <span class="keyword">int</span>          directMethodCount;</span><br><span class="line">    Method*      directMethods;</span><br><span class="line">    <span class="comment">/* 这个类中定义的虚方法，通过vtable调用 */</span></span><br><span class="line">    <span class="keyword">int</span>          virtualMethodCount;</span><br><span class="line">    Method*      virtualMethods;</span><br><span class="line">    <span class="comment">/* 虚方法表 */</span></span><br><span class="line">    <span class="keyword">int</span>          vtableCount;</span><br><span class="line">    Method**     vtable;</span><br><span class="line">    <span class="comment">/* interface table */</span></span><br><span class="line">    <span class="keyword">int</span>             iftableCount;</span><br><span class="line">    InterfaceEntry* iftable;</span><br><span class="line">    <span class="comment">/* 常量池 */</span></span><br><span class="line">    <span class="keyword">int</span>          ifviPoolCount;</span><br><span class="line">    <span class="keyword">int</span>*         ifviPool;</span><br><span class="line">    <span class="comment">/* 实例字段 */</span></span><br><span class="line">    <span class="keyword">int</span>          ifieldCount;</span><br><span class="line">    <span class="keyword">int</span>          ifieldRefCount;</span><br><span class="line">    InstField*   ifields;</span><br><span class="line">    </span><br><span class="line">    u4           refOffsets;        <span class="comment">// 字段区偏移量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>*  sourceFile;        <span class="comment">// 源文件名</span></span><br><span class="line">    <span class="comment">/* 静态字段 */</span></span><br><span class="line">    <span class="keyword">int</span>          sfieldCount;</span><br><span class="line">    StaticField  sfields[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类加载整体流程"><a href="#类加载整体流程" class="headerlink" title="类加载整体流程"></a>类加载整体流程</h3><ul>
<li>获取描述Dex文件的DexFile结构体对象</li>
<li>根据目标类属性选择相应的加载模式</li>
<li>在DexFile数据结构中获取目标类数据在Dex文件中的分布信息</li>
<li>将类数据信息传给实际加载函数</li>
</ul>
<h3 id="函数执行流程-2"><a href="#函数执行流程-2" class="headerlink" title="函数执行流程"></a>函数执行流程</h3><p><code>dalvik/vm/native/dalvik_system_DexFile.cpp</code>中的Dalvik_dalvik_System_DexFile_defineClassNative为这一阶段的主控函数。<br>Dalvik_dalvik_system_DexFile_defineClassNative-&gt;dvmGetRawDexFileDex-&gt;dvmDefineClass-&gt;findClassNoInit完成实际的加载工作。<br><strong>代码清单</strong> dalvik/vm/oo/Class.cpp: findClassNoInit()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ClassObject* <span class="title">findClassNoInit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* descriptor, Object* loader,</span></span></span><br><span class="line"><span class="function"><span class="params">    DvmDex* pDvmDex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Thread* self = dvmThreadSelf();</span><br><span class="line">    ClassObject* clazz; <span class="comment">// 类加载的最终形式</span></span><br><span class="line">    <span class="keyword">bool</span> profilerNotified = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/* 判断目标类是否有类加载器，对于系统类，虚拟机将从默认的启动路径实现其加载工作</span></span><br><span class="line"><span class="comment">    对于用户类，虚拟机一般情况下使用默认的类加载器实现类加载工作 */</span></span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LOGVV(<span class="string">&quot;#### findClassNoInit(%s,%p,%p)&quot;</span>, descriptor, loader,</span><br><span class="line">            pDvmDex-&gt;pDexFile);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">/* 根据目标类的描述符从hash表(系统已加载类)里查找是否已经有该Class的信息，如果已经加载，则返回</span></span><br><span class="line"><span class="comment">    其ClassObject对象，否则，对目标类进行加载*/</span></span><br><span class="line">    clazz = dvmLookupClass(descriptor, loader, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> DexClassDef* pClassDef;</span><br><span class="line"></span><br><span class="line">        dvmMethodTraceClassPrepBegin();</span><br><span class="line">        profilerNotified = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LOG_CLASS_LOADING</span></span><br><span class="line">        u8 startTime = dvmGetThreadCpuTimeNsec();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">/* 判断是否存在DvmDex结构体对象，如果存在，则表示目标类为一个用户类，将从一个解析的Dex文件</span></span><br><span class="line"><span class="comment">        中进行加载，对于一个解析过的Dex文件，是一定存在一个DvmDex结构体对象的，故pDvmDex一定不为空</span></span><br><span class="line"><span class="comment">        若为空，则表示目标类是一个系统类，虚拟机将调用searchBootPathForClass函数从启动路径下查找并</span></span><br><span class="line"><span class="comment">        加载目标类 */</span></span><br><span class="line">        <span class="keyword">if</span> (pDvmDex == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            assert(loader == <span class="literal">NULL</span>);     <span class="comment">/* shouldn&#x27;t be here otherwise */</span></span><br><span class="line">            <span class="comment">/* 从BOOTCLASSPATH里那一堆jar包文件中，看看哪个jar包声明了目标类返回的是一个打开了的代</span></span><br><span class="line"><span class="comment">            表odex文件的DvmDex对象 */</span></span><br><span class="line">            pDvmDex = searchBootPathForClass(descriptor, &amp;pClassDef);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 查找目标类的类定义资源</span></span><br><span class="line">            pClassDef = dexFindClass(pDvmDex-&gt;pDexFile, descriptor);</span><br><span class="line">        &#125;</span><br><span class="line">	...</span><br><span class="line">        <span class="comment">/* 当获得了加载目标类所需的各项资源，主函数将调用loadClassFromDex函数对目标类进行加载 */</span></span><br><span class="line">        clazz = loadClassFromDex(pDvmDex, pClassDef, loader);</span><br><span class="line">        <span class="keyword">if</span> (dvmCheckException(self)) &#123;</span><br><span class="line">            <span class="comment">/* class was found but had issues */</span></span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                dvmFreeClassInnards(clazz);</span><br><span class="line">                dvmReleaseTrackedAlloc((Object*) clazz, <span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 将目前使用的类锁住，防止其他进程更改 */</span></span><br><span class="line">        dvmLockObject(self, (Object*) clazz);</span><br><span class="line">        clazz-&gt;initThreadId = self-&gt;threadId;</span><br><span class="line">        </span><br><span class="line">        assert(clazz-&gt;classLoader == loader);</span><br><span class="line">        <span class="keyword">if</span> (!dvmAddClassToHash(clazz)) &#123; <span class="comment">// class对象加到Hash表里</span></span><br><span class="line">	        clazz-&gt;initThreadId = <span class="number">0</span>;</span><br><span class="line">            dvmUnlockObject(self, (Object*) clazz);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Let the GC free the class. */</span></span><br><span class="line">            dvmFreeClassInnards(clazz);</span><br><span class="line">            dvmReleaseTrackedAlloc((Object*) clazz, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">/* 从已加载的类的系统Hash表中重新得到类 */</span></span><br><span class="line">            clazz = dvmLookupClass(descriptor, loader, <span class="literal">true</span>);</span><br><span class="line">            assert(clazz != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">goto</span> got_class;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 准备开始连接类，对clazz进行一些处理：</span></span><br><span class="line"><span class="comment">         * 1.解析ClassObject对象的基类信息，和它实现了那些接口</span></span><br><span class="line"><span class="comment">         * 2.校验：比如父类是final的，那么就不应该有它的派生类等</span></span><br><span class="line"><span class="comment">         * 此函数调用成功后，clazz的状态将是CLASS_RESOLVED或CLASS_VERIFIED</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!dvmLinkClass(clazz)) &#123;</span><br><span class="line">            assert(dvmCheckException(self));</span><br><span class="line">            <span class="comment">/* Make note of the error and clean up the class. */</span></span><br><span class="line">            removeClassFromHash(clazz);</span><br><span class="line">            clazz-&gt;status = CLASS_ERROR;</span><br><span class="line">            dvmFreeClassInnards(clazz);</span><br><span class="line">            <span class="comment">/* Let any waiters know. */</span></span><br><span class="line">            clazz-&gt;initThreadId = <span class="number">0</span>;</span><br><span class="line">            dvmObjectNotifyAll(self, (Object*) clazz);</span><br><span class="line">            dvmUnlockObject(self, (Object*) clazz);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 将类的状态增加到全局变量中去 */</span></span><br><span class="line">        gDvm.numLoadedClasses++;</span><br><span class="line">        gDvm.numDeclaredMethods +=</span><br><span class="line">            clazz-&gt;virtualMethodCount + clazz-&gt;directMethodCount;</span><br><span class="line">        gDvm.numDeclaredInstFields += clazz-&gt;ifieldCount;</span><br><span class="line">        gDvm.numDeclaredStaticFields += clazz-&gt;sfieldCount;</span><br><span class="line">        ...</span><br><span class="line">    <span class="comment">/* check some invariants */</span></span><br><span class="line">    assert(dvmIsClassLinked(clazz));</span><br><span class="line">    assert(gDvm.classJavaLangClass != <span class="literal">NULL</span>);</span><br><span class="line">    assert(clazz-&gt;clazz == gDvm.classJavaLangClass);</span><br><span class="line">    assert(dvmIsClassObject(clazz));</span><br><span class="line">    assert(clazz == gDvm.classJavaLangObject || clazz-&gt;super != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!dvmIsInterfaceClass(clazz)) &#123;</span><br><span class="line">        <span class="comment">//ALOGI(&quot;class=%s vtableCount=%d, virtualMeth=%d&quot;,</span></span><br><span class="line">        <span class="comment">//    clazz-&gt;descriptor, clazz-&gt;vtableCount,</span></span><br><span class="line">        <span class="comment">//    clazz-&gt;virtualMethodCount);</span></span><br><span class="line">        assert(clazz-&gt;vtableCount &gt;= clazz-&gt;virtualMethodCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">bail:</span><br><span class="line">    <span class="keyword">if</span> (profilerNotified)</span><br><span class="line">        dvmMethodTraceClassPrepEnd();</span><br><span class="line">    assert(clazz != <span class="literal">NULL</span> || dvmCheckException(self));</span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用dvmLookupClass函数判断本类是否已经被加载</p>
<ul>
<li>已加载：直接使用，结束函数。</li>
<li>未加载：判断能否找到Dex文件，能找到调用<code>dexFindClass</code>在指定Dex文件中根据类的描述符查找相关类（用户类）；找不到调用<code>searchBootPathForClass</code>从系统启动基本路径中查找并加载目标类（系统类）。调用loadClassFromDex函数实现加载类达到可运行状态。调用dvmAddClassToHash实现将新加载的类添加到哈希表中方便在此查找。</li>
</ul>
<p>findClassNoInit函数将调用<code>loadClassFromDex0</code>函数完成对该类的加载工作，返回值为一个<code>ClassObject</code>结构体对象。loadClassFromDex0函数源代码如下：<br><strong>代码清单</strong> dalvik/vm/oo/Class.cpp: loadClassFromDex0()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ClassObject* <span class="title">loadClassFromDex0</span><span class="params">(DvmDex* pDvmDex,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> DexClassDef* pClassDef, <span class="keyword">const</span> DexClassDataHeader* pHeader,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> u1* pEncodedData, Object* classLoader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ClassObject* newClass = <span class="literal">NULL</span>; <span class="comment">// 目标类的类实例对象</span></span><br><span class="line">    <span class="keyword">const</span> DexFile* pDexFile;      <span class="comment">// 用于存储目标Dex文件所对应的DexFile数据结构实例对象</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* descriptor;       <span class="comment">// 用于存储目标类的描述符</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 获取相应的类信息</span></span><br><span class="line">    pDexFile = pDvmDex-&gt;pDexFile;</span><br><span class="line">    descriptor = dexGetClassDescriptor(pDexFile, pClassDef);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 为即将生成的类对象实例申请内存空间</span></span><br><span class="line">    assert(descriptor != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 判断是不是java.lang.Class类，此类已经初始化过了</span></span><br><span class="line">    <span class="keyword">if</span> (classLoader == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">strcmp</span>(descriptor, <span class="string">&quot;Ljava/lang/Class;&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        assert(gDvm.classJavaLangClass != <span class="literal">NULL</span>);</span><br><span class="line">        newClass = gDvm.classJavaLangClass;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 取得对象实例大小并在内存中申请相应内存</span></span><br><span class="line">        <span class="keyword">size_t</span> size = classObjectSize(pHeader-&gt;staticFieldsSize);</span><br><span class="line">        newClass = (ClassObject*) dvmMalloc(size, ALLOC_NON_MOVING);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newClass == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对新的类对象实例进行初始化</span></span><br><span class="line">    DVM_OBJECT_INIT(newClass, gDvm.classJavaLangClass);</span><br><span class="line">    dvmSetClassSerialNumber(newClass);</span><br><span class="line">    newClass-&gt;descriptor = descriptor;</span><br><span class="line">    assert(newClass-&gt;descriptorAlloc == <span class="literal">NULL</span>);</span><br><span class="line">    SET_CLASS_FLAG(newClass, pClassDef-&gt;accessFlags);</span><br><span class="line">    <span class="comment">// 设定字段对象</span></span><br><span class="line">    dvmSetFieldObject((Object *)newClass,</span><br><span class="line">                      OFFSETOF_MEMBER(ClassObject, classLoader),</span><br><span class="line">                      (Object *)classLoader);</span><br><span class="line">    <span class="comment">// 设定类的相关指针</span></span><br><span class="line">    newClass-&gt;pDvmDex = pDvmDex;</span><br><span class="line">    newClass-&gt;primitiveType = PRIM_NOT;</span><br><span class="line">    newClass-&gt;status = CLASS_IDX;</span><br><span class="line">    <span class="comment">// 将这个类的父类的索引加入到类对象的指针区域</span></span><br><span class="line">    assert(<span class="keyword">sizeof</span>(u4) == <span class="keyword">sizeof</span>(ClassObject*)); <span class="comment">/* 32-bit check */</span></span><br><span class="line">    newClass-&gt;super = (ClassObject*) pClassDef-&gt;superclassIdx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> DexTypeList* pInterfacesList;</span><br><span class="line">    <span class="comment">// 得到接口列表</span></span><br><span class="line">    pInterfacesList = dexGetInterfacesList(pDexFile, pClassDef);</span><br><span class="line">    <span class="keyword">if</span> (pInterfacesList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        newClass-&gt;interfaceCount = pInterfacesList-&gt;size;</span><br><span class="line">        newClass-&gt;interfaces = (ClassObject**) dvmLinearAlloc(classLoader,</span><br><span class="line">                newClass-&gt;interfaceCount * <span class="keyword">sizeof</span>(ClassObject*));</span><br><span class="line">        <span class="comment">// newClass实现了哪些接口类，此处也先以接口类的index存储，后续放到dvmLinkClass来解析</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; newClass-&gt;interfaceCount; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> DexTypeItem* pType = dexGetTypeItem(pInterfacesList, i);</span><br><span class="line">            newClass-&gt;interfaces[i] = (ClassObject*)(u4) pType-&gt;typeIdx;</span><br><span class="line">        &#125;</span><br><span class="line">        dvmLinearReadOnly(classLoader, newClass-&gt;interfaces);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对字段进行加载，首先加载静态字段</span></span><br><span class="line">    <span class="keyword">if</span> (pHeader-&gt;staticFieldsSize != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* static fields stay on system heap; field data isn&#x27;t &quot;write once&quot; */</span></span><br><span class="line">        <span class="keyword">int</span> count = (<span class="keyword">int</span>) pHeader-&gt;staticFieldsSize;</span><br><span class="line">        u4 lastIndex = <span class="number">0</span>;</span><br><span class="line">        DexField field;</span><br><span class="line">        <span class="comment">// 取得字段数</span></span><br><span class="line">        newClass-&gt;sfieldCount = count;</span><br><span class="line">        <span class="comment">// 逐一加载字段</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            dexReadClassDataField(&amp;pEncodedData, &amp;field, &amp;lastIndex);</span><br><span class="line">            <span class="comment">// 解析newClass定义的静态成员信息</span></span><br><span class="line">            loadSFieldFromDex(newClass, &amp;field, &amp;newClass-&gt;sfields[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加载实例字段</span></span><br><span class="line">    <span class="keyword">if</span> (pHeader-&gt;instanceFieldsSize != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = (<span class="keyword">int</span>) pHeader-&gt;instanceFieldsSize;</span><br><span class="line">        u4 lastIndex = <span class="number">0</span>;</span><br><span class="line">        DexField field;</span><br><span class="line">        <span class="comment">// 取得字段数</span></span><br><span class="line">        newClass-&gt;ifieldCount = count;</span><br><span class="line">        newClass-&gt;ifields = (InstField*) dvmLinearAlloc(classLoader,</span><br><span class="line">                count * <span class="keyword">sizeof</span>(InstField));</span><br><span class="line">        <span class="comment">// 逐一加载字段</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            dexReadClassDataField(&amp;pEncodedData, &amp;field, &amp;lastIndex);</span><br><span class="line">            loadIFieldFromDex(newClass, &amp;field, &amp;newClass-&gt;ifields[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dvmLinearReadOnly(classLoader, newClass-&gt;ifields);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对类方法进行加载</span></span><br><span class="line">    <span class="keyword">if</span> (pHeader-&gt;directMethodsSize != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = (<span class="keyword">int</span>) pHeader-&gt;directMethodsSize;</span><br><span class="line">        u4 lastIndex = <span class="number">0</span>;</span><br><span class="line">        DexMethod method;</span><br><span class="line">        <span class="comment">// 取得方法数目</span></span><br><span class="line">        newClass-&gt;directMethodCount = count;</span><br><span class="line">        newClass-&gt;directMethods = (Method*) dvmLinearAlloc(classLoader,</span><br><span class="line">                count * <span class="keyword">sizeof</span>(Method));</span><br><span class="line">        <span class="comment">// 逐一加载方法</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            dexReadClassDataMethod(&amp;pEncodedData, &amp;method, &amp;lastIndex);</span><br><span class="line">            loadMethodFromDex(newClass, &amp;method, &amp;newClass-&gt;directMethods[i]);</span><br><span class="line">            <span class="keyword">if</span> (classMapData != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> RegisterMap* pMap = dvmRegisterMapGetNext(&amp;classMapData);</span><br><span class="line">                <span class="keyword">if</span> (dvmRegisterMapGetFormat(pMap) != kRegMapFormatNone) &#123;</span><br><span class="line">                    newClass-&gt;directMethods[i].registerMap = pMap;</span><br><span class="line">                    <span class="comment">/* <span class="doctag">TODO:</span> add rigorous checks */</span></span><br><span class="line">                    assert((newClass-&gt;directMethods[i].registersSize+<span class="number">7</span>) / <span class="number">8</span> ==</span><br><span class="line">                        newClass-&gt;directMethods[i].registerMap-&gt;regWidth);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dvmLinearReadOnly(classLoader, newClass-&gt;directMethods);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加载虚方法</span></span><br><span class="line">    <span class="keyword">if</span> (pHeader-&gt;virtualMethodsSize != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = (<span class="keyword">int</span>) pHeader-&gt;virtualMethodsSize;</span><br><span class="line">        u4 lastIndex = <span class="number">0</span>;</span><br><span class="line">        DexMethod method;</span><br><span class="line">        <span class="comment">// 取得虚方法数目</span></span><br><span class="line">        newClass-&gt;virtualMethodCount = count;</span><br><span class="line">        newClass-&gt;virtualMethods = (Method*) dvmLinearAlloc(classLoader,</span><br><span class="line">                count * <span class="keyword">sizeof</span>(Method));</span><br><span class="line">        <span class="comment">// 逐一处理方法</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            dexReadClassDataMethod(&amp;pEncodedData, &amp;method, &amp;lastIndex);</span><br><span class="line">            loadMethodFromDex(newClass, &amp;method, &amp;newClass-&gt;virtualMethods[i]);</span><br><span class="line">            <span class="keyword">if</span> (classMapData != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> RegisterMap* pMap = dvmRegisterMapGetNext(&amp;classMapData);</span><br><span class="line">                <span class="keyword">if</span> (dvmRegisterMapGetFormat(pMap) != kRegMapFormatNone) &#123;</span><br><span class="line">                    newClass-&gt;virtualMethods[i].registerMap = pMap;</span><br><span class="line">                    <span class="comment">/* <span class="doctag">TODO:</span> add rigorous checks */</span></span><br><span class="line">                    assert((newClass-&gt;virtualMethods[i].registersSize+<span class="number">7</span>) / <span class="number">8</span> ==</span><br><span class="line">                        newClass-&gt;virtualMethods[i].registerMap-&gt;regWidth);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dvmLinearReadOnly(classLoader, newClass-&gt;virtualMethods);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存源文件信息</span></span><br><span class="line">    newClass-&gt;sourceFile = dexGetSourceFile(pDexFile, pClassDef);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* caller must call dvmReleaseTrackedAlloc */</span></span><br><span class="line">    <span class="keyword">return</span> newClass; <span class="comment">// 返回类对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依次完成：1.在内存中为类对象申请存储空间；2.设置字段信息；3.为超类建立索引；4.加载类接口；5.加载类字段；6.加载类方法，并将以上数据封装成一个ClassObject结构体对象并返回。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2016/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3glibc-malloc/" rel="prev" title="深入理解glibc malloc">
      <i class="fa fa-chevron-left"></i> 深入理解glibc malloc
    </a></div>
      <div class="post-nav-item">
    <a href="/2016/04/19/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" rel="next" title="Java反射机制">
      Java反射机制 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">1.</span> <span class="nav-text">类加载机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">工作流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dex%E6%96%87%E4%BB%B6%E7%9A%84%E4%BC%98%E5%8C%96%E4%B8%8E%E9%AA%8C%E8%AF%81"><span class="nav-number">3.</span> <span class="nav-text">Dex文件的优化与验证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Odex%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><span class="nav-number">3.1.</span> <span class="nav-text">Odex文件结构分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">3.2.</span> <span class="nav-text">函数执行流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dex%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">Dex文件的解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DexFile%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.</span> <span class="nav-text">DexFile数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dex%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="nav-number">4.2.</span> <span class="nav-text">Dex文件解析流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-1"><span class="nav-number">4.3.</span> <span class="nav-text">函数执行流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD"><span class="nav-number">5.</span> <span class="nav-text">运行时环境数据加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ClassObject%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">5.1.</span> <span class="nav-text">ClassObject数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="nav-number">5.2.</span> <span class="nav-text">类加载整体流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-2"><span class="nav-number">5.3.</span> <span class="nav-text">函数执行流程</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bruce Fan"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Bruce Fan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">131</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bruce Fan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
