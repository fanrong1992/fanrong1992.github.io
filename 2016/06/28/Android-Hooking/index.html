<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="ptrace on Android无论是hook还是调试都离不开ptrace这个system call，ptrace可以跟踪目标进程，并且在目标进程暂停的时候对目标进程的内存进行读写。首先看一下要ptrace的目标程序，用来一直循环输出一句话”Hello, Hooking!”   1234567891011121314151617#include &lt;stdio.h&gt;int count">
<meta property="og:type" content="article">
<meta property="og:title" content="Android Hooking">
<meta property="og:url" content="http://example.com/2016/06/28/Android-Hooking/index.html">
<meta property="og:site_name" content="BruceFan&#39;s Blog">
<meta property="og:description" content="ptrace on Android无论是hook还是调试都离不开ptrace这个system call，ptrace可以跟踪目标进程，并且在目标进程暂停的时候对目标进程的内存进行读写。首先看一下要ptrace的目标程序，用来一直循环输出一句话”Hello, Hooking!”   1234567891011121314151617#include &lt;stdio.h&gt;int count">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/images/androidhook/syscall_trace.png">
<meta property="og:image" content="http://example.com/images/androidhook/targetFunc.png">
<meta property="og:image" content="http://example.com/images/androidhook/window.png">
<meta property="article:published_time" content="2016-06-28T01:36:13.000Z">
<meta property="article:modified_time" content="2020-11-12T02:26:14.666Z">
<meta property="article:author" content="Bruce Fan">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/androidhook/syscall_trace.png">

<link rel="canonical" href="http://example.com/2016/06/28/Android-Hooking/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>Android Hooking | BruceFan's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">BruceFan's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry, stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/06/28/Android-Hooking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bruce Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BruceFan's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android Hooking
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建于：2016-06-28 09:36:13" itemprop="dateCreated datePublished" datetime="2016-06-28T09:36:13+08:00">2016-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="更新于：2020-11-12 10:26:14" itemprop="dateModified" datetime="2020-11-12T10:26:14+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="ptrace-on-Android"><a href="#ptrace-on-Android" class="headerlink" title="ptrace on Android"></a>ptrace on Android</h3><p>无论是hook还是调试都离不开ptrace这个system call，ptrace可以跟踪目标进程，并且在目标进程暂停的时候对目标进程的内存进行读写。<br>首先看一下要ptrace的目标程序，用来一直循环输出一句话”Hello, Hooking!”  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">targetFunc</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">&quot;Hello, Hooking!&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, str, number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        targetFunc(count);</span><br><span class="line">        count++;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要编译它需要先建立一个Android.mk文件，内容如下，让ndk将文件编译为elf可执行文件：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">LOCAL_MODULE := target</span><br><span class="line">LOCAL_SRC_FILES := target.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_EXECUTABLE)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>只有设置Android SDK&lt;=9编译出的elf文件才是executable的，否则编译出的是shared object（即使是include的BUILD_EXECUTABLE）。</p>
</blockquote>
<p>接下来写出hook1.c程序来hook target程序的system call，main函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;pid to be traced&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    pid = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != ptrace(PTRACE_ATTACH, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Trace process failed:%d.\n&quot;</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ptrace(PTRACE_SYSCALL, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">        hookSysCallBefore(pid);</span><br><span class="line">        ptrace(PTARCE_SYSCALL, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        wait(&amp;status);</span><br><span class="line">        hookSysCallAfter(pid);</span><br><span class="line">        ptrace(PTRACE_SYSCALL, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ptrace(PTRACE_DETACH, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先要知道hook目标进程的pid，用ps命令获取。然后使用<code>ptrace(PTRACE_ATTACH, pid, NULL, NULL)</code>这个函数对目标进程进行加载。加载成功后，我们可以使用<code>ptrace(PTRACE_SYSCALL, pid, NULL, NULL)</code>这个函数来对目标程序下断点，每当目标程序调用system call前的时候，就会暂停下来。然后可以读取寄存器的值来获取system call的各项信息。再一次使用<code>ptrace(PTRACE_SYSCALL, pid, NULL, NULL)</code>这个函数就可以让system call在调用完成后再一次暂停下来，并获取system call的返回值。<br>获取system call编号的函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getSysCallNo</span><span class="params">(<span class="keyword">int</span> pid, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> scno = <span class="number">0</span>;</span><br><span class="line">    scno = ptrace(PTRACE_PEEKTEXT, pid, (<span class="keyword">void</span> *)(regs-&gt;ARM_pc - <span class="number">4</span>), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (scno = <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (scno == <span class="number">0xef000000</span>) &#123;</span><br><span class="line">        scno = regs-&gt;ARM_r7;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((scno &amp; <span class="number">0x0ff00000</span>) != <span class="number">0x0f900000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        scno &amp;= <span class="number">0x000fffff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ARM架构上，所有的系统调用都是通过SWI来实现的。并且在ARM架构中有两个SWI指令，分别针对EABI和OABI：</p>
<blockquote>
<p>[EABI]<br>机器码： 1110 1111 0000 0000 – SWI 0<br>具体的调用号存放在寄存器r7中。<br>[OABI]<br>机器码： 1101 1111 vvvv vvvv – SWI immed_8<br>调用号进行转换后得到指令中的立即数。立即数=调用号 | 0x900000</p>
</blockquote>
<p>需要兼容两种方法的调用，在代码上就要分开处理。首先要获取SWI指令判断是EABI还是OABI，如果是EABI，可从r7中获取调用号。如果是OABI，则从SWI指令中获取立即数，反向计算出调用号。<br>接着看hook system call前的函数，和hook system call后的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hookSysCallBefore</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">regs</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sysCallNo = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    sysCallNo = getSysCallNo(pid, &amp;regs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before SysCallNo = %d\n&quot;</span>, sysCallNo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sysCallNo == __NR_write) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;__NR_write: %ld %p %ld\n&quot;</span>, regs.ARM_r0, (<span class="keyword">void</span>*)regs.ARM_r1, regs.ARM_r2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hookSysCallAfter</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">regs</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sysCallNo = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    sysCallNo = getSysCallNo(pid, &amp;regs);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After SysCallNo = %d\n&quot;</span>, sysCallNo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sysCallNo == __NR_write) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;__NR_write return: %ld\n&quot;</span>, regs.ARM_r0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在获取了system call的调用号后，可以进一步获取各个参数的值，比如说wirte这个system call有三个参数。在arm上，如果形参个数少于或等于4，则形参由<code>R0</code>，<code>R1</code>，<code>R2</code>，<code>R3</code>四个寄存器传递。大于四个则通过栈传递。函数的返回值保存在<code>R0</code>中。<br>把target和hook1 push到/data/local/tmp目录下，再chmod 777，接着运行target：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;target</span><br><span class="line">Hello, Hooking! 0</span><br><span class="line">Hello, Hooking! 1</span><br><span class="line">Hello, Hooking! 2</span><br><span class="line">Hello, Hooking! 3</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>再开一个shell，<code>ps</code>获取target的pid，使用hook1程序对target进行hook操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;hook1 27190</span><br><span class="line">Before SysCallNo &#x3D; 0</span><br><span class="line">After SysCallNo &#x3D; 0</span><br><span class="line"></span><br><span class="line">Before SysCallNo &#x3D; 4</span><br><span class="line">__NR_write: 1 0x4f5020 20</span><br><span class="line">After SysCallNo &#x3D; 4</span><br><span class="line">__NR_write return: 20</span><br><span class="line"></span><br><span class="line">Before SysCallNo &#x3D; 162</span><br><span class="line">After SysCallNo &#x3D; 162</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>syscall No 162是<code>sleep</code>函数，syscall No 4是<code>write</code>函数，因为printf本质就是调用write这个系统调用。对write函数参数的解析：1是stdout即标准输出，0x4f5020是字符串地址，20表示字符串长度。返回值20是write成功写入的长度。<br>整个过程的图示：<br><img src="/images/androidhook/syscall_trace.png"></p>
<h3 id="利用ptrace动态修改内存"><a href="#利用ptrace动态修改内存" class="headerlink" title="利用ptrace动态修改内存"></a>利用ptrace动态修改内存</h3><p>下面演示用ptrace进行内存读写，将write()输出的string进行翻转。<br>在hook1.c的基础上继续进行修改，在hookSysCallBefore()函数中加入modifyString(pid, regs.ARM_r1, regs.ARM_r2)这个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sysCallNo == __NR_write) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;__NR_write: %ld %p %ld\n&quot;</span>, regs.ARM_r0, (<span class="keyword">void</span> *)regs.ARM_r1, regs.ARM_r2);</span><br><span class="line">    modifyString(pid, regs.ARM_r1, regs.ARM_r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把write的第二个参数字符串地址<code>r1</code>和第三个参数字符串长度<code>r2</code>传递给<code>modifyString()</code>这个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyString</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">long</span> addr, <span class="keyword">long</span> <span class="built_in">strlen</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    str = (<span class="keyword">char</span> *)<span class="built_in">calloc</span>((<span class="built_in">strlen</span>+<span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>), <span class="number">1</span>);</span><br><span class="line">    getdata(pid, addr, str, <span class="built_in">strlen</span>);</span><br><span class="line">    reverse(str);</span><br><span class="line">    putdata(pid, addr, str, <span class="built_in">strlen</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>modifyString()</code>首先获取在内存中的字符串，然后进行翻转操作，最后把翻转后的字符串写入原来的地址。这些操作用到了getdata()和putdata()函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdata</span><span class="params">(<span class="keyword">pid_t</span> child, <span class="keyword">long</span> addr, <span class="keyword">char</span> *str, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *laddr;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">u</span> &#123;</span></span><br><span class="line">        <span class="keyword">long</span> val;</span><br><span class="line">        <span class="keyword">char</span> chars[long_size];</span><br><span class="line">    &#125; data;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = len / long_size;</span><br><span class="line">    laddr = str;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        data.val = ptrace(PTRACE_PEEKDATA, child, addr+i*<span class="number">4</span>, <span class="literal">NULL</span>); <span class="comment">// ptrace的内存操作一次只能控制4个字节</span></span><br><span class="line">        <span class="built_in">memcpy</span>(laddr, data.chars, long_size);</span><br><span class="line">        ++i;</span><br><span class="line">        laddr += long_size;</span><br><span class="line">    &#125;</span><br><span class="line">    j = len % long_size;</span><br><span class="line">    <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">        data.val = ptrace(PTRACE_PEEKDATA, child, addr+i*<span class="number">4</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(laddr, data.chars, j);</span><br><span class="line">    &#125;</span><br><span class="line">    str[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putdata</span><span class="params">(<span class="keyword">pid_t</span> child, <span class="keyword">long</span> addr, <span class="keyword">char</span> *str, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *laddr;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">u</span> &#123;</span></span><br><span class="line">        <span class="keyword">long</span> val;</span><br><span class="line">        <span class="keyword">char</span> chars[long_size];</span><br><span class="line">    &#125; data;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = len / long_size;</span><br><span class="line">    laddr = str;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(data.chars, laddr, long_size);</span><br><span class="line">        ptrace(PTRACE_POKEDATA, child, addr+i*<span class="number">4</span>, data.val);</span><br><span class="line">        ++i;</span><br><span class="line">        laddr += long_size;</span><br><span class="line">    &#125;</span><br><span class="line">    j = len % long_size;</span><br><span class="line">    <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(data.chars, laddr, j);</span><br><span class="line">        ptrace(PTRACE_POKEDATA, child, addr+i*<span class="number">4</span>, data.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getdata()</code>和<code>putdata()</code>分别使用<code>PTRACE_PEEKDATA</code>和<code>PTRACE_POKEDATA</code>对内存进行读写操作。因为ptrace的内存操作一次只能控制4个字节，所以如果修改比较长的内容需要进行多次操作。<br>现在运行target，并且在运行中用hook2进行hook：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;target</span><br><span class="line">Hello, Hooking! 0</span><br><span class="line">Hello, Hooking! 1</span><br><span class="line">Hello, Hooking! 2</span><br><span class="line">Hello, Hooking! 3</span><br><span class="line">Hello, Hooking! 4</span><br><span class="line">Hello, Hooking! 5</span><br><span class="line">Hello, Hooking! 6</span><br><span class="line">Hello, Hooking! 7</span><br><span class="line">Hello, Hooking! 8</span><br><span class="line">Hello, Hooking! 9</span><br><span class="line">01 !gnikooH ,olleH</span><br><span class="line">11 !gnikooH ,olleH</span><br><span class="line">21 !gnikooH ,olleH</span><br><span class="line">31 !gnikooH ,olleH</span><br><span class="line">41 !gnikooH ,olleH</span><br><span class="line">51 !gnikooH ,olleH</span><br><span class="line">Hello, Hooking! 16</span><br><span class="line">Hello, Hooking! 17</span><br><span class="line">Hello, Hooking! 18</span><br><span class="line">Hello, Hooking! 19</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>运行hook2后字符串被翻转，退出hook2字符串回到原顺序。</p>
<h3 id="利用ptrace动态执行sleep-函数"><a href="#利用ptrace动态执行sleep-函数" class="headerlink" title="利用ptrace动态执行sleep()函数"></a>利用ptrace动态执行sleep()函数</h3><p>下面利用ptrace来执行libc.so中的sleep()函数，主要逻辑如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">old_regs</span>, <span class="title">regs</span>;</span></span><br><span class="line">    <span class="keyword">long</span> sleep_addr;</span><br><span class="line">    <span class="comment">// save old regs</span></span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;old_regs);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;regs, &amp;old_regs, <span class="keyword">sizeof</span>(regs));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getting remote sleep_addr:\n&quot;</span>);</span><br><span class="line">    sleep_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)sleep);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> parameters[<span class="number">1</span>];</span><br><span class="line">    parameters[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    ptrace_call(pid, sleep_addr, parameters, <span class="number">1</span>, &amp;regs);</span><br><span class="line">    <span class="comment">// restore old regs</span></span><br><span class="line">    ptrace(PTRACE_SETREGS, pid, <span class="literal">NULL</span>, &amp;old_regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们用<code>ptrace(PTRACE_GETREGS, pid, NULL, &amp;old_regs)</code>获取当前寄存器的值，以便最后恢复数据。然后获取sleep()函数在目标进程中的地址，接着利用ptrace执行sleep()函数。<br>下面是获取sleep()函数在目标进程中地址的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">get_module_base</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">const</span> <span class="keyword">char</span> *module_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> addr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *pch;</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">32</span>], line[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;/proc/self/maps&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;/proc/%d/maps&quot;</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    fp = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (fgets(line, <span class="keyword">sizeof</span>(line), fp)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, module_name)) &#123;</span><br><span class="line">                pch = strtok(line, <span class="string">&quot;-&quot;</span>);</span><br><span class="line">                addr = strtoul(pch, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">                <span class="keyword">if</span> (addr == <span class="number">0x8000</span>) <span class="comment">// 如果被加载的文件是executable而不是so，则不需要加上基址</span></span><br><span class="line">                    addr = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">get_remote_addr</span><span class="params">(<span class="keyword">pid_t</span> target_pid, <span class="keyword">const</span> <span class="keyword">char</span> *module_name, <span class="keyword">void</span> *local_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *local_handle, *remote_handle;</span><br><span class="line">    local_handle = get_module_base(<span class="number">0</span>, module_name);</span><br><span class="line">    remote_handle = get_module_base(target_pid, module_name);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;module_base: local[%p], remote[%p]\n&quot;</span>, local_handle, remote_handle);</span><br><span class="line">    <span class="comment">// 本进程函数地址减去本进程libc地址等于该函数在libc的偏移，再加上负载进程的libc基址即负载进程中函数地址</span></span><br><span class="line">    <span class="keyword">long</span> ret_addr = (<span class="keyword">long</span>)((<span class="keyword">uint32_t</span>)local_addr - (<span class="keyword">uint32_t</span>)local_handle + (<span class="keyword">uint32_t</span>)remote_handle);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;remote_addr: [%p]\n&quot;</span>, (<span class="keyword">void</span> *)ret_addr);</span><br><span class="line">    <span class="keyword">return</span> ret_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为libc.so在内存中的地址是随机的，所以要先获取目标进程的libc.so的加载地址，再获取本进程的libc.so的加载地址和sleep()在内存中的地址。然后我们就能计算出sleep()函数在目标进程中的地址了。要注意的是获取目标进程和本进程的libc.so的加载地址是通过解析<code>/proc/[pid]/maps</code>得到的。<br>接下来执行sleep()函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_call</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">long</span> addr, <span class="keyword">long</span> *params, <span class="keyword">uint32_t</span> num_params, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    <span class="comment">// 将参数赋给R0-R3</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_params &amp;&amp; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        regs-&gt;uregs[i] = params[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数大于四个，将参数放在栈上</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; num_params) &#123;</span><br><span class="line">        regs-&gt;ARM_sp -= (num_params - i) * long_size;</span><br><span class="line">        putdata(pid, (<span class="keyword">long</span>)regs-&gt;ARM_sp, (<span class="keyword">char</span> *)&amp;params[i], (num_params - i) * long_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    regs-&gt;ARM_pc = addr;</span><br><span class="line">    <span class="keyword">if</span> (regs-&gt;ARM_pc &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* thumb */</span></span><br><span class="line">        regs-&gt;ARM_pc &amp;= (~<span class="number">1u</span>);</span><br><span class="line">        regs-&gt;ARM_cpsr |= CPSR_T_MASK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* arm */</span></span><br><span class="line">        regs-&gt;ARM_cpsr &amp;= ~CPSR_T_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    regs-&gt;ARM_lr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ptrace_setregs(pid, regs) == <span class="number">-1</span> || ptrace_continue(pid) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> stat = <span class="number">0</span>;</span><br><span class="line">    waitpid(pid, &amp;stat, WUNTRACED);</span><br><span class="line">    <span class="keyword">while</span> (stat != <span class="number">0xb7f</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptrace_continue(pid) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        waitpid(pid, &amp;stat, WUNTRACED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是将参数赋值给R0-R3，如果参数大于四个的话，再使用putdata()将参数存放在栈上。然后我们将PC的值设置为函数地址。接着再根据是否是thumb指令设置ARM_cpsr寄存器的值。随后我们使用ptrace_setregs()将目标进程寄存器的值进行修改。最后使用waitpid()等待函数被执行。</p>
<h3 id="利用ptrace动态加载so并执行自定义函数"><a href="#利用ptrace动态加载so并执行自定义函数" class="headerlink" title="利用ptrace动态加载so并执行自定义函数"></a>利用ptrace动态加载so并执行自定义函数</h3><p>逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">保存当前寄存器的状态</span><br><span class="line">获取目标程序的mmap, dlopen, dlsym, dlclose地址</span><br><span class="line">调用mmap分配一段内存空间来保存参数信息</span><br><span class="line">调用dlopen加载so文件</span><br><span class="line">调用dlsym找到目标函数地址</span><br><span class="line">使用ptrace_call执行目标函数</span><br><span class="line">调用dlclose卸载so文件</span><br><span class="line">恢复寄存器的状态</span><br></pre></td></tr></table></figure>
<p>实现整个逻辑的函数injectSo()的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">injectSo</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">char</span> *so_path, <span class="keyword">char</span> *function_name, <span class="keyword">char</span> *parameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">old_regs</span>, <span class="title">regs</span>;</span></span><br><span class="line">    <span class="keyword">long</span> mmap_addr, dlopen_addr, dlsym_addr, dlclose_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save old regs</span></span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;old_regs);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;regs, &amp;old_regs, <span class="keyword">sizeof</span>(regs));</span><br><span class="line">    <span class="comment">// get remote address</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getting remote address:\n&quot;</span>);</span><br><span class="line">    mmap_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)mmap);</span><br><span class="line">    dlopen_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)dlopen);</span><br><span class="line">    dlsym_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)dlsym);</span><br><span class="line">    dlclose_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)dlclose);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmap_addr = %p dlopen_addr=%p dlsym_addr=%p dlclose_addr=%p\n&quot;</span>,</span><br><span class="line">            (<span class="keyword">void</span> *)mmap_addr, (<span class="keyword">void</span> *)dlopen_addr, (<span class="keyword">void</span> *)dlsym_addr, (<span class="keyword">void</span> *)dlclose_addr);</span><br><span class="line">    <span class="keyword">long</span> parameters[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mmap</span></span><br><span class="line">    parameters[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// address</span></span><br><span class="line">    parameters[<span class="number">1</span>] = <span class="number">0x4000</span>; <span class="comment">// size</span></span><br><span class="line">    parameters[<span class="number">2</span>] = PROT_READ | PROT_WRITE | PROT_EXEC; <span class="comment">// WRX</span></span><br><span class="line">    parameters[<span class="number">3</span>] = MAP_ANONYMOUS | MAP_PRIVATE; <span class="comment">// flag</span></span><br><span class="line">    parameters[<span class="number">4</span>] = <span class="number">0</span>; <span class="comment">// fd</span></span><br><span class="line">    parameters[<span class="number">5</span>] = <span class="number">0</span>; <span class="comment">// offset</span></span><br><span class="line"></span><br><span class="line">    ptrace_call(pid, mmap_addr, parameters, <span class="number">6</span>, &amp;regs);</span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    <span class="keyword">long</span> map_base = regs.ARM_r0; <span class="comment">// 返回映射区的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;map_base = %p\n&quot;</span>, (<span class="keyword">void</span> *)map_base);</span><br><span class="line">    <span class="comment">// dlopen</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;save os_path = %s to map_base %p\n&quot;</span>, so_path, (<span class="keyword">void</span> *)map_base);</span><br><span class="line">    putdata(pid, map_base, so_path, <span class="built_in">strlen</span>(so_path)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    parameters[<span class="number">0</span>] = map_base;</span><br><span class="line">    parameters[<span class="number">1</span>] = RTLD_NOW | RTLD_GLOBAL;</span><br><span class="line">    ptrace_call(pid, dlopen_addr, parameters, <span class="number">2</span>, &amp;regs);</span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    <span class="keyword">long</span> handle = regs.ARM_r0;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handle = %p\n&quot;</span>, (<span class="keyword">void</span> *)handle);</span><br><span class="line">    <span class="comment">// dlsym</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;save function_name = %s to map_base = %p\n&quot;</span>, function_name, (<span class="keyword">void</span> *)map_base);</span><br><span class="line">    putdata(pid, map_base, function_name, <span class="built_in">strlen</span>(function_name) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    parameters[<span class="number">0</span>] = handle;</span><br><span class="line">    parameters[<span class="number">1</span>] = map_base;</span><br><span class="line">    ptrace_call(pid, dlsym_addr, parameters, <span class="number">2</span>, &amp;regs);</span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    <span class="keyword">long</span> function_ptr = regs.ARM_r0;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function_ptr = %p\n&quot;</span>, (<span class="keyword">void</span> *)function_ptr);</span><br><span class="line">    <span class="comment">// function_call</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;save parameter = %s to map_base = %p\n&quot;</span>, parameter, (<span class="keyword">void</span> *)map_base);</span><br><span class="line">    putdata(pid, map_base, parameter, <span class="built_in">strlen</span>(parameter)+<span class="number">1</span>); <span class="comment">//此处的parameter是通过参数传递进来的</span></span><br><span class="line"></span><br><span class="line">    parameters[<span class="number">0</span>] = map_base;</span><br><span class="line"></span><br><span class="line">    ptrace_call(pid, function_ptr, parameters, <span class="number">1</span>, &amp;regs);</span><br><span class="line">    <span class="comment">// dlclose</span></span><br><span class="line">    parameters[<span class="number">0</span>] = handle;</span><br><span class="line">    ptrace_call(pid, dlclose_addr, parameters, <span class="number">1</span>, &amp;regs);</span><br><span class="line">    <span class="comment">// restore old regs</span></span><br><span class="line">    ptrace(PTRACE_SETREGS, pid, <span class="literal">NULL</span>, &amp;old_regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mmap()可以用来将一个文件或者其它对象映射进内存，如果我们把flag设置为MAP_ANONYMOUS并且把参数fd设置为0的话就相当于直接映射一段内容为空的内存。mmap()的函数声明和参数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>start：映射区的开始地址，设置为0时表示由系统决定映射区的起始地址。<br>length：映射区的长度。<br>prot：期望的内存保护标志，不能与文件的打开模式冲突。这里设置为RWX。<br>flags：指定映射对象的类型，映射选项和映射页是否可以共享。我们这里设置为：MAP_ANONYMOUS(匿名映射，映射区不与任何文件关联)，MAP_PRIVATE(建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件)。<br>fd：有效的文件描述词。匿名映射设置为0。<br>offset：被映射对象内容的起点。设置为0。</p>
</blockquote>
<p><code>mmap()</code>映射的内存主要用来保存传递给其他函数的参数。比如接下来我们需要用dlopen()去加载”/data/local/tmp/libinject.so”这个文件，所以需要先用<code>putdata()</code>将字符串”/data/local/tmp/libinject.so”放置在mmap()所映射的内存中，再将映射地址作为参数传递给dlopen()。接下来的dlsym()，so中的目标函数，dlclose()都是相同的调用方式。<br>被加载的so文件内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">injectedFunc</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;injected function pid = %d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello %s\n&quot;</span>, str);</span><br><span class="line">    LOGD(<span class="string">&quot;injected function pid = %d\n&quot;</span>, getpid());</span><br><span class="line">    LOGD(<span class="string">&quot;Hello %s\n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里不光使用printf()还使用了android debug的函数LOGD()用来输出调试结果。所以在编译时我们需要加上<code>LOCAL_LDLIBS := -llog</code>。<br>编译完后使用hook4对target进行注入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;target</span><br><span class="line">Hello, Hooking! 0</span><br><span class="line">Hello, Hooking! 1</span><br><span class="line">Hello, Hooking! 2</span><br><span class="line">Hello, Hooking! 3</span><br><span class="line">injected function pid &#x3D; 13574</span><br><span class="line">Hello Android hooking</span><br><span class="line">Hello, Hooking! 4</span><br><span class="line">Hello, Hooking! 5</span><br><span class="line">Hello, Hooking! 6</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;hook4 13574</span><br><span class="line">getting remote address:</span><br><span class="line">module_base: local[0xb6f7c000], remote[0xb6ec0000]</span><br><span class="line">remote_addr: [0xb6ed2c5d]</span><br><span class="line">module_base: local[0xb6f7c000], remote[0xb6ec0000]</span><br><span class="line">remote_addr: [0xb6f22f31]</span><br><span class="line">module_base: local[0xb6f7c000], remote[0xb6ec0000]</span><br><span class="line">remote_addr: [0xb6f22e81]</span><br><span class="line">module_base: local[0xb6f7c000], remote[0xb6ec0000]</span><br><span class="line">remote_addr: [0xb6f22dfd]</span><br><span class="line">mmap_addr &#x3D; 0xb6ed2c5d dlopen_addr&#x3D;0xb6f22f31 dlsym_addr&#x3D;0xb6f22e81 dlclose_addr&#x3D;0xb6f22dfd</span><br><span class="line">map_base &#x3D; 0xb6e82000</span><br><span class="line">save os_path &#x3D; &#x2F;data&#x2F;local&#x2F;tmp&#x2F;libinject.so to map_base 0xb6e82000</span><br><span class="line">handle &#x3D; 0xb6f1f494</span><br><span class="line">save function_name &#x3D; injectedFunc to map_base &#x3D; 0xb6e82000</span><br><span class="line">function_ptr &#x3D; 0xb6e7cc61</span><br><span class="line">save parameter &#x3D; Android hooking to map_base &#x3D; 0xb6e82000</span><br></pre></td></tr></table></figure>
<p>可以看到stdout和logcat都成功输出了调试信息。这意味着可以通过注入让目标进程加载so文件并执行任意代码了。</p>
<h3 id="利用函数挂钩实现native层的hook"><a href="#利用函数挂钩实现native层的hook" class="headerlink" title="利用函数挂钩实现native层的hook"></a>利用函数挂钩实现native层的hook</h3><p>这一节要实现用函数挂钩hook目标函数，函数挂钩的基本原理是先用mprotect()将原代码段改成可读可写可执行，然后修改原函数的入口处的代码，让pc指针跳转到动态加载的so文件中的hook函数中，执行完hook函数以后再让pc指针跳转回原本的函数中。<br>用来注入的程序hook5逻辑与hook4相比并没有太大变化，仅仅少了”调用dlclose卸载so文件”这一个步骤，因为要执行的hook后的函数在so中，所以不需要卸载，步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">保存当前寄存器的状态</span><br><span class="line">获取目标程序的mmap, dlopen, dlsym地址</span><br><span class="line">调用mmap分配一段内存空间用来保存参数信息</span><br><span class="line">调用dlopen加载so文件</span><br><span class="line">调用dlsym找到目标函数地址</span><br><span class="line">使用ptrace_call执行目标函数</span><br><span class="line">恢复寄存器的状态</span><br></pre></td></tr></table></figure>
<p>hook5的主要代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">injectSo</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">char</span> *so_path, <span class="keyword">char</span> *function_name,<span class="keyword">char</span> *parameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">old_regs</span>,<span class="title">regs</span>;</span></span><br><span class="line">    <span class="keyword">long</span> mmap_addr, dlopen_addr, dlsym_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save old regs</span></span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;old_regs);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;regs, &amp;old_regs, <span class="keyword">sizeof</span>(regs));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get remote address</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getting remote addres:\n&quot;</span>);</span><br><span class="line">    mmap_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)mmap);</span><br><span class="line">    dlopen_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)dlopen);</span><br><span class="line">    dlsym_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)dlsym);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmap_addr=%p dlopen_addr=%p dlsym_addr=%p\n&quot;</span>,</span><br><span class="line">    (<span class="keyword">void</span>*)mmap_addr,(<span class="keyword">void</span>*)dlopen_addr,(<span class="keyword">void</span>*)dlsym_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> parameters[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mmap</span></span><br><span class="line">    parameters[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// address</span></span><br><span class="line">    parameters[<span class="number">1</span>] = <span class="number">0x4000</span>; <span class="comment">// size</span></span><br><span class="line">    parameters[<span class="number">2</span>] = PROT_READ | PROT_WRITE | PROT_EXEC; <span class="comment">// WRX</span></span><br><span class="line">    parameters[<span class="number">3</span>] = MAP_ANONYMOUS | MAP_PRIVATE; <span class="comment">// flag</span></span><br><span class="line">    parameters[<span class="number">4</span>] = <span class="number">0</span>; <span class="comment">// fd</span></span><br><span class="line">    parameters[<span class="number">5</span>] = <span class="number">0</span>; <span class="comment">// offset</span></span><br><span class="line">    </span><br><span class="line">    ptrace_call(pid, mmap_addr, parameters, <span class="number">6</span>, &amp;regs);</span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> map_base = regs.ARM_r0;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;map_base = %p\n&quot;</span>, (<span class="keyword">void</span>*)map_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dlopen</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;save so_path = %s to map_base = %p\n&quot;</span>, so_path, (<span class="keyword">void</span>*)map_base);</span><br><span class="line">    putdata(pid, map_base, so_path, <span class="built_in">strlen</span>(so_path) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    parameters[<span class="number">0</span>] = map_base;</span><br><span class="line">    parameters[<span class="number">1</span>] = RTLD_NOW| RTLD_GLOBAL;</span><br><span class="line"></span><br><span class="line">    ptrace_call(pid, dlopen_addr, parameters, <span class="number">2</span>, &amp;regs);</span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> handle = regs.ARM_r0;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handle = %p\n&quot;</span>,(<span class="keyword">void</span>*) handle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dlsym</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;save function_name = %s to map_base = %p\n&quot;</span>, function_name, (<span class="keyword">void</span>*)map_base);</span><br><span class="line">    putdata(pid, map_base, function_name, <span class="built_in">strlen</span>(function_name) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    parameters[<span class="number">0</span>] = handle;</span><br><span class="line">    parameters[<span class="number">1</span>] = map_base;</span><br><span class="line"></span><br><span class="line">    ptrace_call(pid, dlsym_addr, parameters, <span class="number">2</span>, &amp;regs);</span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> function_ptr = regs.ARM_r0;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function_ptr = %p\n&quot;</span>, (<span class="keyword">void</span>*)function_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// function_call</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;save parameter = %s to map_base = %p\n&quot;</span>, parameter, (<span class="keyword">void</span>*)map_base);</span><br><span class="line">    putdata(pid, map_base, parameter, <span class="built_in">strlen</span>(parameter) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    parameters[<span class="number">0</span>] = map_base;</span><br><span class="line"></span><br><span class="line">    ptrace_call(pid, function_ptr, parameters, <span class="number">1</span>, &amp;regs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore old regs</span></span><br><span class="line">    ptrace(PTRACE_SETREGS, pid, <span class="literal">NULL</span>, &amp;old_regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>arm处理器支持两种指令集，一种是arm指令集，另一种是thumb指令集。所以要hook的函数可能是被编译成arm指令集的，也有可能是被编译成thumb指令集的。需要注意的是thumb指令的长度是不固定的，但arm指令是固定的32位长度。<br>为了更容易地理解hook的原理，先只考虑arm指令集，因为arm相比thumb要简单一点，不需要考虑指令长度的问题。所以我们需要将target和hook的so编译成arm指令集的形式。很简单，只要在Android.mk中的文件名后面加上”.arm”即可 (真正的文件不用加)。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">LOCAL_MODULE    := target</span><br><span class="line">LOCAL_SRC_FILES := target.c.arm</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_EXECUTABLE)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">LOCAL_MODULE    := inject2</span><br><span class="line">LOCAL_SRC_FILES := inject2.c.arm</span><br><span class="line">LOCAL_LDLIBS := -llog </span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span></span><br></pre></td></tr></table></figure>
<p>确定了指令集以后，来看实现挂钩最重要的逻辑，这个逻辑是在注入的so里实现的。首先我们需要一个结构体保存汇编代码和hook地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hook_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> jump[<span class="number">3</span>]; <span class="comment">// 保存跳转指令</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> store[<span class="number">3</span>]; <span class="comment">// 保存原指令</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> orig; <span class="comment">// 保存原函数地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> patch; <span class="comment">// 保存hook函数地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接着来看注入的逻辑，最重要的函数为hook_direct()，他有三个参数，1）最开始定义的用来保存汇编代码和hook地址的结构体，2）要hook的原函数的地址，3）用来执行的hook函数地址。函数的源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hook_direct</span><span class="params">(struct <span class="keyword">hook_t</span> *h, <span class="keyword">unsigned</span> <span class="keyword">int</span> addr, <span class="keyword">void</span> *hookf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr  = %x\n&quot;</span>, addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hookf = %x\n&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)hookf);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将代码段改成可读可写可执行</span></span><br><span class="line">    mprotect((<span class="keyword">void</span>*)<span class="number">0x8000</span>, <span class="number">0xa000</span><span class="number">-0x8000</span>, PROT_READ|PROT_WRITE|PROT_EXEC);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// modify function entry </span></span><br><span class="line">    h-&gt;patch = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)hookf; <span class="comment">// hook函数地址</span></span><br><span class="line">    h-&gt;orig = addr; <span class="comment">// 原函数地址</span></span><br><span class="line">    h-&gt;jump[<span class="number">0</span>] = <span class="number">0xe59ff000</span>; <span class="comment">// 把目标函数第一条指令改成 LDR pc, [pc, #0];跳转到PC指针所指的地址</span></span><br><span class="line">    h-&gt;jump[<span class="number">1</span>] = h-&gt;patch; <span class="comment">// 由于pc寄存器读出的值实际上是当前指令地址加8，所以我们把后面两处指令</span></span><br><span class="line">    h-&gt;jump[<span class="number">2</span>] = h-&gt;patch; <span class="comment">// 都保存为hook函数的地址，这样的话，我们就能控制PC跳转到hook函数的地址了。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="comment">// 保存原函数的前三条指令</span></span><br><span class="line">        h-&gt;store[i] = ((<span class="keyword">int</span>*)h-&gt;orig)[i];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="comment">// 将函数入口指令改成跳转指令</span></span><br><span class="line">        ((<span class="keyword">int</span>*)h-&gt;orig)[i] = h-&gt;jump[i];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 刷新指令的缓存。因为虽然前面的操作修改了内存中的指令，但有可能被修改的指令已经被缓存起来了   </span></span><br><span class="line">    hook_cacheflush((<span class="keyword">unsigned</span> <span class="keyword">int</span>)h-&gt;orig, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)h-&gt;orig + <span class="keyword">sizeof</span>(h-&gt;jump));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然android有ASLR，但并没有PIE，所以program image是固定在0x8000这个地址的，因此我们用mprotect()函数将整个target代码段变成RWX，这样我们就能修改函数入口处的代码了。是否修改成功可以通过cat /proc/[pid]/maps查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F; # cat &#x2F;proc&#x2F;18029&#x2F;maps</span><br><span class="line">00008000-0000a000 rwxp 00000000 b3:1c 671749     &#x2F;data&#x2F;local&#x2F;tmp&#x2F;target</span><br><span class="line">0000a000-0000b000 r--p 00001000 b3:1c 671749     &#x2F;data&#x2F;local&#x2F;tmp&#x2F;target</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>然后需要确定目标函数的地址，这个有两种方法。1）如果目标程序本身没有被strip的话，那些symbol都是存在的，因此可以使用dlopen()和dlsym()等方法来获取目标函数地址。但很多情况，目标程序都会被strip，特别是可以直接运行的二进制文件默认都会被直接strip。比如target中的targetFunc()这个函数名会在编译的时候去掉，所以使用dlsym()的话是无法找到这个函数的。2）这时候我们就需要使用IDA或者objdump来定位一下目标函数的地址。比如用IDA找一下target程序里面targetFunc(int number)这个函数的地址：<br><img src="/images/androidhook/targetFunc.png"><br>虽然target这个binary被strip了，但还是可以找到targetFunc()这个函数的起始地址是在0x84c4。一般ARM程序在IDA中打开后，自定义的函数都在<code>Functions window</code>的前几个：<br><img src="/images/androidhook/window.png"><br>最后一个参数也就是我们要执行的hook函数的地址。得到这个地址非常简单，因为是so中的函数，调用hook_direct()的时候直接写上函数名即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hook_direct(&amp;eph, hookaddr, hookFunc);</span><br></pre></td></tr></table></figure>
<p>hook_cacheflush()代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">inline</span> <span class="title">hook_cacheflush</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> begin, <span class="keyword">unsigned</span> <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> syscall = <span class="number">0xf0002</span>;</span><br><span class="line"> </span><br><span class="line">    __asm __volatile (</span><br><span class="line">        <span class="string">&quot;mov     r0, %0\n&quot;</span>         </span><br><span class="line">        <span class="string">&quot;mov     r1, %1\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov     r7, %2\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov     r2, #0x0\n&quot;</span></span><br><span class="line">        <span class="string">&quot;svc     0x00000000\n&quot;</span></span><br><span class="line">        :</span><br><span class="line">        :   <span class="string">&quot;r&quot;</span> (begin), <span class="string">&quot;r&quot;</span> (end), <span class="string">&quot;r&quot;</span> (syscall)</span><br><span class="line">        :   <span class="string">&quot;r0&quot;</span>, <span class="string">&quot;r1&quot;</span>, <span class="string">&quot;r7&quot;</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刷新完缓存后，再执行到原函数的时候，pc指针就会跳转到自定义的hook函数中了，hook函数里的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>  __attribute__ ((noinline)) hookFunc(<span class="keyword">int</span> number)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;targetFunc() called, number = %d\n&quot;</span>, number);</span><br><span class="line">    number *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*orig_targetFunc)(<span class="keyword">int</span> number);</span><br><span class="line">    orig_targetFunc = (<span class="keyword">void</span> *)eph.orig;</span><br><span class="line">    </span><br><span class="line">    hook_precall(&amp;eph);</span><br><span class="line">    orig_targetFunc(number);</span><br><span class="line">    hook_postcall(&amp;eph);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先在hook函数中，可以获得原函数的参数（参数已经在寄存器中了，编写hook函数的时候，参数与原函数相同即可），并且可以对原函数的参数进行修改，比如说将数字乘2。随后使用<code>hook_precall(&amp;eph);</code>将原本函数的内容进行还原。hook_precall()内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hook_precall</span><span class="params">(struct <span class="keyword">hook_t</span> *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        ((<span class="keyword">int</span>*)h-&gt;orig)[i] = h-&gt;store[i];</span><br><span class="line"> </span><br><span class="line">    hook_cacheflush((<span class="keyword">unsigned</span> <span class="keyword">int</span>)h-&gt;orig, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)h-&gt;orig+<span class="keyword">sizeof</span>(h-&gt;jump)*<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在hook_precall()中，先对原本的三条指令进行还原，然后使用hook_cacheflush()对内存进行刷新。经过处理之后，就可以执行原来的函数orig_targetFunc(number)了。执行完后，如果还想再次hook这个函数，就需要调用hook_postcall(&amp;eph)将原本的三条指令再进行一次修改。<br>下面用hook5和libinject2.so来注入以下target这个程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;target</span><br><span class="line">Hello, Hooking! 0</span><br><span class="line">Hello, Hooking! 1</span><br><span class="line">Hello, Hooking! 2</span><br><span class="line">Hello, Hooking! 3</span><br><span class="line">Hello, Hooking! 4</span><br><span class="line">Hello, Hooking! 5</span><br><span class="line">Hello, Hooking! 6</span><br><span class="line">Hook Function pid &#x3D; 18561</span><br><span class="line">Hello HookFunction</span><br><span class="line">addr  &#x3D; 84c4</span><br><span class="line">hookf &#x3D; b6ea3da5</span><br><span class="line">targetFunc() called, number &#x3D; 7</span><br><span class="line">Hello, Hooking! 14</span><br><span class="line">targetFunc() called, number &#x3D; 8</span><br><span class="line">Hello, Hooking! 16</span><br><span class="line">targetFunc() called, number &#x3D; 9</span><br><span class="line">Hello, Hooking! 18</span><br><span class="line">targetFunc() called, number &#x3D; 10</span><br><span class="line">Hello, Hooking! 20</span><br><span class="line">targetFunc() called, number &#x3D; 11</span><br><span class="line">Hello, Hooking! 22</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;hook5 18561</span><br><span class="line">getting remote addres:</span><br><span class="line">mmap_addr&#x3D;0xb6ef9c5d dlopen_addr&#x3D;0xb6f49f31 dlsym_addr&#x3D;0xb6f49e81</span><br><span class="line">map_base &#x3D; 0xb6ea9000</span><br><span class="line">save so_path &#x3D; &#x2F;data&#x2F;local&#x2F;tmp&#x2F;libinject2.so to map_base &#x3D; 0xb6ea9000</span><br><span class="line">handle &#x3D; 0xb6f46494</span><br><span class="line">save function_name &#x3D; hookEntry to map_base &#x3D; 0xb6ea9000</span><br><span class="line">function_ptr &#x3D; 0xb6ea3e3d</span><br><span class="line">save parameter &#x3D; HookFunction to map_base &#x3D; 0xb6ea9000</span><br></pre></td></tr></table></figure>
<p><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://drops.wooyun.org/tips/9300">http://drops.wooyun.org/tips/9300</a><br><a target="_blank" rel="noopener" href="http://drops.wooyun.org/papers/10156">http://drops.wooyun.org/papers/10156</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2016/06/20/Radare2%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" rel="prev" title="Radare2使用说明">
      <i class="fa fa-chevron-left"></i> Radare2使用说明
    </a></div>
      <div class="post-nav-item">
    <a href="/2016/07/16/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="next" title="基于线程的并发编程">
      基于线程的并发编程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#ptrace-on-Android"><span class="nav-number">1.</span> <span class="nav-text">ptrace on Android</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8ptrace%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%86%85%E5%AD%98"><span class="nav-number">2.</span> <span class="nav-text">利用ptrace动态修改内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8ptrace%E5%8A%A8%E6%80%81%E6%89%A7%E8%A1%8Csleep-%E5%87%BD%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text">利用ptrace动态执行sleep()函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8ptrace%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDso%E5%B9%B6%E6%89%A7%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">利用ptrace动态加载so并执行自定义函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%87%BD%E6%95%B0%E6%8C%82%E9%92%A9%E5%AE%9E%E7%8E%B0native%E5%B1%82%E7%9A%84hook"><span class="nav-number">5.</span> <span class="nav-text">利用函数挂钩实现native层的hook</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bruce Fan"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Bruce Fan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">125</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bruce Fan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
