<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Android Hooking | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="ptrace on Android无论是hook还是调试都离不开ptrace这个system call，ptrace可以跟踪目标进程，并且在目标进程暂停的时候对目标进程的内存进行读写。首先看一下要ptrace的目标程序，用来一直循环输出一句话”Hello, Hooking!”   1234567891011121314151617#include &lt;stdio.h&gt;int count">
<meta property="og:type" content="article">
<meta property="og:title" content="Android Hooking">
<meta property="og:url" content="http://example.com/2016/06/28/Android-Hooking/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="ptrace on Android无论是hook还是调试都离不开ptrace这个system call，ptrace可以跟踪目标进程，并且在目标进程暂停的时候对目标进程的内存进行读写。首先看一下要ptrace的目标程序，用来一直循环输出一句话”Hello, Hooking!”   1234567891011121314151617#include &lt;stdio.h&gt;int count">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/androidhook/syscall_trace.png">
<meta property="og:image" content="http://example.com/images/androidhook/targetFunc.png">
<meta property="og:image" content="http://example.com/images/androidhook/window.png">
<meta property="article:published_time" content="2016-06-28T01:36:13.000Z">
<meta property="article:modified_time" content="2020-11-12T02:26:14.666Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/androidhook/syscall_trace.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Android-Hooking" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/28/Android-Hooking/" class="article-date">
  <time datetime="2016-06-28T01:36:13.000Z" itemprop="datePublished">2016-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android Hooking
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="ptrace-on-Android"><a href="#ptrace-on-Android" class="headerlink" title="ptrace on Android"></a>ptrace on Android</h3><p>无论是hook还是调试都离不开ptrace这个system call，ptrace可以跟踪目标进程，并且在目标进程暂停的时候对目标进程的内存进行读写。<br>首先看一下要ptrace的目标程序，用来一直循环输出一句话”Hello, Hooking!”  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">targetFunc</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">&quot;Hello, Hooking!&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, str, number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        targetFunc(count);</span><br><span class="line">        count++;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要编译它需要先建立一个Android.mk文件，内容如下，让ndk将文件编译为elf可执行文件：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">LOCAL_MODULE := target</span><br><span class="line">LOCAL_SRC_FILES := target.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_EXECUTABLE)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>只有设置Android SDK&lt;=9编译出的elf文件才是executable的，否则编译出的是shared object（即使是include的BUILD_EXECUTABLE）。</p>
</blockquote>
<p>接下来写出hook1.c程序来hook target程序的system call，main函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;pid to be traced&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    pid = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != ptrace(PTRACE_ATTACH, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Trace process failed:%d.\n&quot;</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ptrace(PTRACE_SYSCALL, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">        hookSysCallBefore(pid);</span><br><span class="line">        ptrace(PTARCE_SYSCALL, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        wait(&amp;status);</span><br><span class="line">        hookSysCallAfter(pid);</span><br><span class="line">        ptrace(PTRACE_SYSCALL, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ptrace(PTRACE_DETACH, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先要知道hook目标进程的pid，用ps命令获取。然后使用<code>ptrace(PTRACE_ATTACH, pid, NULL, NULL)</code>这个函数对目标进程进行加载。加载成功后，我们可以使用<code>ptrace(PTRACE_SYSCALL, pid, NULL, NULL)</code>这个函数来对目标程序下断点，每当目标程序调用system call前的时候，就会暂停下来。然后可以读取寄存器的值来获取system call的各项信息。再一次使用<code>ptrace(PTRACE_SYSCALL, pid, NULL, NULL)</code>这个函数就可以让system call在调用完成后再一次暂停下来，并获取system call的返回值。<br>获取system call编号的函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getSysCallNo</span><span class="params">(<span class="keyword">int</span> pid, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> scno = <span class="number">0</span>;</span><br><span class="line">    scno = ptrace(PTRACE_PEEKTEXT, pid, (<span class="keyword">void</span> *)(regs-&gt;ARM_pc - <span class="number">4</span>), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (scno = <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (scno == <span class="number">0xef000000</span>) &#123;</span><br><span class="line">        scno = regs-&gt;ARM_r7;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((scno &amp; <span class="number">0x0ff00000</span>) != <span class="number">0x0f900000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        scno &amp;= <span class="number">0x000fffff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ARM架构上，所有的系统调用都是通过SWI来实现的。并且在ARM架构中有两个SWI指令，分别针对EABI和OABI：</p>
<blockquote>
<p>[EABI]<br>机器码： 1110 1111 0000 0000 – SWI 0<br>具体的调用号存放在寄存器r7中。<br>[OABI]<br>机器码： 1101 1111 vvvv vvvv – SWI immed_8<br>调用号进行转换后得到指令中的立即数。立即数=调用号 | 0x900000</p>
</blockquote>
<p>需要兼容两种方法的调用，在代码上就要分开处理。首先要获取SWI指令判断是EABI还是OABI，如果是EABI，可从r7中获取调用号。如果是OABI，则从SWI指令中获取立即数，反向计算出调用号。<br>接着看hook system call前的函数，和hook system call后的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hookSysCallBefore</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">regs</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sysCallNo = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    sysCallNo = getSysCallNo(pid, &amp;regs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before SysCallNo = %d\n&quot;</span>, sysCallNo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sysCallNo == __NR_write) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;__NR_write: %ld %p %ld\n&quot;</span>, regs.ARM_r0, (<span class="keyword">void</span>*)regs.ARM_r1, regs.ARM_r2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hookSysCallAfter</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">regs</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sysCallNo = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    sysCallNo = getSysCallNo(pid, &amp;regs);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After SysCallNo = %d\n&quot;</span>, sysCallNo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sysCallNo == __NR_write) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;__NR_write return: %ld\n&quot;</span>, regs.ARM_r0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在获取了system call的调用号后，可以进一步获取各个参数的值，比如说wirte这个system call有三个参数。在arm上，如果形参个数少于或等于4，则形参由<code>R0</code>，<code>R1</code>，<code>R2</code>，<code>R3</code>四个寄存器传递。大于四个则通过栈传递。函数的返回值保存在<code>R0</code>中。<br>把target和hook1 push到/data/local/tmp目录下，再chmod 777，接着运行target：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;target</span><br><span class="line">Hello, Hooking! 0</span><br><span class="line">Hello, Hooking! 1</span><br><span class="line">Hello, Hooking! 2</span><br><span class="line">Hello, Hooking! 3</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>再开一个shell，<code>ps</code>获取target的pid，使用hook1程序对target进行hook操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;hook1 27190</span><br><span class="line">Before SysCallNo &#x3D; 0</span><br><span class="line">After SysCallNo &#x3D; 0</span><br><span class="line"></span><br><span class="line">Before SysCallNo &#x3D; 4</span><br><span class="line">__NR_write: 1 0x4f5020 20</span><br><span class="line">After SysCallNo &#x3D; 4</span><br><span class="line">__NR_write return: 20</span><br><span class="line"></span><br><span class="line">Before SysCallNo &#x3D; 162</span><br><span class="line">After SysCallNo &#x3D; 162</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>syscall No 162是<code>sleep</code>函数，syscall No 4是<code>write</code>函数，因为printf本质就是调用write这个系统调用。对write函数参数的解析：1是stdout即标准输出，0x4f5020是字符串地址，20表示字符串长度。返回值20是write成功写入的长度。<br>整个过程的图示：<br><img src="/images/androidhook/syscall_trace.png"></p>
<h3 id="利用ptrace动态修改内存"><a href="#利用ptrace动态修改内存" class="headerlink" title="利用ptrace动态修改内存"></a>利用ptrace动态修改内存</h3><p>下面演示用ptrace进行内存读写，将write()输出的string进行翻转。<br>在hook1.c的基础上继续进行修改，在hookSysCallBefore()函数中加入modifyString(pid, regs.ARM_r1, regs.ARM_r2)这个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sysCallNo == __NR_write) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;__NR_write: %ld %p %ld\n&quot;</span>, regs.ARM_r0, (<span class="keyword">void</span> *)regs.ARM_r1, regs.ARM_r2);</span><br><span class="line">    modifyString(pid, regs.ARM_r1, regs.ARM_r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把write的第二个参数字符串地址<code>r1</code>和第三个参数字符串长度<code>r2</code>传递给<code>modifyString()</code>这个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyString</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">long</span> addr, <span class="keyword">long</span> <span class="built_in">strlen</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    str = (<span class="keyword">char</span> *)<span class="built_in">calloc</span>((<span class="built_in">strlen</span>+<span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>), <span class="number">1</span>);</span><br><span class="line">    getdata(pid, addr, str, <span class="built_in">strlen</span>);</span><br><span class="line">    reverse(str);</span><br><span class="line">    putdata(pid, addr, str, <span class="built_in">strlen</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>modifyString()</code>首先获取在内存中的字符串，然后进行翻转操作，最后把翻转后的字符串写入原来的地址。这些操作用到了getdata()和putdata()函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdata</span><span class="params">(<span class="keyword">pid_t</span> child, <span class="keyword">long</span> addr, <span class="keyword">char</span> *str, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *laddr;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">u</span> &#123;</span></span><br><span class="line">        <span class="keyword">long</span> val;</span><br><span class="line">        <span class="keyword">char</span> chars[long_size];</span><br><span class="line">    &#125; data;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = len / long_size;</span><br><span class="line">    laddr = str;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        data.val = ptrace(PTRACE_PEEKDATA, child, addr+i*<span class="number">4</span>, <span class="literal">NULL</span>); <span class="comment">// ptrace的内存操作一次只能控制4个字节</span></span><br><span class="line">        <span class="built_in">memcpy</span>(laddr, data.chars, long_size);</span><br><span class="line">        ++i;</span><br><span class="line">        laddr += long_size;</span><br><span class="line">    &#125;</span><br><span class="line">    j = len % long_size;</span><br><span class="line">    <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">        data.val = ptrace(PTRACE_PEEKDATA, child, addr+i*<span class="number">4</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(laddr, data.chars, j);</span><br><span class="line">    &#125;</span><br><span class="line">    str[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putdata</span><span class="params">(<span class="keyword">pid_t</span> child, <span class="keyword">long</span> addr, <span class="keyword">char</span> *str, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *laddr;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">u</span> &#123;</span></span><br><span class="line">        <span class="keyword">long</span> val;</span><br><span class="line">        <span class="keyword">char</span> chars[long_size];</span><br><span class="line">    &#125; data;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = len / long_size;</span><br><span class="line">    laddr = str;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(data.chars, laddr, long_size);</span><br><span class="line">        ptrace(PTRACE_POKEDATA, child, addr+i*<span class="number">4</span>, data.val);</span><br><span class="line">        ++i;</span><br><span class="line">        laddr += long_size;</span><br><span class="line">    &#125;</span><br><span class="line">    j = len % long_size;</span><br><span class="line">    <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(data.chars, laddr, j);</span><br><span class="line">        ptrace(PTRACE_POKEDATA, child, addr+i*<span class="number">4</span>, data.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getdata()</code>和<code>putdata()</code>分别使用<code>PTRACE_PEEKDATA</code>和<code>PTRACE_POKEDATA</code>对内存进行读写操作。因为ptrace的内存操作一次只能控制4个字节，所以如果修改比较长的内容需要进行多次操作。<br>现在运行target，并且在运行中用hook2进行hook：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;target</span><br><span class="line">Hello, Hooking! 0</span><br><span class="line">Hello, Hooking! 1</span><br><span class="line">Hello, Hooking! 2</span><br><span class="line">Hello, Hooking! 3</span><br><span class="line">Hello, Hooking! 4</span><br><span class="line">Hello, Hooking! 5</span><br><span class="line">Hello, Hooking! 6</span><br><span class="line">Hello, Hooking! 7</span><br><span class="line">Hello, Hooking! 8</span><br><span class="line">Hello, Hooking! 9</span><br><span class="line">01 !gnikooH ,olleH</span><br><span class="line">11 !gnikooH ,olleH</span><br><span class="line">21 !gnikooH ,olleH</span><br><span class="line">31 !gnikooH ,olleH</span><br><span class="line">41 !gnikooH ,olleH</span><br><span class="line">51 !gnikooH ,olleH</span><br><span class="line">Hello, Hooking! 16</span><br><span class="line">Hello, Hooking! 17</span><br><span class="line">Hello, Hooking! 18</span><br><span class="line">Hello, Hooking! 19</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>运行hook2后字符串被翻转，退出hook2字符串回到原顺序。</p>
<h3 id="利用ptrace动态执行sleep-函数"><a href="#利用ptrace动态执行sleep-函数" class="headerlink" title="利用ptrace动态执行sleep()函数"></a>利用ptrace动态执行sleep()函数</h3><p>下面利用ptrace来执行libc.so中的sleep()函数，主要逻辑如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">old_regs</span>, <span class="title">regs</span>;</span></span><br><span class="line">    <span class="keyword">long</span> sleep_addr;</span><br><span class="line">    <span class="comment">// save old regs</span></span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;old_regs);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;regs, &amp;old_regs, <span class="keyword">sizeof</span>(regs));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getting remote sleep_addr:\n&quot;</span>);</span><br><span class="line">    sleep_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)sleep);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> parameters[<span class="number">1</span>];</span><br><span class="line">    parameters[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    ptrace_call(pid, sleep_addr, parameters, <span class="number">1</span>, &amp;regs);</span><br><span class="line">    <span class="comment">// restore old regs</span></span><br><span class="line">    ptrace(PTRACE_SETREGS, pid, <span class="literal">NULL</span>, &amp;old_regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们用<code>ptrace(PTRACE_GETREGS, pid, NULL, &amp;old_regs)</code>获取当前寄存器的值，以便最后恢复数据。然后获取sleep()函数在目标进程中的地址，接着利用ptrace执行sleep()函数。<br>下面是获取sleep()函数在目标进程中地址的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">get_module_base</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">const</span> <span class="keyword">char</span> *module_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> addr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *pch;</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">32</span>], line[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;/proc/self/maps&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;/proc/%d/maps&quot;</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    fp = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (fgets(line, <span class="keyword">sizeof</span>(line), fp)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, module_name)) &#123;</span><br><span class="line">                pch = strtok(line, <span class="string">&quot;-&quot;</span>);</span><br><span class="line">                addr = strtoul(pch, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">                <span class="keyword">if</span> (addr == <span class="number">0x8000</span>) <span class="comment">// 如果被加载的文件是executable而不是so，则不需要加上基址</span></span><br><span class="line">                    addr = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">get_remote_addr</span><span class="params">(<span class="keyword">pid_t</span> target_pid, <span class="keyword">const</span> <span class="keyword">char</span> *module_name, <span class="keyword">void</span> *local_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *local_handle, *remote_handle;</span><br><span class="line">    local_handle = get_module_base(<span class="number">0</span>, module_name);</span><br><span class="line">    remote_handle = get_module_base(target_pid, module_name);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;module_base: local[%p], remote[%p]\n&quot;</span>, local_handle, remote_handle);</span><br><span class="line">    <span class="comment">// 本进程函数地址减去本进程libc地址等于该函数在libc的偏移，再加上负载进程的libc基址即负载进程中函数地址</span></span><br><span class="line">    <span class="keyword">long</span> ret_addr = (<span class="keyword">long</span>)((<span class="keyword">uint32_t</span>)local_addr - (<span class="keyword">uint32_t</span>)local_handle + (<span class="keyword">uint32_t</span>)remote_handle);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;remote_addr: [%p]\n&quot;</span>, (<span class="keyword">void</span> *)ret_addr);</span><br><span class="line">    <span class="keyword">return</span> ret_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为libc.so在内存中的地址是随机的，所以要先获取目标进程的libc.so的加载地址，再获取本进程的libc.so的加载地址和sleep()在内存中的地址。然后我们就能计算出sleep()函数在目标进程中的地址了。要注意的是获取目标进程和本进程的libc.so的加载地址是通过解析<code>/proc/[pid]/maps</code>得到的。<br>接下来执行sleep()函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_call</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">long</span> addr, <span class="keyword">long</span> *params, <span class="keyword">uint32_t</span> num_params, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    <span class="comment">// 将参数赋给R0-R3</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_params &amp;&amp; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        regs-&gt;uregs[i] = params[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数大于四个，将参数放在栈上</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; num_params) &#123;</span><br><span class="line">        regs-&gt;ARM_sp -= (num_params - i) * long_size;</span><br><span class="line">        putdata(pid, (<span class="keyword">long</span>)regs-&gt;ARM_sp, (<span class="keyword">char</span> *)&amp;params[i], (num_params - i) * long_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    regs-&gt;ARM_pc = addr;</span><br><span class="line">    <span class="keyword">if</span> (regs-&gt;ARM_pc &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* thumb */</span></span><br><span class="line">        regs-&gt;ARM_pc &amp;= (~<span class="number">1u</span>);</span><br><span class="line">        regs-&gt;ARM_cpsr |= CPSR_T_MASK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* arm */</span></span><br><span class="line">        regs-&gt;ARM_cpsr &amp;= ~CPSR_T_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    regs-&gt;ARM_lr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ptrace_setregs(pid, regs) == <span class="number">-1</span> || ptrace_continue(pid) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> stat = <span class="number">0</span>;</span><br><span class="line">    waitpid(pid, &amp;stat, WUNTRACED);</span><br><span class="line">    <span class="keyword">while</span> (stat != <span class="number">0xb7f</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptrace_continue(pid) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        waitpid(pid, &amp;stat, WUNTRACED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是将参数赋值给R0-R3，如果参数大于四个的话，再使用putdata()将参数存放在栈上。然后我们将PC的值设置为函数地址。接着再根据是否是thumb指令设置ARM_cpsr寄存器的值。随后我们使用ptrace_setregs()将目标进程寄存器的值进行修改。最后使用waitpid()等待函数被执行。</p>
<h3 id="利用ptrace动态加载so并执行自定义函数"><a href="#利用ptrace动态加载so并执行自定义函数" class="headerlink" title="利用ptrace动态加载so并执行自定义函数"></a>利用ptrace动态加载so并执行自定义函数</h3><p>逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">保存当前寄存器的状态</span><br><span class="line">获取目标程序的mmap, dlopen, dlsym, dlclose地址</span><br><span class="line">调用mmap分配一段内存空间来保存参数信息</span><br><span class="line">调用dlopen加载so文件</span><br><span class="line">调用dlsym找到目标函数地址</span><br><span class="line">使用ptrace_call执行目标函数</span><br><span class="line">调用dlclose卸载so文件</span><br><span class="line">恢复寄存器的状态</span><br></pre></td></tr></table></figure>
<p>实现整个逻辑的函数injectSo()的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">injectSo</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">char</span> *so_path, <span class="keyword">char</span> *function_name, <span class="keyword">char</span> *parameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">old_regs</span>, <span class="title">regs</span>;</span></span><br><span class="line">    <span class="keyword">long</span> mmap_addr, dlopen_addr, dlsym_addr, dlclose_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save old regs</span></span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;old_regs);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;regs, &amp;old_regs, <span class="keyword">sizeof</span>(regs));</span><br><span class="line">    <span class="comment">// get remote address</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getting remote address:\n&quot;</span>);</span><br><span class="line">    mmap_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)mmap);</span><br><span class="line">    dlopen_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)dlopen);</span><br><span class="line">    dlsym_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)dlsym);</span><br><span class="line">    dlclose_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)dlclose);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmap_addr = %p dlopen_addr=%p dlsym_addr=%p dlclose_addr=%p\n&quot;</span>,</span><br><span class="line">            (<span class="keyword">void</span> *)mmap_addr, (<span class="keyword">void</span> *)dlopen_addr, (<span class="keyword">void</span> *)dlsym_addr, (<span class="keyword">void</span> *)dlclose_addr);</span><br><span class="line">    <span class="keyword">long</span> parameters[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mmap</span></span><br><span class="line">    parameters[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// address</span></span><br><span class="line">    parameters[<span class="number">1</span>] = <span class="number">0x4000</span>; <span class="comment">// size</span></span><br><span class="line">    parameters[<span class="number">2</span>] = PROT_READ | PROT_WRITE | PROT_EXEC; <span class="comment">// WRX</span></span><br><span class="line">    parameters[<span class="number">3</span>] = MAP_ANONYMOUS | MAP_PRIVATE; <span class="comment">// flag</span></span><br><span class="line">    parameters[<span class="number">4</span>] = <span class="number">0</span>; <span class="comment">// fd</span></span><br><span class="line">    parameters[<span class="number">5</span>] = <span class="number">0</span>; <span class="comment">// offset</span></span><br><span class="line"></span><br><span class="line">    ptrace_call(pid, mmap_addr, parameters, <span class="number">6</span>, &amp;regs);</span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    <span class="keyword">long</span> map_base = regs.ARM_r0; <span class="comment">// 返回映射区的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;map_base = %p\n&quot;</span>, (<span class="keyword">void</span> *)map_base);</span><br><span class="line">    <span class="comment">// dlopen</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;save os_path = %s to map_base %p\n&quot;</span>, so_path, (<span class="keyword">void</span> *)map_base);</span><br><span class="line">    putdata(pid, map_base, so_path, <span class="built_in">strlen</span>(so_path)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    parameters[<span class="number">0</span>] = map_base;</span><br><span class="line">    parameters[<span class="number">1</span>] = RTLD_NOW | RTLD_GLOBAL;</span><br><span class="line">    ptrace_call(pid, dlopen_addr, parameters, <span class="number">2</span>, &amp;regs);</span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    <span class="keyword">long</span> handle = regs.ARM_r0;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handle = %p\n&quot;</span>, (<span class="keyword">void</span> *)handle);</span><br><span class="line">    <span class="comment">// dlsym</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;save function_name = %s to map_base = %p\n&quot;</span>, function_name, (<span class="keyword">void</span> *)map_base);</span><br><span class="line">    putdata(pid, map_base, function_name, <span class="built_in">strlen</span>(function_name) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    parameters[<span class="number">0</span>] = handle;</span><br><span class="line">    parameters[<span class="number">1</span>] = map_base;</span><br><span class="line">    ptrace_call(pid, dlsym_addr, parameters, <span class="number">2</span>, &amp;regs);</span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    <span class="keyword">long</span> function_ptr = regs.ARM_r0;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function_ptr = %p\n&quot;</span>, (<span class="keyword">void</span> *)function_ptr);</span><br><span class="line">    <span class="comment">// function_call</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;save parameter = %s to map_base = %p\n&quot;</span>, parameter, (<span class="keyword">void</span> *)map_base);</span><br><span class="line">    putdata(pid, map_base, parameter, <span class="built_in">strlen</span>(parameter)+<span class="number">1</span>); <span class="comment">//此处的parameter是通过参数传递进来的</span></span><br><span class="line"></span><br><span class="line">    parameters[<span class="number">0</span>] = map_base;</span><br><span class="line"></span><br><span class="line">    ptrace_call(pid, function_ptr, parameters, <span class="number">1</span>, &amp;regs);</span><br><span class="line">    <span class="comment">// dlclose</span></span><br><span class="line">    parameters[<span class="number">0</span>] = handle;</span><br><span class="line">    ptrace_call(pid, dlclose_addr, parameters, <span class="number">1</span>, &amp;regs);</span><br><span class="line">    <span class="comment">// restore old regs</span></span><br><span class="line">    ptrace(PTRACE_SETREGS, pid, <span class="literal">NULL</span>, &amp;old_regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mmap()可以用来将一个文件或者其它对象映射进内存，如果我们把flag设置为MAP_ANONYMOUS并且把参数fd设置为0的话就相当于直接映射一段内容为空的内存。mmap()的函数声明和参数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>start：映射区的开始地址，设置为0时表示由系统决定映射区的起始地址。<br>length：映射区的长度。<br>prot：期望的内存保护标志，不能与文件的打开模式冲突。这里设置为RWX。<br>flags：指定映射对象的类型，映射选项和映射页是否可以共享。我们这里设置为：MAP_ANONYMOUS(匿名映射，映射区不与任何文件关联)，MAP_PRIVATE(建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件)。<br>fd：有效的文件描述词。匿名映射设置为0。<br>offset：被映射对象内容的起点。设置为0。</p>
</blockquote>
<p><code>mmap()</code>映射的内存主要用来保存传递给其他函数的参数。比如接下来我们需要用dlopen()去加载”/data/local/tmp/libinject.so”这个文件，所以需要先用<code>putdata()</code>将字符串”/data/local/tmp/libinject.so”放置在mmap()所映射的内存中，再将映射地址作为参数传递给dlopen()。接下来的dlsym()，so中的目标函数，dlclose()都是相同的调用方式。<br>被加载的so文件内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">injectedFunc</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;injected function pid = %d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello %s\n&quot;</span>, str);</span><br><span class="line">    LOGD(<span class="string">&quot;injected function pid = %d\n&quot;</span>, getpid());</span><br><span class="line">    LOGD(<span class="string">&quot;Hello %s\n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里不光使用printf()还使用了android debug的函数LOGD()用来输出调试结果。所以在编译时我们需要加上<code>LOCAL_LDLIBS := -llog</code>。<br>编译完后使用hook4对target进行注入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;target</span><br><span class="line">Hello, Hooking! 0</span><br><span class="line">Hello, Hooking! 1</span><br><span class="line">Hello, Hooking! 2</span><br><span class="line">Hello, Hooking! 3</span><br><span class="line">injected function pid &#x3D; 13574</span><br><span class="line">Hello Android hooking</span><br><span class="line">Hello, Hooking! 4</span><br><span class="line">Hello, Hooking! 5</span><br><span class="line">Hello, Hooking! 6</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;hook4 13574</span><br><span class="line">getting remote address:</span><br><span class="line">module_base: local[0xb6f7c000], remote[0xb6ec0000]</span><br><span class="line">remote_addr: [0xb6ed2c5d]</span><br><span class="line">module_base: local[0xb6f7c000], remote[0xb6ec0000]</span><br><span class="line">remote_addr: [0xb6f22f31]</span><br><span class="line">module_base: local[0xb6f7c000], remote[0xb6ec0000]</span><br><span class="line">remote_addr: [0xb6f22e81]</span><br><span class="line">module_base: local[0xb6f7c000], remote[0xb6ec0000]</span><br><span class="line">remote_addr: [0xb6f22dfd]</span><br><span class="line">mmap_addr &#x3D; 0xb6ed2c5d dlopen_addr&#x3D;0xb6f22f31 dlsym_addr&#x3D;0xb6f22e81 dlclose_addr&#x3D;0xb6f22dfd</span><br><span class="line">map_base &#x3D; 0xb6e82000</span><br><span class="line">save os_path &#x3D; &#x2F;data&#x2F;local&#x2F;tmp&#x2F;libinject.so to map_base 0xb6e82000</span><br><span class="line">handle &#x3D; 0xb6f1f494</span><br><span class="line">save function_name &#x3D; injectedFunc to map_base &#x3D; 0xb6e82000</span><br><span class="line">function_ptr &#x3D; 0xb6e7cc61</span><br><span class="line">save parameter &#x3D; Android hooking to map_base &#x3D; 0xb6e82000</span><br></pre></td></tr></table></figure>
<p>可以看到stdout和logcat都成功输出了调试信息。这意味着可以通过注入让目标进程加载so文件并执行任意代码了。</p>
<h3 id="利用函数挂钩实现native层的hook"><a href="#利用函数挂钩实现native层的hook" class="headerlink" title="利用函数挂钩实现native层的hook"></a>利用函数挂钩实现native层的hook</h3><p>这一节要实现用函数挂钩hook目标函数，函数挂钩的基本原理是先用mprotect()将原代码段改成可读可写可执行，然后修改原函数的入口处的代码，让pc指针跳转到动态加载的so文件中的hook函数中，执行完hook函数以后再让pc指针跳转回原本的函数中。<br>用来注入的程序hook5逻辑与hook4相比并没有太大变化，仅仅少了”调用dlclose卸载so文件”这一个步骤，因为要执行的hook后的函数在so中，所以不需要卸载，步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">保存当前寄存器的状态</span><br><span class="line">获取目标程序的mmap, dlopen, dlsym地址</span><br><span class="line">调用mmap分配一段内存空间用来保存参数信息</span><br><span class="line">调用dlopen加载so文件</span><br><span class="line">调用dlsym找到目标函数地址</span><br><span class="line">使用ptrace_call执行目标函数</span><br><span class="line">恢复寄存器的状态</span><br></pre></td></tr></table></figure>
<p>hook5的主要代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">injectSo</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">char</span> *so_path, <span class="keyword">char</span> *function_name,<span class="keyword">char</span> *parameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">old_regs</span>,<span class="title">regs</span>;</span></span><br><span class="line">    <span class="keyword">long</span> mmap_addr, dlopen_addr, dlsym_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save old regs</span></span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;old_regs);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;regs, &amp;old_regs, <span class="keyword">sizeof</span>(regs));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get remote address</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getting remote addres:\n&quot;</span>);</span><br><span class="line">    mmap_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)mmap);</span><br><span class="line">    dlopen_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)dlopen);</span><br><span class="line">    dlsym_addr = get_remote_addr(pid, libc_path, (<span class="keyword">void</span> *)dlsym);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmap_addr=%p dlopen_addr=%p dlsym_addr=%p\n&quot;</span>,</span><br><span class="line">    (<span class="keyword">void</span>*)mmap_addr,(<span class="keyword">void</span>*)dlopen_addr,(<span class="keyword">void</span>*)dlsym_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> parameters[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mmap</span></span><br><span class="line">    parameters[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// address</span></span><br><span class="line">    parameters[<span class="number">1</span>] = <span class="number">0x4000</span>; <span class="comment">// size</span></span><br><span class="line">    parameters[<span class="number">2</span>] = PROT_READ | PROT_WRITE | PROT_EXEC; <span class="comment">// WRX</span></span><br><span class="line">    parameters[<span class="number">3</span>] = MAP_ANONYMOUS | MAP_PRIVATE; <span class="comment">// flag</span></span><br><span class="line">    parameters[<span class="number">4</span>] = <span class="number">0</span>; <span class="comment">// fd</span></span><br><span class="line">    parameters[<span class="number">5</span>] = <span class="number">0</span>; <span class="comment">// offset</span></span><br><span class="line">    </span><br><span class="line">    ptrace_call(pid, mmap_addr, parameters, <span class="number">6</span>, &amp;regs);</span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> map_base = regs.ARM_r0;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;map_base = %p\n&quot;</span>, (<span class="keyword">void</span>*)map_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dlopen</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;save so_path = %s to map_base = %p\n&quot;</span>, so_path, (<span class="keyword">void</span>*)map_base);</span><br><span class="line">    putdata(pid, map_base, so_path, <span class="built_in">strlen</span>(so_path) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    parameters[<span class="number">0</span>] = map_base;</span><br><span class="line">    parameters[<span class="number">1</span>] = RTLD_NOW| RTLD_GLOBAL;</span><br><span class="line"></span><br><span class="line">    ptrace_call(pid, dlopen_addr, parameters, <span class="number">2</span>, &amp;regs);</span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> handle = regs.ARM_r0;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handle = %p\n&quot;</span>,(<span class="keyword">void</span>*) handle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dlsym</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;save function_name = %s to map_base = %p\n&quot;</span>, function_name, (<span class="keyword">void</span>*)map_base);</span><br><span class="line">    putdata(pid, map_base, function_name, <span class="built_in">strlen</span>(function_name) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    parameters[<span class="number">0</span>] = handle;</span><br><span class="line">    parameters[<span class="number">1</span>] = map_base;</span><br><span class="line"></span><br><span class="line">    ptrace_call(pid, dlsym_addr, parameters, <span class="number">2</span>, &amp;regs);</span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> function_ptr = regs.ARM_r0;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function_ptr = %p\n&quot;</span>, (<span class="keyword">void</span>*)function_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// function_call</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;save parameter = %s to map_base = %p\n&quot;</span>, parameter, (<span class="keyword">void</span>*)map_base);</span><br><span class="line">    putdata(pid, map_base, parameter, <span class="built_in">strlen</span>(parameter) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    parameters[<span class="number">0</span>] = map_base;</span><br><span class="line"></span><br><span class="line">    ptrace_call(pid, function_ptr, parameters, <span class="number">1</span>, &amp;regs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore old regs</span></span><br><span class="line">    ptrace(PTRACE_SETREGS, pid, <span class="literal">NULL</span>, &amp;old_regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>arm处理器支持两种指令集，一种是arm指令集，另一种是thumb指令集。所以要hook的函数可能是被编译成arm指令集的，也有可能是被编译成thumb指令集的。需要注意的是thumb指令的长度是不固定的，但arm指令是固定的32位长度。<br>为了更容易地理解hook的原理，先只考虑arm指令集，因为arm相比thumb要简单一点，不需要考虑指令长度的问题。所以我们需要将target和hook的so编译成arm指令集的形式。很简单，只要在Android.mk中的文件名后面加上”.arm”即可 (真正的文件不用加)。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">LOCAL_MODULE    := target</span><br><span class="line">LOCAL_SRC_FILES := target.c.arm</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_EXECUTABLE)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">LOCAL_MODULE    := inject2</span><br><span class="line">LOCAL_SRC_FILES := inject2.c.arm</span><br><span class="line">LOCAL_LDLIBS := -llog </span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span></span><br></pre></td></tr></table></figure>
<p>确定了指令集以后，来看实现挂钩最重要的逻辑，这个逻辑是在注入的so里实现的。首先我们需要一个结构体保存汇编代码和hook地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hook_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> jump[<span class="number">3</span>]; <span class="comment">// 保存跳转指令</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> store[<span class="number">3</span>]; <span class="comment">// 保存原指令</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> orig; <span class="comment">// 保存原函数地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> patch; <span class="comment">// 保存hook函数地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接着来看注入的逻辑，最重要的函数为hook_direct()，他有三个参数，1）最开始定义的用来保存汇编代码和hook地址的结构体，2）要hook的原函数的地址，3）用来执行的hook函数地址。函数的源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hook_direct</span><span class="params">(struct <span class="keyword">hook_t</span> *h, <span class="keyword">unsigned</span> <span class="keyword">int</span> addr, <span class="keyword">void</span> *hookf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr  = %x\n&quot;</span>, addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hookf = %x\n&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)hookf);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将代码段改成可读可写可执行</span></span><br><span class="line">    mprotect((<span class="keyword">void</span>*)<span class="number">0x8000</span>, <span class="number">0xa000</span><span class="number">-0x8000</span>, PROT_READ|PROT_WRITE|PROT_EXEC);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// modify function entry </span></span><br><span class="line">    h-&gt;patch = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)hookf; <span class="comment">// hook函数地址</span></span><br><span class="line">    h-&gt;orig = addr; <span class="comment">// 原函数地址</span></span><br><span class="line">    h-&gt;jump[<span class="number">0</span>] = <span class="number">0xe59ff000</span>; <span class="comment">// 把目标函数第一条指令改成 LDR pc, [pc, #0];跳转到PC指针所指的地址</span></span><br><span class="line">    h-&gt;jump[<span class="number">1</span>] = h-&gt;patch; <span class="comment">// 由于pc寄存器读出的值实际上是当前指令地址加8，所以我们把后面两处指令</span></span><br><span class="line">    h-&gt;jump[<span class="number">2</span>] = h-&gt;patch; <span class="comment">// 都保存为hook函数的地址，这样的话，我们就能控制PC跳转到hook函数的地址了。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="comment">// 保存原函数的前三条指令</span></span><br><span class="line">        h-&gt;store[i] = ((<span class="keyword">int</span>*)h-&gt;orig)[i];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="comment">// 将函数入口指令改成跳转指令</span></span><br><span class="line">        ((<span class="keyword">int</span>*)h-&gt;orig)[i] = h-&gt;jump[i];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 刷新指令的缓存。因为虽然前面的操作修改了内存中的指令，但有可能被修改的指令已经被缓存起来了   </span></span><br><span class="line">    hook_cacheflush((<span class="keyword">unsigned</span> <span class="keyword">int</span>)h-&gt;orig, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)h-&gt;orig + <span class="keyword">sizeof</span>(h-&gt;jump));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然android有ASLR，但并没有PIE，所以program image是固定在0x8000这个地址的，因此我们用mprotect()函数将整个target代码段变成RWX，这样我们就能修改函数入口处的代码了。是否修改成功可以通过cat /proc/[pid]/maps查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F; # cat &#x2F;proc&#x2F;18029&#x2F;maps</span><br><span class="line">00008000-0000a000 rwxp 00000000 b3:1c 671749     &#x2F;data&#x2F;local&#x2F;tmp&#x2F;target</span><br><span class="line">0000a000-0000b000 r--p 00001000 b3:1c 671749     &#x2F;data&#x2F;local&#x2F;tmp&#x2F;target</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>然后需要确定目标函数的地址，这个有两种方法。1）如果目标程序本身没有被strip的话，那些symbol都是存在的，因此可以使用dlopen()和dlsym()等方法来获取目标函数地址。但很多情况，目标程序都会被strip，特别是可以直接运行的二进制文件默认都会被直接strip。比如target中的targetFunc()这个函数名会在编译的时候去掉，所以使用dlsym()的话是无法找到这个函数的。2）这时候我们就需要使用IDA或者objdump来定位一下目标函数的地址。比如用IDA找一下target程序里面targetFunc(int number)这个函数的地址：<br><img src="/images/androidhook/targetFunc.png"><br>虽然target这个binary被strip了，但还是可以找到targetFunc()这个函数的起始地址是在0x84c4。一般ARM程序在IDA中打开后，自定义的函数都在<code>Functions window</code>的前几个：<br><img src="/images/androidhook/window.png"><br>最后一个参数也就是我们要执行的hook函数的地址。得到这个地址非常简单，因为是so中的函数，调用hook_direct()的时候直接写上函数名即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hook_direct(&amp;eph, hookaddr, hookFunc);</span><br></pre></td></tr></table></figure>
<p>hook_cacheflush()代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">inline</span> <span class="title">hook_cacheflush</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> begin, <span class="keyword">unsigned</span> <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> syscall = <span class="number">0xf0002</span>;</span><br><span class="line"> </span><br><span class="line">    __asm __volatile (</span><br><span class="line">        <span class="string">&quot;mov     r0, %0\n&quot;</span>         </span><br><span class="line">        <span class="string">&quot;mov     r1, %1\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov     r7, %2\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov     r2, #0x0\n&quot;</span></span><br><span class="line">        <span class="string">&quot;svc     0x00000000\n&quot;</span></span><br><span class="line">        :</span><br><span class="line">        :   <span class="string">&quot;r&quot;</span> (begin), <span class="string">&quot;r&quot;</span> (end), <span class="string">&quot;r&quot;</span> (syscall)</span><br><span class="line">        :   <span class="string">&quot;r0&quot;</span>, <span class="string">&quot;r1&quot;</span>, <span class="string">&quot;r7&quot;</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刷新完缓存后，再执行到原函数的时候，pc指针就会跳转到自定义的hook函数中了，hook函数里的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>  __attribute__ ((noinline)) hookFunc(<span class="keyword">int</span> number)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;targetFunc() called, number = %d\n&quot;</span>, number);</span><br><span class="line">    number *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*orig_targetFunc)(<span class="keyword">int</span> number);</span><br><span class="line">    orig_targetFunc = (<span class="keyword">void</span> *)eph.orig;</span><br><span class="line">    </span><br><span class="line">    hook_precall(&amp;eph);</span><br><span class="line">    orig_targetFunc(number);</span><br><span class="line">    hook_postcall(&amp;eph);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先在hook函数中，可以获得原函数的参数（参数已经在寄存器中了，编写hook函数的时候，参数与原函数相同即可），并且可以对原函数的参数进行修改，比如说将数字乘2。随后使用<code>hook_precall(&amp;eph);</code>将原本函数的内容进行还原。hook_precall()内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hook_precall</span><span class="params">(struct <span class="keyword">hook_t</span> *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        ((<span class="keyword">int</span>*)h-&gt;orig)[i] = h-&gt;store[i];</span><br><span class="line"> </span><br><span class="line">    hook_cacheflush((<span class="keyword">unsigned</span> <span class="keyword">int</span>)h-&gt;orig, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)h-&gt;orig+<span class="keyword">sizeof</span>(h-&gt;jump)*<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在hook_precall()中，先对原本的三条指令进行还原，然后使用hook_cacheflush()对内存进行刷新。经过处理之后，就可以执行原来的函数orig_targetFunc(number)了。执行完后，如果还想再次hook这个函数，就需要调用hook_postcall(&amp;eph)将原本的三条指令再进行一次修改。<br>下面用hook5和libinject2.so来注入以下target这个程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;target</span><br><span class="line">Hello, Hooking! 0</span><br><span class="line">Hello, Hooking! 1</span><br><span class="line">Hello, Hooking! 2</span><br><span class="line">Hello, Hooking! 3</span><br><span class="line">Hello, Hooking! 4</span><br><span class="line">Hello, Hooking! 5</span><br><span class="line">Hello, Hooking! 6</span><br><span class="line">Hook Function pid &#x3D; 18561</span><br><span class="line">Hello HookFunction</span><br><span class="line">addr  &#x3D; 84c4</span><br><span class="line">hookf &#x3D; b6ea3da5</span><br><span class="line">targetFunc() called, number &#x3D; 7</span><br><span class="line">Hello, Hooking! 14</span><br><span class="line">targetFunc() called, number &#x3D; 8</span><br><span class="line">Hello, Hooking! 16</span><br><span class="line">targetFunc() called, number &#x3D; 9</span><br><span class="line">Hello, Hooking! 18</span><br><span class="line">targetFunc() called, number &#x3D; 10</span><br><span class="line">Hello, Hooking! 20</span><br><span class="line">targetFunc() called, number &#x3D; 11</span><br><span class="line">Hello, Hooking! 22</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">root@hammerhead:&#x2F;data&#x2F;local&#x2F;tmp # .&#x2F;hook5 18561</span><br><span class="line">getting remote addres:</span><br><span class="line">mmap_addr&#x3D;0xb6ef9c5d dlopen_addr&#x3D;0xb6f49f31 dlsym_addr&#x3D;0xb6f49e81</span><br><span class="line">map_base &#x3D; 0xb6ea9000</span><br><span class="line">save so_path &#x3D; &#x2F;data&#x2F;local&#x2F;tmp&#x2F;libinject2.so to map_base &#x3D; 0xb6ea9000</span><br><span class="line">handle &#x3D; 0xb6f46494</span><br><span class="line">save function_name &#x3D; hookEntry to map_base &#x3D; 0xb6ea9000</span><br><span class="line">function_ptr &#x3D; 0xb6ea3e3d</span><br><span class="line">save parameter &#x3D; HookFunction to map_base &#x3D; 0xb6ea9000</span><br></pre></td></tr></table></figure>
<p><strong>reference</strong><br><a target="_blank" rel="noopener" href="http://drops.wooyun.org/tips/9300">http://drops.wooyun.org/tips/9300</a><br><a target="_blank" rel="noopener" href="http://drops.wooyun.org/papers/10156">http://drops.wooyun.org/papers/10156</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2016/06/28/Android-Hooking/" data-id="ckhe7o4ob0078chl73ixyd1ia" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/07/16/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          基于线程的并发编程
        
      </div>
    </a>
  
  
    <a href="/2016/06/20/Radare2%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Radare2使用说明</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ARM/" rel="tag">ARM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Blockchain/" rel="tag">Blockchain</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/" rel="tag">C/C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Crypto/" rel="tag">Crypto</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fuzzing/" rel="tag">Fuzzing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IoT/" rel="tag">IoT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kernel/" rel="tag">Kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Machine-Learning/" rel="tag">Machine Learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pwn/" rel="tag">Pwn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reverse/" rel="tag">Reverse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Symbolic-Execution/" rel="tag">Symbolic Execution</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tensorflow/" rel="tag">Tensorflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Virtual/" rel="tag">Virtual</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ARM/" style="font-size: 11px;">ARM</a> <a href="/tags/Algorithms/" style="font-size: 10px;">Algorithms</a> <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Blockchain/" style="font-size: 11px;">Blockchain</a> <a href="/tags/C-C/" style="font-size: 18px;">C/C++</a> <a href="/tags/Crypto/" style="font-size: 10px;">Crypto</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Fuzzing/" style="font-size: 15px;">Fuzzing</a> <a href="/tags/IoT/" style="font-size: 12px;">IoT</a> <a href="/tags/Java/" style="font-size: 14px;">Java</a> <a href="/tags/Kernel/" style="font-size: 19px;">Kernel</a> <a href="/tags/Machine-Learning/" style="font-size: 17px;">Machine Learning</a> <a href="/tags/Pwn/" style="font-size: 19px;">Pwn</a> <a href="/tags/Reverse/" style="font-size: 13px;">Reverse</a> <a href="/tags/Symbolic-Execution/" style="font-size: 12px;">Symbolic Execution</a> <a href="/tags/Tensorflow/" style="font-size: 10px;">Tensorflow</a> <a href="/tags/Virtual/" style="font-size: 16px;">Virtual</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/29/so%E6%96%87%E4%BB%B6%E7%9A%84-init-array%E6%AE%B5%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81/">so文件的.init_array段中添加代码</a>
          </li>
        
          <li>
            <a href="/2020/07/09/PID-namespace/">PID namespace</a>
          </li>
        
          <li>
            <a href="/2020/07/08/Mount-namespace/">Mount namespace</a>
          </li>
        
          <li>
            <a href="/2020/07/06/User-namespace/">User namespace</a>
          </li>
        
          <li>
            <a href="/2020/07/01/UnionFS%E6%8A%80%E6%9C%AF/">UnionFS技术</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>